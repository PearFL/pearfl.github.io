<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spark编译安装</title>
    <url>/2020/02/11/38.Spark%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1.JDK:Spark 2.2.0及以上版本只支持JDK1.8</p>
<p>2.Maven：3.6.3</p>
<ol>
<li><p>设置maven环境变量时，需设置maven内存：</p>
</li>
<li><p>export MAVEN_OPTS=”-Xmx2g -XX:ReservedCodeCacheSize=512m”</p>
</li>
</ol>
<p>3.Scala：2.13.1</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ol>
<li><p><strong>下载spark的tar包，并解压</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;spark&#x2F;spark-2.4.5&#x2F;spark-2.4.5.tgz</span><br><span class="line"># tar -xzvf spark-2.4.5.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编辑dev/make-distribution.sh</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  vi dev&#x2F;make-distribution.sh</span><br></pre></td></tr></table></figure>


<p>注释以下内容：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#VERSION&#x3D;$(&quot;$MVN&quot; help:evaluate -Dexpression&#x3D;project.version $@ 2&gt;&#x2F;dev&#x2F;null | grep -v &quot;INFO&quot; | tail -n 1)</span><br><span class="line">#SCALA_VERSION&#x3D;$(&quot;$MVN&quot; help:evaluate -Dexpression&#x3D;scala.binary.version $@ 2&gt;&#x2F;dev&#x2F;null\</span><br><span class="line">#    | grep -v &quot;INFO&quot;\</span><br><span class="line">#    | tail -n 1)</span><br><span class="line">#SPARK_HADOOP_VERSION&#x3D;$(&quot;$MVN&quot; help:evaluate -Dexpression&#x3D;hadoop.version $@ 2&gt;&#x2F;dev&#x2F;null\</span><br><span class="line">#    | grep -v &quot;INFO&quot;\</span><br><span class="line">#    | tail -n 1)</span><br><span class="line">#SPARK_HIVE&#x3D;$(&quot;$MVN&quot; help:evaluate -Dexpression&#x3D;project.activeProfiles -pl sql&#x2F;hive $@ 2&gt;&#x2F;dev&#x2F;null\</span><br><span class="line">#    | grep -v &quot;INFO&quot;\</span><br><span class="line">#    | fgrep --count &quot;&lt;id&gt;hive&lt;&#x2F;id&gt;&quot;;\</span><br><span class="line">#    # Reset exit status to 0, otherwise the script stops here if the last grep finds nothing\</span><br><span class="line">#    # because we use &quot;set -o pipefail&quot;</span><br><span class="line">#    echo -n)</span><br></pre></td></tr></table></figure>

<p> 添加以下内容：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VERSION&#x3D;2.4.5</span><br><span class="line">SCALA_VERSION&#x3D;2.13</span><br><span class="line">SPARK_HADOOP_VERSION&#x3D;2.6.0-cdh5.16.2</span><br><span class="line">SPARK_HIVE&#x3D;1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>编辑pom.xml</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加</span><br><span class="line"></span><br><span class="line">&lt;repository&gt;</span><br><span class="line"></span><br><span class="line">      &lt;id&gt;clouders&lt;&#x2F;id&gt;</span><br><span class="line"></span><br><span class="line">      &lt;name&gt;clouders Repository&lt;&#x2F;name&gt;</span><br><span class="line"></span><br><span class="line">      &lt;url&gt;https:&#x2F;&#x2F;repository.cloudera.com&#x2F;artifactory&#x2F;cloudera-repos&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;repository&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装</strong></p>
<p>在解压后的spark目录下</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># $ .&#x2F;dev&#x2F;make-distribution.sh --name 2.6.0-cdh5.16.2 --tgz -Dhadoop.version&#x3D;2.6.0-cdh5.16.2 -Phadoop-2.6 -Phive -Phive-thriftserver -Pyarn</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>spark</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala安装</title>
    <url>/2020/02/10/37.Scala%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>需要预先安装好jdk8+</p>
<p>已经下载好scala包放置于software目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -zxvf scala-2.13.1.tgz -C ~&#x2F;app&#x2F;</span><br><span class="line"># vi ~&#x2F;.bash_profile</span><br><span class="line">export SCALA_HOME&#x3D;&#x2F;root&#x2F;app&#x2F;scala-2.13.1</span><br><span class="line">export PATH&#x3D;$SCALA_HOME&#x2F;bin:$PATH</span><br><span class="line"># source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>



<p>非常的简单哟</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底明白Java的值传递和引用传递</title>
    <url>/2020/02/10/36.%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDJava%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/bntx2jsqfehy7/article/details/83508006" target="_blank" rel="noopener">https://blog.csdn.net/bntx2jsqfehy7/article/details/83508006</a></p>
<h2 id="一、形参与实参"><a href="#一、形参与实参" class="headerlink" title="一、形参与实参"></a>一、形参与实参</h2><ol>
<li>形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了</li>
<li>实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</li>
</ol>
<h2 id="二、-java的数据类型"><a href="#二、-java的数据类型" class="headerlink" title="二、 java的数据类型"></a>二、 java的数据类型</h2><p>所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行</p>
<p>数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</p>
<p>所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。</p>
<a id="more"></a>

<p>1.基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>种整数类型：<span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">int</span>、<span class="keyword">long</span></span><br><span class="line"><span class="number">2</span>种浮点数类型：<span class="keyword">float</span>、<span class="keyword">double</span></span><br><span class="line"><span class="number">1</span>种字符类型：<span class="keyword">char</span></span><br><span class="line"><span class="number">1</span>种布尔类型：<span class="keyword">boolean</span></span><br></pre></td></tr></table></figure>

<p>2.引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类</span><br><span class="line">接口</span><br><span class="line">数组</span><br></pre></td></tr></table></figure>

<p>有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。</p>
<h2 id="三、JVM内存的划分及职能"><a href="#三、JVM内存的划分及职能" class="headerlink" title="三、JVM内存的划分及职能"></a>三、JVM内存的划分及职能</h2><p>Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：</p>
<p><img src="/images/36/36_1.png" alt="36_1"></p>
<p>有图可以看出：Java代码被编译器编译成字节码之后，JVM开辟一片内存空间（也叫运行时数据区），通过类加载器加到到运行时数据区来存储程序执行期间需要用到的数据和相关信息，在这个数据区中，它由以下几部分组成：</p>
<ol>
<li><p>虚拟机栈</p>
</li>
<li><p>堆</p>
</li>
<li><p>程序计数器</p>
</li>
<li><p>方法区</p>
</li>
<li><p>本地方法栈</p>
</li>
</ol>
<p>我们接着来了解一下每部分的原理以及具体用来存储程序执行过程中的哪些数据。</p>
<h3 id="1-虚拟机栈"><a href="#1-虚拟机栈" class="headerlink" title="1.虚拟机栈"></a>1.虚拟机栈</h3><p>虚拟机栈是Java方法执行的内存模型，栈中存放着栈帧，每个栈帧分别对应一个被调用的方法，方法的调用过程对应栈帧在虚拟机中入栈到出栈的过程。</p>
<p>栈是线程私有的，也就是线程之间的栈是隔离的；当程序中某个线程开始执行一个方法时就会相应的创建一个栈帧并且入栈（位于栈顶），在方法结束后，栈帧出栈。</p>
<p>下图表示了一个Java栈的模型以及栈帧的组成：</p>
<p><img src="/images/36/36_2.png" alt="36_2"></p>
<p><strong>栈帧</strong>:是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>
<p>每个栈帧中包括：</p>
<ol>
<li><strong>局部变量表</strong>:用来存储方法中的局部变量（非静态变量、函数形参）。当变量为基本数据类型时，直接存储值，当变量为引用类型时，存储的是指向具体对象的引用。</li>
<li><strong>操作数栈</strong>:Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，其中所指的栈就是指操作数栈。</li>
<li><strong>指向运行时常量池的引用</strong>:存储程序执行时可能用到常量的引用。</li>
<li><strong>方法返回地址</strong>:存储方法执行完成后的返回地址。</li>
</ol>
<h3 id="2-堆"><a href="#2-堆" class="headerlink" title="2.堆"></a>2.堆</h3><p>堆是用来存储对象本身和数组的，在JVM中只有一个堆，因此，堆是被所有线程共享的。</p>
<h3 id="3-方法区"><a href="#3-方法区" class="headerlink" title="3.方法区"></a>3.方法区</h3><p>方法区是一块所有线程共享的内存逻辑区域，在JVM中只有一个方法区，用来存储一些线程可共享的内容，它是线程安全的，多个线程同时访问方法区中同一个内容时，只能有一个线程装载该数据，其它线程只能等待。</p>
<p>方法区可存储的内容有：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、常量池（字段，方法信息，静态变量，类型引用（class））等。</p>
<h3 id="4-本地方法栈："><a href="#4-本地方法栈：" class="headerlink" title="4.本地方法栈："></a>4.本地方法栈：</h3><p>本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。</p>
<h3 id="5-程序计数器"><a href="#5-程序计数器" class="headerlink" title="5. 程序计数器"></a>5. 程序计数器</h3><p>线程私有的。<br>记录着当前线程所执行的字节码的行号指示器，在程序运行过程中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p>
<h2 id="四、数据如何在内存中存储"><a href="#四、数据如何在内存中存储" class="headerlink" title="四、数据如何在内存中存储"></a>四、数据如何在内存中存储</h2><p>从上面程序运行图我们可以看到，JVM在程序运行时的内存分配有三个地方：</p>
<ul>
<li>堆</li>
<li>栈</li>
<li>静态方法区</li>
<li>常量区</li>
</ul>
<p>相应地，每个存储区域都有自己的内存分配策略：</p>
<ul>
<li>堆式</li>
<li>栈式</li>
<li>静态</li>
</ul>
<p>我们已经知道：Java中的数据类型有基本数据类型和引用数据类型，那么这些数据的存储都使用哪一种策略呢？<br>这里要分以下的情况进行探究：</p>
<p><strong>1.基本数据类型的存储：</strong></p>
<ul>
<li>A、基本数据类型的局部变量</li>
<li>B、基本数据类型的成员变量</li>
<li>C、基本数据类型的静态变量</li>
</ul>
<p><strong>2、引用数据类型的存储</strong></p>
<h4 id="1-基本数据类型的存储"><a href="#1-基本数据类型的存储" class="headerlink" title="1.基本数据类型的存储"></a>1.基本数据类型的存储</h4><p>我们分别来研究一下：</p>
<p><strong>A.基本数据类型的局部变量</strong></p>
<p>1.定义基本数据类型的局部变量以及数据都是直接存储在内存中的栈上，也就是前面说到的<strong>“虚拟机栈”</strong>，数据本身的值就是存储在栈空间里面。</p>
<p><img src="/images/36/36_3.png" alt="36_3"></p>
<p>如上图，在方法内定义的变量直接存储在栈中，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int age&#x3D;50;</span><br><span class="line">int weight&#x3D;50;</span><br><span class="line">int grade&#x3D;6;</span><br></pre></td></tr></table></figure>

<p>当我们写“int age=50；”，其实是分为两步的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int age;&#x2F;&#x2F;定义变量</span><br><span class="line">age&#x3D;50;&#x2F;&#x2F;赋值</span><br></pre></td></tr></table></figure>

<p>首先JVM创建一个名为age的变量，存于局部变量表中，然后去栈中查找是否存在有字面量值为50的内容，如果有就直接把age指向这个地址，如果没有，JVM会在栈中开辟一块空间来存储“50”这个内容，并且把age指向这个地址。因此我们可以知道：<br><strong>我们声明并初始化基本数据类型的局部变量时，变量名以及字面量值都是存储在栈中，而且是真实的内容。</strong></p>
<p>我们再来看“int weight=50；”，按照刚才的思路：字面量为50的内容在栈中已经存在，因此weight是直接指向这个地址的。由此可见：<strong>栈中的数据在当前线程下是共享的</strong>。</p>
<p>那么如果再执行下面的代码呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weight&#x3D;40；</span><br></pre></td></tr></table></figure>

<p>当代码中重新给weight变量进行赋值时，JVM会去栈中寻找字面量为40的内容，发现没有，就会开辟一块内存空间存储40这个内容，并且把weight指向这个地址。由此可知：</p>
<p><strong>基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存存新数据，并且把要重新赋值的局部变量的引用指向新数据所在地址。</strong></p>
<p><strong>B.</strong>基本数据类型的成员变量****</p>
<p>成员变量：顾名思义，就是在类体中定义的变量。<br>看下图：</p>
<p><img src="/images/36/36_4.jpg" alt="36_4"></p>
<p>我们看per的地址指向的是堆内存中的一块区域，我们来还原一下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">	private int age;</span><br><span class="line">	private String name;</span><br><span class="line">	private int grade;</span><br><span class="line">	&#x2F;&#x2F;篇幅较长，省略setter getter方法</span><br><span class="line">	static void run()&#123;</span><br><span class="line">	System.out.println(&quot;run....&quot;); </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">Person per&#x3D;new Person();</span><br></pre></td></tr></table></figure>

<p>同样是局部变量的age、name、grade却被存储到了堆中为per对象开辟的一块空间中。因此可知：<strong>基本数据类型的成员变量名和值都存储于堆中，其生命周期和对象的是一致的。</strong></p>
<h5 id="C-基本数据类型的静态变量"><a href="#C-基本数据类型的静态变量" class="headerlink" title="C. 基本数据类型的静态变量"></a><strong>C. 基本数据类型的静态变量</strong></h5><p>前面提到<strong>方法区</strong>用来存储一些共享数据，因此<strong>基本数据类型的静态变量名以及值存储于方法区的运行时常量池中，静态变量随类加载而加载，随类消失而消失</strong></p>
<h4 id="2-引用数据类型的存储"><a href="#2-引用数据类型的存储" class="headerlink" title="2.引用数据类型的存储"></a>2.引用数据类型的存储</h4><p>上面提到：堆是用来存储对象本身和数组，而引用（句柄）存放的是实际内容的地址值，因此通过上面的程序运行图，也可以看出，当我们定义一个对象时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person per&#x3D;new Person();</span><br></pre></td></tr></table></figure>

<p>实际上，它也是有两个过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person per;&#x2F;&#x2F;定义变量</span><br><span class="line">per&#x3D;new Person();&#x2F;&#x2F;赋值</span><br></pre></td></tr></table></figure>

<p>在执行Person per;时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=new Person()时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。因此可见：<br><strong>对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。</strong></p>
<h2 id="6-值传递和引用传递"><a href="#6-值传递和引用传递" class="headerlink" title="6.值传递和引用传递"></a>6.值传递和引用传递</h2><p>前面已经介绍过形参和实参，也介绍了数据类型以及数据在内存中的存储形式，接下来，就是文章的主题：值传递和引用的传递。</p>
<p><strong>值传递：</strong></p>
<p>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</p>
<p>来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void valueCrossTest(int age,float weight)&#123;</span><br><span class="line">    System.out.println(&quot;传入的age：&quot;+age);</span><br><span class="line">    System.out.println(&quot;传入的weight：&quot;+weight);</span><br><span class="line">    age&#x3D;33;</span><br><span class="line">    weight&#x3D;89.5f;</span><br><span class="line">    System.out.println(&quot;方法内重新赋值后的age：&quot;+age);</span><br><span class="line">    System.out.println(&quot;方法内重新赋值后的weight：&quot;+weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int a&#x3D;25;</span><br><span class="line">        float w&#x3D;77.5f;</span><br><span class="line">        valueCrossTest(a,w);</span><br><span class="line">        System.out.println(&quot;方法执行后的age：&quot;+a);</span><br><span class="line">        System.out.println(&quot;方法执行后的weight：&quot;+w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传入的age：25</span><br><span class="line">传入的weight：77.5</span><br><span class="line"></span><br><span class="line">方法内重新赋值后的age：33</span><br><span class="line">方法内重新赋值后的weight：89.5</span><br><span class="line"></span><br><span class="line">方法执行后的age：25</span><br><span class="line">方法执行后的weight：77.5</span><br></pre></td></tr></table></figure>

<p>从上面的打印结果可以看到：<br>a和w作为实参传入valueCrossTest之后，无论在方法内做了什么操作，最终a和w都没变化。</p>
<p>这是什么造型呢？！！</p>
<p>下面我们根据上面学到的知识点，进行详细的分析：</p>
<p>首先程序运行时，调用mian()方法，此时JVM为main()方法往虚拟机栈中压入一个栈帧，即为当前栈帧，用来存放main()中的局部变量表(包括参数)、操作栈、方法出口等信息，如a和w都是mian()方法中的局部变量，因此可以断定，a和w是躺着mian方法所在的栈帧中<br>如图：</p>
<p><img src="/images/36/36_5.png" alt="36_5"></p>
<p>而当执行到valueCrossTest()方法时，JVM也为其往虚拟机栈中压入一个栈，即为当前栈帧，用来存放valueCrossTest()中的局部变量等信息，因此age和weight是躺着valueCrossTest方法所在的栈帧中，而他们的值是从a和w的值copy了一份副本而得，如图：</p>
<p><img src="/images/36/36_6.png" alt="36_6"></p>
<p>因而可以a和age、w和weight对应的内容是不一致的，所以当在方法内重新赋值时，实际流程如图：</p>
<p><img src="/images/36/36_7.png" alt="36_7"></p>
<p>也就是说，age和weight的改动，只是改变了当前栈帧（valueCrossTest方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，mian方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。<br>因此：<br><strong>值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。</strong></p>
<p><strong>引用传递：</strong><br>”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。</p>
<p>举个例子：<br>先定义一个对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">        public int getAge() &#123;</span><br><span class="line">            return age;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setAge(int age) &#123;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写个函数测试一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void PersonCrossTest(Person person)&#123;</span><br><span class="line">        System.out.println(&quot;传入的person的name：&quot;+person.getName());</span><br><span class="line">        person.setName(&quot;我是张小龙&quot;);</span><br><span class="line">        System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Person p&#x3D;new Person();</span><br><span class="line">        p.setName(&quot;我是马化腾&quot;);</span><br><span class="line">        p.setAge(45);</span><br><span class="line">        PersonCrossTest(p);</span><br><span class="line">        System.out.println(&quot;方法执行后的name：&quot;+p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传入的person的name：我是马化腾</span><br><span class="line">方法内重新赋值后的name：我是张小龙</span><br><span class="line">方法执行后的name：我是张小龙</span><br></pre></td></tr></table></figure>

<p>可以看出，person经过personCrossTest()方法的执行之后，内容发生了改变，这印证了上面所说的<strong>“引用传递”</strong>，对形参的操作，改变了实际对象的内容。</p>
<p>那么，到这里就结题了吗？<br>不是的，没那么简单，<br>能看得到想要的效果<br>是因为刚好选对了例子而已！！！</p>
<p>下面我们对上面的例子稍作修改，加上一行代码，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void PersonCrossTest(Person person)&#123;</span><br><span class="line">    System.out.println(&quot;传入的person的name：&quot;+person.getName());</span><br><span class="line">    person&#x3D;new Person();&#x2F;&#x2F;加多此行代码</span><br><span class="line">    person.setName(&quot;我是张小龙&quot;);</span><br><span class="line">    System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传入的person的name：我是马化腾</span><br><span class="line">方法内重新赋值后的name：我是张小龙</span><br><span class="line">方法执行后的name：我是马化腾</span><br></pre></td></tr></table></figure>

<p>为什么这次的输出和上次的不一样了呢？<br>看出什么问题了吗？</p>
<p>按照上面讲到JVM内存模型可以知道，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到main（）方法中的下列代码时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p&#x3D;new Person();</span><br><span class="line">p.setName(&quot;我是马化腾&quot;);</span><br><span class="line">p.setAge(45);</span><br><span class="line">PersonCrossTest(p);</span><br></pre></td></tr></table></figure>

<p>JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：</p>
<p><img src="/images/36/36_8.png" alt="36_8"></p>
<p>当执行到PersonCrossTest()方法时，因为方法内有这么一行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person&#x3D;new Person();</span><br></pre></td></tr></table></figure>

<p>JVM需要在堆内另外开辟一块内存来存储new Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：<strong>引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变</strong>。</p>
<p>可以推出：实参也应该指向了新创建的person对象的地址，所以在执行PersonCrossTest()结束之后，最终输出的应该是后面创建的对象内容。</p>
<p>然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。</p>
<p>由此可见：<strong>引用传递，在Java中并不存在。</strong></p>
<p>但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？</p>
<p>这是因为：<strong>无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。</strong></p>
<p><img src="/images/36/36_9.png" alt="36_9"></p>
<p>有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：</p>
<p><strong>p和person都是指向同一个对象</strong>。</p>
<p>因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。而在第二个例子中，当执行到new Person()之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：</p>
<p><strong>p依旧是指向旧的对象，person指向新对象的地址。</strong></p>
<p>所以此时<strong>对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系</strong>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>因此可见：在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。<br>只是在传递过程中：</p>
<p><strong>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</strong></p>
<p><strong>如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</strong></p>
<p>以上为小编关于“值传递和引用传递”问题的思考和论证，对于这个问题，历来都是多有争论，在此希望和读者一起探讨和学习，有不同意见或者建议请假小编微信：sisi-ceo。理性评论，不喜勿喷。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集简述</title>
    <url>/2020/02/10/34.%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> par[MAX_N];</span><br><span class="line"><span class="keyword">int</span> rank[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化n个元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		par[i] = i;</span><br><span class="line">		rank[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询树的根 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(par[x] == x)&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并x和y所属的集合 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	x = <span class="built_in">find</span>(x);</span><br><span class="line">	y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(rank[x] &lt; rank[y])&#123;</span><br><span class="line">		par[x] = y;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		par[y] = x;</span><br><span class="line">		<span class="keyword">if</span>(rank[x] == rank[y]) rank[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断x和y是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>并查集简述</title>
    <url>/2020/02/10/35.JAVA%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> par[MAX_N];</span><br><span class="line"><span class="keyword">int</span> rank[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化n个元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		par[i] = i;</span><br><span class="line">		rank[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询树的根 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(par[x] == x)&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并x和y所属的集合 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	x = <span class="built_in">find</span>(x);</span><br><span class="line">	y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(rank[x] &lt; rank[y])&#123;</span><br><span class="line">		par[x] = y;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		par[y] = x;</span><br><span class="line">		<span class="keyword">if</span>(rank[x] == rank[y]) rank[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断x和y是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Eratosthenes 素数筛选</title>
    <url>/2020/02/10/33.Eratosthenes%20%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89/</url>
    <content><![CDATA[<h3 id="Eratosthenes-素数筛选"><a href="#Eratosthenes-素数筛选" class="headerlink" title="Eratosthenes 素数筛选"></a>Eratosthenes 素数筛选</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j +=i) &#123;</span><br><span class="line">             is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后时间复杂度比O(NloglogN)还要低</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>maven安装</title>
    <url>/2020/02/09/31.maven%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>官网下载链接：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p>
<p>下载后我放置在服务器用户根目录的software文件夹下，现在我们解压到app下面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -zxvf apache-maven-3.6.3-bin.tar.gz -C ~&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure>

<p>在app文件夹下，开始操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入maven文件夹</span><br><span class="line"># cd apache-maven-3.6.3&#x2F;</span><br><span class="line">pwd获取当前的路径</span><br><span class="line"># vi ~&#x2F;.bash_profile</span><br><span class="line">export MAVEN_HOME&#x3D;&#x2F;root&#x2F;app&#x2F;apache-maven-3.6.3</span><br><span class="line">export PATH&#x3D;$MAVEN_HOME&#x2F;bin:$PATH</span><br><span class="line"># source ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line">可以通过mvn -v检查是否生效</span><br></pre></td></tr></table></figure>



<p>完成后，conf内有些数据建议更改一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd conf</span><br><span class="line"># vi settings.xml</span><br><span class="line">  &lt;!-- localRepository</span><br><span class="line">   | The path to the local repository maven will use to store artifacts.</span><br><span class="line">   |</span><br><span class="line">   | Default: $&#123;user.home&#125;&#x2F;.m2&#x2F;repository</span><br><span class="line">  &lt;localRepository&gt;&#x2F;path&#x2F;to&#x2F;local&#x2F;repo&lt;&#x2F;localRepository&gt;</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;localRepository&gt;&#x2F;root&#x2F;maven_repos&#x2F;&lt;&#x2F;localRepository&gt;</span><br></pre></td></tr></table></figure>

<p>/root/maven_repos/ 位置存放你下载的包，这个根据个人需求修改</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>linux上的maven安装</title>
    <url>/2020/02/09/32.linux%E4%B8%8A%E7%9A%84maven%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>官网下载链接：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p>
<p>下载后我放置在服务器用户根目录的software文件夹下，现在我们解压到app下面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -zxvf apache-maven-3.6.3-bin.tar.gz -C ~&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure>

<p>在app文件夹下，开始操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入maven文件夹</span><br><span class="line"># cd apache-maven-3.6.3&#x2F;</span><br><span class="line">pwd获取当前的路径</span><br><span class="line"># vi ~&#x2F;.bash_profile</span><br><span class="line">export MAVEN_HOME&#x3D;&#x2F;root&#x2F;app&#x2F;apache-maven-3.6.3</span><br><span class="line">export PATH&#x3D;$MAVEN_HOME&#x2F;bin:$PATH</span><br><span class="line"># source ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line">可以通过mvn -v检查是否生效</span><br></pre></td></tr></table></figure>



<p>完成后，conf内有些数据建议更改一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd conf</span><br><span class="line"># vi settings.xml</span><br><span class="line">  &lt;!-- localRepository</span><br><span class="line">   | The path to the local repository maven will use to store artifacts.</span><br><span class="line">   |</span><br><span class="line">   | Default: $&#123;user.home&#125;&#x2F;.m2&#x2F;repository</span><br><span class="line">  &lt;localRepository&gt;&#x2F;path&#x2F;to&#x2F;local&#x2F;repo&lt;&#x2F;localRepository&gt;</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;localRepository&gt;&#x2F;root&#x2F;maven_repos&#x2F;&lt;&#x2F;localRepository&gt;</span><br></pre></td></tr></table></figure>

<p>/root/maven_repos/ 位置存放你下载的包，这个根据个人需求修改</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-962（单调栈）</title>
    <url>/2020/02/09/30.leetcode-962%EF%BC%88%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 A，坡是元组 (i, j)，其中  i &lt; j 且 A[i] &lt;&#x3D; A[j]。这样的坡的宽度为 j - i。</span><br><span class="line"></span><br><span class="line">找出 A 中的坡的最大宽度，如果不存在，返回 0 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;maximum-width-ramp</span><br><span class="line"></span><br><span class="line">实例1：</span><br><span class="line">输入：[6,0,8,2,1,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">最大宽度的坡为 (i, j) &#x3D; (1, 5): A[1] &#x3D; 0 且 A[5] &#x3D; 5.</span><br><span class="line"></span><br><span class="line">实例2：</span><br><span class="line">输入：[9,8,1,0,1,9,4,0,4,1]</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">最大宽度的坡为 (i, j) &#x3D; (2, 9): A[2] &#x3D; 1 且 A[9] &#x3D; 1.</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1.	2 &lt;&#x3D; A.length &lt;&#x3D; 50000</span><br><span class="line">2.	0 &lt;&#x3D; A[i] &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>



<p>思路：找到当前元素左边第一个比它小的元素，很明显采用单调栈的方法</p>
<p>单调栈应用范围：<br>求解数组中元素右边第一个比它小的元素的下标，从前往后，构造单调递增栈；<br>求解数组中元素右边第一个比它大的元素的下标，从前往后，构造单调递减栈；<br>求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递减栈；<br>求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递增栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stacks = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stacks.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> length = A.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt;= A[stacks.peek()]) &#123;</span><br><span class="line">                stacks.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stacks.isEmpty() &amp;&amp; A[i] &gt;= A[stacks.peek()]) &#123;</span><br><span class="line">                max = Math.max(max, i - stacks.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mapreduce解析json数据</title>
    <url>/2020/02/09/29.mapreduce%E8%A7%A3%E6%9E%90json%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入数据</span><br><span class="line">&#123;&quot;status&quot;:&quot;0&quot;,&quot;message&quot;:&quot;成功&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;mxh&quot; , &quot;age&quot;:22 , &quot;cars&quot;:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Porsche&quot;&#125;,&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;BMW&quot;&#125;]&#125;&#125;</span><br><span class="line">&#123;&quot;status&quot;:&quot;0&quot;,&quot;message&quot;:&quot;成功&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;mxh&quot; , &quot;age&quot;:22 , &quot;cars&quot;:[ &quot;Porsche&quot;, &quot;BMW&quot;, &quot;Volvo&quot; ]&#125;&#125;</span><br><span class="line">&#123;&quot;status&quot;:&quot;0&quot;,&quot;message&quot;:&quot;成功&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;mxh&quot; , &quot;age&quot;:22 , &quot;male&quot;:true&#125;&#125;</span><br><span class="line"></span><br><span class="line">输出数据</span><br><span class="line">0	成功	mxh	22	1	Porsche	2	BMW	</span><br><span class="line">0	成功	mxh	22	Porsche	BMW	Volvo	</span><br><span class="line">0	成功	mxh	22	true</span><br></pre></td></tr></table></figure>

<p>解析采用jackson</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String input = <span class="string">"data/json/data.txt"</span>;</span><br><span class="line">        String output = <span class="string">"out"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1:获取job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除已存在目录</span></span><br><span class="line">        FileUtils.deleteOutput(configuration,output);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2：本job对应执行的主类</span></span><br><span class="line">        job.setJarByClass(JsonDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3）设置Mapper</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4）设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5）设置输入和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6）提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">NullWritable</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key,Text values,Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException</span>&#123;</span><br><span class="line">            String str = values.toString();</span><br><span class="line">            String out = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            JsonNode root = mapper.readTree(str);</span><br><span class="line"></span><br><span class="line">            Iterator&lt;JsonNode&gt; elements = root.elements();</span><br><span class="line">            out = dfs(elements, out);</span><br><span class="line">            out = out.replace(<span class="string">"\""</span>,<span class="string">""</span>);</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(out),NullWritable.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dfs</span><span class="params">(Iterator&lt;JsonNode&gt; elements, String out)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(elements.hasNext())&#123;</span><br><span class="line">            JsonNode node = elements.next();</span><br><span class="line">            <span class="keyword">if</span>(node.isObject())&#123;</span><br><span class="line">                Iterator&lt;JsonNode&gt; e = node.elements();</span><br><span class="line">                out = dfs(e, out);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.isArray())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;node.size();i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(node.get(i).isObject())&#123;</span><br><span class="line">                        Iterator&lt;JsonNode&gt; e2 = node.elements();</span><br><span class="line">                        out = dfs(e2, out);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        out = out + node.get(i) + <span class="string">'\t'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                out = out + node.toString() + <span class="string">'\t'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>mapreduce</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈jackson</title>
    <url>/2020/02/08/28.%E6%B5%85%E8%B0%88jackson/</url>
    <content><![CDATA[<p>官方文档：<a href="https://github.com/FasterXML/jackson-docs" target="_blank" rel="noopener">https://github.com/FasterXML/jackson-docs</a></p>
<p>Jackson是当前用的比较广泛的，用来序列化和反序列化json的Java开源框架。Jackson社区相对比较活跃，更新速度也比较快， 从Github中的统计来看，Jackson是最流行的json解析器之一，Spring MVC的默认json解析器便是Jackson。</p>
<p>Jackson优点很多：</p>
<ol>
<li><p>Jackson 所依赖的jar包较少，简单易用。</p>
</li>
<li><p>与其他 Java 的 json 的框架 Gson 等相比，Jackson 解析大的 json 文件速度比较快。</p>
</li>
<li><p>Jackson 运行时占用内存比较低，性能比较好</p>
</li>
<li><p>Jackson 有灵活的 API，可以很容易进行扩展和定制。</p>
</li>
</ol>
<p>Jackson 的核心模块由三部分组成：</p>
<ol>
<li>jackson-core 核心包，提供基于”流模式”解析的相关 API，它包括 JsonPaser 和 JsonGenerator。Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json。</li>
<li>jackson-annotations 注解包，提供标准注解功能；</li>
<li>jackson-databind 数据绑定包，提供基于”对象绑定” 解析的相关 API（ ObjectMapper ）和”树模型” 解析的相关 API（JsonNode）；基于”对象绑定” 解析的 API 和”树模型”解析的 API 依赖基于”流模式”解析的 API。</li>
</ol>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊正则表达式</title>
    <url>/2020/02/07/27.%E8%81%8A%E8%81%8A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则学习文章推荐（本篇博文为转载）：<a href="https://github.com/cdoco/learn-regex-zh" target="_blank" rel="noopener">https://github.com/cdoco/learn-regex-zh</a></p>
<p>正则表达式测试工具：<a href="https://c.runoob.com/front-end/854" target="_blank" rel="noopener">https://c.runoob.com/front-end/854</a></p>
<h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h2><p>正则表达式只是我们用于在文本中检索字母和数字的模式。例如正则表达式 <code>cat</code>，表示: 字母 <code>c</code> 后面跟着一个字母 <code>a</code>，再后面跟着一个字母 <code>t</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;cat&quot; &#x3D;&gt; The cat sat on the mat</span><br></pre></td></tr></table></figure>

<p>正则表达式 <code>123</code> 会匹配字符串 “123”。通过将正则表达式中的每个字符逐个与要匹配的字符串中的每个字符进行比较，来完成正则匹配。 正则表达式通常区分大小写，因此正则表达式 <code>Cat</code> 与字符串 “cat” 不匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Cat&quot; &#x3D;&gt; The cat sat on the Cat</span><br></pre></td></tr></table></figure>

<h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><p>元字符是正则表达式的基本组成元素。元字符在这里跟它通常表达的意思不一样，而是以某种特殊的含义去解释。有些元字符写在方括号内的时候有特殊含义。 元字符如下:</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的任意字符。</td>
</tr>
<tr>
<td>[ ]</td>
<td>字符类，匹配方括号中包含的任意字符。</td>
</tr>
<tr>
<td>[^ ]</td>
<td>否定字符类。匹配方括号中不包含的任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>花括号，匹配前面字符至少 n 次，但是不超过 m 次。</td>
</tr>
<tr>
<td>(xyz)</td>
<td>字符组，按照确切的顺序匹配字符xyz。</td>
</tr>
<tr>
<td>|</td>
<td>分支结构，匹配符号之前的字符或后面的字符。</td>
</tr>
<tr>
<td>\</td>
<td>转义符，它可以还原元字符原来的含义，允许你匹配保留字符 `[ ] ( ) { } . * + ? ^ $ \</td>
</tr>
<tr>
<td>^</td>
<td>匹配行的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配行的结束</td>
</tr>
</tbody></table>
<h2 id="2-1-英文句号"><a href="#2-1-英文句号" class="headerlink" title="2.1 英文句号"></a>2.1 英文句号</h2><p>英文句号 <code>.</code> 是元字符的最简单的例子。元字符 <code>.</code> 可以匹配任意单个字符。它不会匹配换行符和新行的字符。例如正则表达式 <code>.ar</code>，表示: 任意字符后面跟着一个字母 <code>a</code>， 再后面跟着一个字母 <code>r</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;.ar&quot; &#x3D;&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>

<h2 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h2><p>字符集也称为字符类。方括号被用于指定字符集。使用字符集内的连字符来指定字符范围。方括号内的字符范围的顺序并不重要。 例如正则表达式 <code>[Tt]he</code>，表示: 大写 <code>T</code> 或小写 <code>t</code> ，后跟字母 <code>h</code>，再后跟字母 <code>e</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[Tt]he&quot; &#x3D;&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>

<p>然而，字符集中的英文句号表示它字面的含义。正则表达式 <code>ar[.]</code>，表示小写字母 <code>a</code>，后面跟着一个字母 <code>r</code>，再后面跟着一个英文句号 <code>.</code> 字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;ar[.]&quot; &#x3D;&gt; A garage is a good place to park a car.</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h3><p>一般来说插入字符 <code>^</code> 表示一个字符串的开始，但是当它在方括号内出现时，它会取消字符集。例如正则表达式 <code>[^c]ar</code>，表示: 除了字母 <code>c</code> 以外的任意字符，后面跟着字符 <code>a</code>， 再后面跟着一个字母 <code>r</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[^c]ar&quot; &#x3D;&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>

<h2 id="2-3-重复"><a href="#2-3-重复" class="headerlink" title="2.3 重复"></a>2.3 重复</h2><p>以下元字符 <code>+</code>，<code>*</code> 或 <code>?</code> 用于指定子模式可以出现多少次。这些元字符在不同情况下的作用不同。</p>
<h3 id="2-3-1-星号"><a href="#2-3-1-星号" class="headerlink" title="2.3.1 星号"></a>2.3.1 星号</h3><p>该符号 <code>*</code> 表示匹配上一个匹配规则的零次或多次。正则表达式 <code>a*</code> 表示小写字母 <code>a</code> 可以重复零次或者多次。但是它如果出现在字符集或者字符类之后，它表示整个字符集的重复。 例如正则表达式 <code>[a-z]*</code>，表示: 一行中可以包含任意数量的小写字母。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[a-z]*&quot; &#x3D;&gt; The car parked in the garage #21.</span><br></pre></td></tr></table></figure>

<p>该 <code>*</code> 符号可以与元符号 <code>.</code> 用在一起，用来匹配任意字符串 <code>.*</code>。该 <code>*</code> 符号可以与空格符 <code>\s</code> 一起使用，用来匹配一串空格字符。 例如正则表达式 <code>\s*cat\s*</code>，表示: 零个或多个空格，后面跟小写字母 <code>c</code>，再后面跟小写字母 <code>a</code>，再再后面跟小写字母 <code>t</code>，后面再跟零个或多个空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;\s*cat\s*&quot; &#x3D;&gt; The fat cat sat on the cat.</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-加号"><a href="#2-3-2-加号" class="headerlink" title="2.3.2 加号"></a>2.3.2 加号</h3><p>该符号 <code>+</code> 匹配上一个字符的一次或多次。例如正则表达式 <code>c.+t</code>，表示: 一个小写字母 <code>c</code>，后跟任意数量的字符，后跟小写字母 <code>t</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;c.+t&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-问号"><a href="#2-3-3-问号" class="headerlink" title="2.3.3 问号"></a>2.3.3 问号</h3><p>在正则表达式中，元字符 <code>?</code> 用来表示前一个字符是可选的。该符号匹配前一个字符的零次或一次。 例如正则表达式 <code>[T]?he</code>，表示: 可选的大写字母 <code>T</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[T]he&quot; &#x3D;&gt; The car is parked in the garage.</span><br><span class="line">&quot;[T]?he&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h2 id="2-4-花括号"><a href="#2-4-花括号" class="headerlink" title="2.4 花括号"></a>2.4 花括号</h2><p>在正则表达式中花括号(也被称为量词 ?)用于指定字符或一组字符可以重复的次数。例如正则表达式 <code>[0-9]{2,3}</code>，表示: 匹配至少2位数字但不超过3位(0到9范围内的字符)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,3&#125;&quot; &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>

<p>我们可以省略第二个数字。例如正则表达式 <code>[0-9]{2,}</code>，表示: 匹配2个或更多个数字。如果我们也删除逗号，则正则表达式 <code>[0-9]{2}</code>，表示: 匹配正好为2位数的数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,&#125;&quot; &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br><span class="line">&quot;[0-9]&#123;2&#125;&quot; &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>

<h2 id="2-5-字符组"><a href="#2-5-字符组" class="headerlink" title="2.5 字符组"></a>2.5 字符组</h2><p>字符组是一组写在圆括号内的子模式 <code>(...)</code>。正如我们在正则表达式中讨论的那样，如果我们把一个量词放在一个字符之后，它会重复前一个字符。 但是，如果我们把量词放在一个字符组之后，它会重复整个字符组。 例如正则表达式 <code>(ab)*</code> 表示匹配零个或多个的字符串 “ab”。我们还可以在字符组中使用元字符 <code>|</code>。例如正则表达式 <code>(c|g|p)ar</code>，表示: 小写字母 <code>c</code>、<code>g</code> 或 <code>p</code> 后面跟字母 <code>a</code>，后跟字母 <code>r</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(c|g|p)ar&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h2 id="2-6-分支结构"><a href="#2-6-分支结构" class="headerlink" title="2.6 分支结构"></a>2.6 分支结构</h2><p>在正则表达式中垂直条 <code>|</code> 用来定义分支结构，分支结构就像多个表达式之间的条件。现在你可能认为这个字符集和分支机构的工作方式一样。 但是字符集和分支结构巨大的区别是字符集只在字符级别上有作用，然而分支结构在表达式级别上依然可以使用。 例如正则表达式 <code>(T|t)he|car</code>，表示: 大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code> 或小写字母 <code>c</code>，后跟小写字母 <code>a</code>，后跟小写字母 <code>r</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he|car&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h2 id="2-7-转义特殊字符"><a href="#2-7-转义特殊字符" class="headerlink" title="2.7 转义特殊字符"></a>2.7 转义特殊字符</h2><p>正则表达式中使用反斜杠 <code>\</code> 来转义下一个字符。这将允许你使用保留字符来作为匹配字符 <code>{ } [ ] / \ + * . $ ^ | ?</code>。在特殊字符前面加 <code>\</code>，就可以使用它来做匹配字符。 例如正则表达式 <code>.</code> 是用来匹配除了换行符以外的任意字符。现在要在输入字符串中匹配 <code>.</code> 字符，正则表达式 <code>(f|c|m)at\.?</code>，表示: 小写字母 <code>f</code>、<code>c</code> 或者 <code>m</code> 后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟可选的 <code>.</code> 字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(f|c|m)at\.?&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h2 id="2-8-定位符"><a href="#2-8-定位符" class="headerlink" title="2.8 定位符"></a>2.8 定位符</h2><p>在正则表达式中，为了检查匹配符号是否是起始符号或结尾符号，我们使用定位符。 定位符有两种类型: 第一种类型是 <code>^</code> 检查匹配字符是否是起始字符，第二种类型是 <code>$</code>，它检查匹配字符是否是输入字符串的最后一个字符。</p>
<h3 id="2-8-1-插入符号"><a href="#2-8-1-插入符号" class="headerlink" title="2.8.1 插入符号"></a>2.8.1 插入符号</h3><p>插入符号 <code>^</code> 符号用于检查匹配字符是否是输入字符串的第一个字符。如果我们使用正则表达式 <code>^a</code> (如果a是起始符号)匹配字符串 <code>abc</code>，它会匹配到 <code>a</code>。 但是如果我们使用正则表达式 <code>^b</code>，它是匹配不到任何东西的，因为在字符串 <code>abc</code> 中 “b” 不是起始字符。 让我们来看看另一个正则表达式 <code>^(T|t)he</code>，这表示: 大写字母 <code>T</code> 或小写字母 <code>t</code> 是输入字符串的起始符号，后面跟着小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he&quot; &#x3D;&gt; The car is parked in the garage.</span><br><span class="line">&quot;^(T|t)he&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h3 id="2-8-2-美元符号"><a href="#2-8-2-美元符号" class="headerlink" title="2.8.2 美元符号"></a>2.8.2 美元符号</h3><p>美元 <code>$</code> 符号用于检查匹配字符是否是输入字符串的最后一个字符。例如正则表达式 <code>(at\.)$</code>，表示: 小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟一个 <code>.</code> 字符，且这个匹配器必须是字符串的结尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(at\.)&quot; &#x3D;&gt; The fat cat. sat. on the mat.</span><br><span class="line">&quot;(at\.)$&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式为常用的字符集和常用的正则表达式提供了简写。简写字符集如下:</p>
<table>
<thead>
<tr>
<th>简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配所有字母和数字的字符: <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母和数字的字符: <code>[^\w]</code></td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字: <code>[0-9]</code></td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字: <code>[^\d]</code></td>
</tr>
<tr>
<td>\s</td>
<td>匹配空格符: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空格符: <code>[^\s]</code></td>
</tr>
</tbody></table>
<h2 id="4-断言"><a href="#4-断言" class="headerlink" title="4. 断言"></a>4. 断言</h2><p>后行断言和先行断言有时候被称为断言，它们是特殊类型的 <strong><em>非捕获组</em></strong> (用于匹配模式，但不包括在匹配列表中)。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。 例如我们想获取输入字符串 <code>$4.44 and $10.88</code> 中带有前缀 <code>$</code> 的所有数字。我们可以使用这个正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>，表示: 获取包含 <code>.</code> 字符且前缀为 <code>$</code> 的所有数字。 以下是正则表达式中使用的断言:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>?=</td>
<td>正向先行断言</td>
</tr>
<tr>
<td>?!</td>
<td>负向先行断言</td>
</tr>
<tr>
<td>?&lt;=</td>
<td>正向后行断言</td>
</tr>
<tr>
<td>?&lt;!</td>
<td>负向后行断言</td>
</tr>
</tbody></table>
<h3 id="4-1-正向先行断言"><a href="#4-1-正向先行断言" class="headerlink" title="4.1 正向先行断言"></a>4.1 正向先行断言</h3><p>正向先行断言认为第一部分的表达式必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。 要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 <code>(?=...)</code>。先行断言表达式写在括号中的等号后面。 例如正则表达式 <code>(T|t)he(?=\sfat)</code>，表示: 匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟字母 <code>h</code>，后跟字母 <code>e</code>。 在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配 <code>The</code> 或 <code>the</code> 后面跟着 <code>fat</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he(?&#x3D;\sfat)&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="4-2-负向先行断言"><a href="#4-2-负向先行断言" class="headerlink" title="4.2 负向先行断言"></a>4.2 负向先行断言</h3><p>当我们需要从输入字符串中获取不匹配表达式的内容时，使用负向先行断言。负向先行断言的定义跟我们定义的正向先行断言一样， 唯一的区别是不是等号 <code>=</code>，我们使用否定符号 <code>!</code>，例如 <code>(?!...)</code>。 我们来看看下面的正则表达式 <code>(T|t)he(?!\sfat)</code>，表示: 从输入字符串中获取全部 <code>The</code> 或者 <code>the</code> 且不匹配 <code>fat</code> 前面加上一个空格字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he(?!\sfat)&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="4-3-正向后行断言"><a href="#4-3-正向后行断言" class="headerlink" title="4.3 正向后行断言"></a>4.3 正向后行断言</h3><p>正向后行断言是用于获取在特定模式之前的所有匹配内容。正向后行断言表示为 <code>(?&lt;=...)</code>。例如正则表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code>，表示: 从输入字符串中获取在单词 <code>The</code> 或 <code>the</code> 之后的所有 <code>fat</code> 和 <code>mat</code> 单词。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(?&lt;&#x3D;(T|t)he\s)(fat|mat)&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="4-4-负向后行断言"><a href="#4-4-负向后行断言" class="headerlink" title="4.4 负向后行断言"></a>4.4 负向后行断言</h3><p>负向后行断言是用于获取不在特定模式之前的所有匹配的内容。负向后行断言表示为 <code>(?。例如正则表达式</code>(?，表示: 在输入字符中获取所有不在 <code>The</code> 或 <code>the</code> 之后的所有单词 <code>cat</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(?&lt;!(T|t)he\s)(cat)&quot; &#x3D;&gt; The cat sat on cat.</span><br></pre></td></tr></table></figure>

<h2 id="5-标记"><a href="#5-标记" class="headerlink" title="5. 标记"></a>5. 标记</h2><p>标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>不区分大小写: 将匹配设置为不区分大小写。</td>
</tr>
<tr>
<td>g</td>
<td>全局搜索: 搜索整个输入字符串中的所有匹配。</td>
</tr>
<tr>
<td>m</td>
<td>多行匹配: 会匹配输入字符串每一行。</td>
</tr>
</tbody></table>
<h3 id="5-1-不区分大小写"><a href="#5-1-不区分大小写" class="headerlink" title="5.1 不区分大小写"></a>5.1 不区分大小写</h3><p><code>i</code> 修饰符用于执行不区分大小写匹配。例如正则表达式 <code>/The/gi</code>，表示: 大写字母 <code>T</code>，后跟小写字母 <code>h</code>，后跟字母 <code>e</code>。 但是在正则匹配结束时 <code>i</code> 标记会告诉正则表达式引擎忽略这种情况。正如你所看到的，我们还使用了 <code>g</code> 标记，因为我们要在整个输入字符串中搜索匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;The&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br><span class="line">&quot;&#x2F;The&#x2F;gi&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="5-2-全局搜索"><a href="#5-2-全局搜索" class="headerlink" title="5.2 全局搜索"></a>5.2 全局搜索</h3><p><code>g</code> 修饰符用于执行全局匹配 (会查找所有匹配，不会在查找到第一个匹配时就停止)。 例如正则表达式 <code>/.(at)/g</code>，表示: 除换行符之外的任意字符，后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>。 因为我们在正则表达式的末尾使用了 <code>g</code> 标记，它会从整个输入字符串中找到每个匹配项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;.(at)&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br><span class="line">&quot;&#x2F;.(at)&#x2F;g&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="5-3-多行匹配"><a href="#5-3-多行匹配" class="headerlink" title="5.3 多行匹配"></a>5.3 多行匹配</h3><p><code>m</code> 修饰符被用来执行多行的匹配。正如我们前面讨论过的 <code>(^, $)</code>，使用定位符来检查匹配字符是输入字符串开始或者结束。但是我们希望每一行都使用定位符，所以我们就使用 <code>m</code> 修饰符。 例如正则表达式 <code>/at(.)?$/gm</code>，表示: 小写字母 <code>a</code>，后跟小写字母 <code>t</code>，匹配除了换行符以外任意字符零次或一次。而且因为 <code>m</code> 标记，现在正则表达式引擎匹配字符串中每一行的末尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&#x2F;.at(.)?$&#x2F;&quot; &#x3D;&gt; The fat</span><br><span class="line">                cat sat</span><br><span class="line">                on the mat.</span><br><span class="line">&quot;&#x2F;.at(.)?$&#x2F;gm&quot; &#x3D;&gt; The fat</span><br><span class="line">                  cat sat</span><br><span class="line">                  on the mat.</span><br></pre></td></tr></table></figure>

<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><ul>
<li><strong>正整数</strong>: <code>^\d+$</code></li>
<li><strong>负整数</strong>: <code>^-\d+$</code></li>
<li><strong>电话号码</strong>: <code>^+?[\d\s]{3,}$</code></li>
<li><strong>电话代码</strong>: <code>^+?[\d\s]+(?[\d\s]{10,}$</code></li>
<li><strong>整数</strong>: <code>^-?\d+$</code></li>
<li><strong>用户名</strong>: <code>^[\w\d_.]{4,16}$</code></li>
<li><strong>字母数字字符</strong>: <code>^[a-zA-Z0-9]*$</code></li>
<li><strong>带空格的字母数字字符</strong>: <code>^[a-zA-Z0-9 ]*$</code></li>
<li><strong>密码</strong>: <code>^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$</code></li>
<li><strong>电子邮件</strong>: <code>^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4})*$</code></li>
<li><strong>IPv4 地址</strong>: <code>^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</code></li>
<li><strong>小写字母</strong>: <code>^([a-z])*$</code></li>
<li><strong>大写字母</strong>: <code>^([A-Z])*$</code></li>
<li><strong>网址</strong>: <code>^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\/+=%&amp;_\.~?\-]*))*$</code></li>
<li><strong>VISA 信用卡号码</strong>: <code>^(4[0-9]{12}(?:[0-9]{3})?)*$</code></li>
<li><strong>日期 (MM/DD/YYYY)</strong>: <code>^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$</code></li>
<li><strong>日期 (YYYY/MM/DD)</strong>: <code>^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$</code></li>
<li><strong>万事达信用卡号码</strong>: <code>^(5[1-5][0-9]{14})*$</code></li>
</ul>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-java基础技巧</title>
    <url>/2020/02/06/%EF%BC%8126.leetcode-java%E5%9F%BA%E7%A1%80%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>之前打算法竞赛一直是用C+STL，包括牛客网上写题练习也是用这个方式来解决的，长期习惯了以后，开始对java刷题甚至产生了排斥……但鉴于java以后肯定是要常用的，因此必须矫正这个问题</p>
<p>本篇博文讲述刷leetcode过程中采用java语言遇到的坑，明明一眼就知道该怎么写但不能用其他语言写出来就是不行啊！</p>
<p>根据自己经验，有竞赛基础的建议直接从周赛题开始摸坑=3=（倒着刷）</p>
<p>（本文长期更新）</p>
<h2 id="1-String转int、long"><a href="#1-String转int、long" class="headerlink" title="1.String转int、long"></a>1.String转int、long</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">int</span> n1 = Integer.parseInt(s);</span><br><span class="line"><span class="keyword">long</span> n2 = Long.parseLong(s);</span><br></pre></td></tr></table></figure>



<h2 id="2-StringBuffer"><a href="#2-StringBuffer" class="headerlink" title="2.StringBuffer"></a>2.StringBuffer</h2><p>StringBuffer类和String一样，也用来代表字符串，只是由于StringBuffer的内部实现方式和String不同，所以StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些.</p>
<p>StringBuffer与String有一个显著的区别：<strong>StringBuffer对象的每次修改都会改变对象自身</strong></p>
<p>StringBuffer是线程安全的，所以在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些</p>
<p>1.String转StringBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<p>2.append方法，将内容追加到StringBuffer末尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">s.append(<span class="string">"efg"</span>);</span><br><span class="line">System.out.println(s.toString());</span><br></pre></td></tr></table></figure>

<p>3.delete方法</p>
<p>deleteCharAt(int index)<br>该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。第一位为0<br>s.delete(int start,int end)<br>该方法的作用是删除指定区间以内的所有字符，包含start，不包含end索引值的区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">s.append(<span class="string">"efg"</span>);</span><br><span class="line">s.deleteCharAt(<span class="number">2</span>);</span><br><span class="line">s.delete(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(s.toString());</span><br></pre></td></tr></table></figure>

<p>4.insert方法</p>
<p>StringBuffer insert(int offset, String str)<br>该方法的作用是在StringBuffer对象中插入内容，然后形成新的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"TestString"</span>);</span><br><span class="line">sb.insert(<span class="number">4</span>,<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>

<p>5.reverse方法</p>
<p>StringBuffer reverse()<br>该方法的作用是将StringBuffer对象中的内容反转，然后形成新的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"TestString"</span>);</span><br><span class="line">sb.reverse();</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>

<p>6.setCharAt方法</p>
<p>setCharAt(int index, char ch)<br>该方法的作用是修改对象中索引值为index位置的字符为新的字符ch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"bc"</span>);</span><br><span class="line">sb.setCharAt(<span class="number">1</span>,<span class="string">'D'</span>);</span><br></pre></td></tr></table></figure>



<h2 id="3-数组排序"><a href="#3-数组排序" class="headerlink" title="3.数组排序"></a>3.数组排序</h2><p>Arrays.Sort() 快排</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arys[])</span><br><span class="line">Arrays.sort(arys[],int from,int to) &#x2F;&#x2F; 排序范围:from--&gt;to-1</span><br><span class="line">Arrays.sort(arys[],new MyComparator())</span><br><span class="line">Arrays.sort(arys[],int from,int to,new MyComparator())</span><br></pre></td></tr></table></figure>

<p>Arrays.sort()方法可对任何实现compareble接口的对象数组排序, 像Integer,String这两种引用类型都实现了compareble接口，所以这两种类型的数组都可直接使用Arrays.sort()进行排序。</p>
<p>1.数字排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, -<span class="number">23</span> &#125;;</span><br><span class="line">Arrays.sort(intArray);</span><br><span class="line"></span><br><span class="line">输出： [-<span class="number">23</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<p>2.字符串排序，先大写后小写 String[] strArray = new String[] { “z”, “a”, “C” };</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strArray = <span class="keyword">new</span> String[] &#123; <span class="string">"z"</span>, <span class="string">"a"</span>, <span class="string">"C"</span> &#125;;</span><br><span class="line">Arrays.sort(strArray);</span><br><span class="line"></span><br><span class="line">输出： [C, a, z]</span><br></pre></td></tr></table></figure>



<p>3.严格按字母表顺序排序，也就是忽略大小写排序 Case-insensitive sort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line"></span><br><span class="line">输出： [a, C, z]</span><br></pre></td></tr></table></figure>



<p>4.反向排序,Reverse-order sort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(strArray, Collections.reverseOrder());</span><br><span class="line"></span><br><span class="line">输出：[z, a, C]</span><br></pre></td></tr></table></figure>



<p>5.忽略大小写反向排序 Case-insensitive reverse-order sort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">Collections.reverse(Arrays.asList(strArray));</span><br><span class="line"></span><br><span class="line">输出： [z, C, a]</span><br></pre></td></tr></table></figure>



<p>Collections.sort模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">　　　　　　* 升序排的话就是第一个参数.compareTo(第二个参数);</span></span><br><span class="line"><span class="comment">　　　　　　* 降序排的话就是第二个参数.compareTo(第一个参数);</span></span><br><span class="line"><span class="comment">　　　　　　*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按首字母升序排</span></span><br><span class="line">        <span class="comment">// return str1.compareTo(str2);</span></span><br><span class="line">        <span class="comment">// 按第二个字母升序排</span></span><br><span class="line">        <span class="keyword">char</span> c1 = str1.charAt(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">char</span> c2 = str2.charAt(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> c1 - c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop之jps详解</title>
    <url>/2020/02/06/25.hadoop%E4%B9%8Bjps%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>jps最主要的功能使查看java接口的进程号</strong></p>
<p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有 java 进程 pid 的命令，简单实用，非常适合在 linux/unix 平台上简单察看当前java进程的一些简单情况。</p>
<p>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令</p>
<h2 id="jps常用参数"><a href="#jps常用参数" class="headerlink" title="jps常用参数"></a>jps常用参数</h2><p>1.命令jps类似于Linux下的ps，但它只用于列出Java的进程。直接运行jps不加任何参数，可以列出Java程序的进程ID以及Main函数等名称。</p>
<p>其中一个输出jps就是jps命令本身，这更加证明此命令的本质也是一个Java程序</p>
<p>2.参数-q 指定jps只输出进程ID，而不输出类的短名称</p>
<p>3.参数-m 用于输出传递给Java进程（主函数）的参数</p>
<p>4.参数-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</p>
<p>5.参数-v 可以显示传递给JVM的参数</p>
<h2 id="问题：process-information-unavailable"><a href="#问题：process-information-unavailable" class="headerlink" title="问题：process information unavailable"></a>问题：process information unavailable</h2><p>1.找到进程号jps</p>
<p>2.ps -ef|grep pid是否存在（这步很关键要做判断查看进程是否存在）</p>
<p>3.假如进程不存在，我们可以去该/tmp/hsperfdata_xxx去删除</p>
<p>4.如果存在千万别删，自己查看是不可以的，其他用户查看是可用的。</p>
<p>5不存在举例：我不知道是这个进程是属于哪个用户的我们怎么操作呢？ps -ef|grep pid查看进程号属于哪个目录删除就可了</p>
<p>6.如果存在ps -ef |grep pid 看到了用户名，su 切换过去jps一下就好了</p>
<h2 id="关于jps的一些总结"><a href="#关于jps的一些总结" class="headerlink" title="关于jps的一些总结"></a>关于jps的一些总结</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop用户启动的 .&#x2F;start-dfs.sh  jps后可以看到进程,</span><br><span class="line">root用户看到的就是5235 -- process information unavailable,</span><br><span class="line">ps -ef| grep 5235 看的到是hadoop用户的这个进程还在,</span><br><span class="line">那这个状态就是假死,因为进程还在,所以说root用户是看不到hadoop启动的jps进程,</span><br><span class="line">只有root用户启动hdfs才能看到jps下的三个进程,</span><br><span class="line"></span><br><span class="line">root 使用jps只有两种情况：</span><br><span class="line"></span><br><span class="line">第一种: 查看正常信息</span><br><span class="line">第二种: - process information unavailable</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS最常用命令及快捷键整理</title>
    <url>/2020/02/06/24.Centos%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd &#x2F;home					进入 &#39;&#x2F;home&#39; 目录</span><br><span class="line"># cd ..						返回上一级目录</span><br><span class="line"># cd ..&#x2F;..					返回上两级目录</span><br><span class="line"># cd -						返回上次所在目录</span><br><span class="line"># cp file1 file2			将file1复制为file2</span><br><span class="line"># cp -a dir1 dir2			复制一个目录</span><br><span class="line"># cp -a &#x2F;tmp&#x2F;dir1 .			复制一个目录到当前工作目录（.代表当前目录）</span><br><span class="line"># ls						查看目录中的文件</span><br><span class="line"># ls -a						显示隐藏文件</span><br><span class="line"># ls -l						显示详细信息</span><br><span class="line"># ls -lrt					按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序）</span><br><span class="line"># pwd						显示工作路径</span><br><span class="line"># mkdir dir1				创建 &#39;dir1&#39; 目录</span><br><span class="line"># mkdir dir1 dir2			同时创建两个目录</span><br><span class="line"># mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2	创建一个目录树</span><br><span class="line"># mv dir1 dir2				移动&#x2F;重命名一个目录</span><br><span class="line"># rm -f file1				删除 &#39;file1&#39;</span><br><span class="line"># rm -rf dir1				删除 &#39;dir1&#39; 目录及其子目录内容</span><br></pre></td></tr></table></figure>



<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat file1					从第一个字节开始正向查看文件的内容</span><br><span class="line"># head -2 file1				查看一个文件的前两行</span><br><span class="line"># more file1				查看一个长文件的内容</span><br><span class="line"># tac file1					从最后一行开始反向查看一个文件的内容</span><br><span class="line"># tail -3 file1				查看一个文件的最后三行</span><br></pre></td></tr></table></figure>



<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep str &#x2F;tmp&#x2F;test		在文件 &#39;&#x2F;tmp&#x2F;test&#39; 中查找 &quot;str&quot;</span><br><span class="line"># grep ^str &#x2F;tmp&#x2F;test		在文件 &#39;&#x2F;tmp&#x2F;test&#39; 中查找以 &quot;str&quot; 开始的行</span><br><span class="line"># grep [0-9] &#x2F;tmp&#x2F;test		查找 &#39;&#x2F;tmp&#x2F;test&#39; 文件中所有包含数字的行</span><br><span class="line"># grep str -r &#x2F;tmp&#x2F;*		在目录 &#39;&#x2F;tmp&#39; 及其子目录中查找 &quot;str&quot;</span><br><span class="line"># diff file1 file2			找出两个文件的不同处</span><br><span class="line"># sdiff file1 file2			以对比的方式显示两个文件的不同</span><br></pre></td></tr></table></figure>



<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find &#x2F; -name file1				从 &#39;&#x2F;&#39; 开始进入根文件系统查找文件和目录</span><br><span class="line"># find &#x2F; -user user1				查找属于用户 &#39;user1&#39; 的文件和目录</span><br><span class="line"># find &#x2F;home&#x2F;user1 -name \*.bin		在目录 &#39;&#x2F; home&#x2F;user1&#39; 中查找以 &#39;.bin&#39; 结尾的文件</span><br><span class="line"># find &#x2F;usr&#x2F;bin -type f -atime +100	查找在过去100天内未被使用过的执行文件</span><br><span class="line"># find &#x2F;usr&#x2F;bin -type f -mtime -10	查找在10天内被创建或者修改过的文件</span><br><span class="line"># locate \*.ps						寻找以 &#39;.ps&#39; 结尾的文件，先运行 &#39;updatedb&#39; 命令</span><br><span class="line"># find -name &#39;*.[ch]&#39; | xargs grep -E &#39;expr&#39;	在当前目录及其子目录所有.c和.h文件中查找 &#39;expr&#39;</span><br><span class="line"># find -type f -print0 | xargs -r0 grep -F &#39;expr&#39;	在当前目录及其子目录的常规文件中查找 &#39;expr&#39;</span><br><span class="line"># find -maxdepth 1 -type f | xargs grep -F &#39;expr&#39;	在当前目录中查找 &#39;expr&#39;</span><br></pre></td></tr></table></figure>



<h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bzip2 file1							压缩 file1</span><br><span class="line"># bunzip2 file1.bz2						解压 file1.bz2</span><br><span class="line"># gzip file1							压缩 file1</span><br><span class="line"># gzip -9 file1							最大程度压缩 file1</span><br><span class="line"># gunzip file1.gz						解压 file1.gz</span><br><span class="line"># tar -cvf archive.tar file1			把file1打包成 archive.tar</span><br><span class="line">（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数）</span><br><span class="line"># tar -cvf archive.tar file1 dir1		把 file1，dir1 打包成 archive.tar</span><br><span class="line"># tar -tf archive.tar					显示一个包中的内容</span><br><span class="line"># tar -xvf archive.tar					释放一个包</span><br><span class="line"># tar -xvf archive.tar -C &#x2F;tmp			把压缩包释放到 &#x2F;tmp目录下</span><br><span class="line"># zip file1.zip file1					创建一个zip格式的压缩包</span><br><span class="line"># zip -r file1.zip file1 dir1			把文件和目录压缩成一个zip格式的压缩包</span><br><span class="line"># unzip file1.zip						解压一个zip格式的压缩包到当前目录</span><br><span class="line"># unzip test.zip -d &#x2F;tmp&#x2F;				解压一个zip格式的压缩包到 &#x2F;tmp 目录</span><br></pre></td></tr></table></figure>



<h2 id="yum工具"><a href="#yum工具" class="headerlink" title="yum工具"></a>yum工具</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum -y install [package]				下载并安装一个rpm包</span><br><span class="line"># yum localinstall [package.rpm]		安装一个rpm包，使用你自己的软件仓库解决所有依赖关系</span><br><span class="line"># yum -y update							更新当前系统中安装的所有rpm包</span><br><span class="line"># yum update [package]					更新一个rpm包</span><br><span class="line"># yum remove [package]					删除一个rpm包</span><br><span class="line"># yum list								列出当前系统中安装的所有包</span><br><span class="line"># yum search [package]					在rpm仓库中搜寻软件包</span><br><span class="line"># yum clean [package]					清除缓存目录（&#x2F;var&#x2F;cache&#x2F;yum）下的软件包</span><br><span class="line"># yum clean headers						删除所有头文件</span><br><span class="line"># yum clean all							删除所有缓存的包和头文件</span><br></pre></td></tr></table></figure>



<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ifconfig eth0										显示一个以太网卡的配置</span><br><span class="line"># ifconfig eth0 192.168.1.1 netmask 255.255.255.0	配置网卡的IP地址</span><br><span class="line"># ifdown eth0										禁用 &#39;eth0&#39; 网络设备</span><br><span class="line"># ifup eth0											启用 &#39;eth0&#39; 网络设备</span><br><span class="line"># iwconfig eth1										显示一个无线网卡的配置</span><br><span class="line"># iwlist scan										显示无线网络</span><br><span class="line"># ip addr show										显示网卡的IP地址</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># su -						切换到root权限（与su有区别）</span><br><span class="line"># shutdown -h now			关机</span><br><span class="line"># shutdown -r now			重启</span><br><span class="line"># top						罗列使用CPU资源最多的linux任务 （输入q退出）</span><br><span class="line"># pstree					以树状图显示程序</span><br><span class="line"># man ping					查看参考手册（例如ping 命令）</span><br><span class="line"># passwd					修改密码</span><br><span class="line"># df -h						显示磁盘的使用情况</span><br><span class="line"># cal -3					显示前一个月，当前月以及下一个月的月历</span><br><span class="line"># cal 10 1988				显示指定月，年的月历</span><br><span class="line"># date --date &#39;1970-01-01 UTC 1427888888 seconds&#39;	把一相对于1970-01-01 00:00的秒数转换成时间</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive之UDF函数</title>
    <url>/2020/02/05/23.Hive%E4%B9%8BUDF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>官方文档：<a href="https://cwiki.apache.org/confluence/display/Hive/HivePlugins" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/HivePlugins</a></p>
<p>中文整理稍等~</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>数据倾斜解决方案</title>
    <url>/2020/02/04/22.%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>同key分发到同一个reduce去执行==&gt;skew</p>
<p>数据倾斜解决方案：打散再处理</p>
<p>假设原task要处理9000w的数据量，我们通过随机数打散为100份</p>
<p>==&gt; 原来都在一个reducetask中取处理的数据，被我们打散后变为9000w / 100</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chain:</span><br><span class="line">	第一个mr：key加随机数打散</span><br><span class="line">	data_8 100</span><br><span class="line">	data_1 200</span><br><span class="line">	data_2 300</span><br><span class="line">	data_4 200</span><br><span class="line">	第二个mr：第一个mr加的随机数去掉</span><br><span class="line">	data 100</span><br><span class="line">	data 200</span><br><span class="line">	data 300</span><br><span class="line">	data 200</span><br><span class="line">	</span><br><span class="line">	在第二个mr中的reduce来做最终的聚合操作</span><br><span class="line">	ruoze 800</span><br></pre></td></tr></table></figure>

<p>Hadoop不怕数据量大，就怕数据倾斜hhhhhhhhhhhhh（跑不动）</p>
<p>以统计某人的数字之和为例</p>
<p>数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mxh 	102</span><br><span class="line">mxh 	1042</span><br><span class="line">pearfl 	102222</span><br><span class="line">pearfl 	1000</span><br></pre></td></tr></table></figure>



<p>第一个mr</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainFirstDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String input = <span class="string">"data/chain/data.txt"</span>;</span><br><span class="line">        String output = <span class="string">"data/chain/first"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1:获取job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除已存在目录</span></span><br><span class="line">        FileUtils.deleteOutput(configuration,output);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2：本job对应执行的主类</span></span><br><span class="line">        job.setJarByClass(ChainFirstDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3）设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(MyReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        job.setNumReduceTasks(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4）设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5）设置Reducer阶段输出数据的类型</span></span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6）设置输入和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7）提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key,Text values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String[] splits = values.toString().split(<span class="string">"\t"</span>);</span><br><span class="line">            <span class="keyword">int</span> r = random.nextInt(<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(splits[<span class="number">0</span>].trim() + <span class="string">"_"</span> + r), <span class="keyword">new</span> IntWritable(Integer.parseInt(splits[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key,Iterable&lt;IntWritable&gt;values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(IntWritable value:values)&#123;</span><br><span class="line">                sum+=value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,<span class="keyword">new</span> IntWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第二个mr</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainSecondDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        String input = <span class="string">"data/chain/first"</span>;</span><br><span class="line">        String output = <span class="string">"data/chain/second"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1:获取job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除已存在目录</span></span><br><span class="line">        FileUtils.deleteOutput(configuration,output);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2：本job对应执行的主类</span></span><br><span class="line">        job.setJarByClass(ChainFirstDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3）设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(MyReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4）设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5）设置Reducer阶段输出数据的类型</span></span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6）设置输入和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7）提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key,Text values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String[] splits = values.toString().split(<span class="string">"\t"</span>);</span><br><span class="line">            <span class="keyword">int</span> index = splits[<span class="number">0</span>].lastIndexOf(<span class="string">"_"</span>);</span><br><span class="line">            String result = splits[<span class="number">0</span>].substring(<span class="number">0</span>, index);</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(result),<span class="keyword">new</span> IntWritable(Integer.parseInt(splits[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">IntWritable</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key,Iterable&lt;IntWritable&gt; values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(IntWritable value:values)&#123;</span><br><span class="line">                sum+=value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,<span class="keyword">new</span> IntWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>FileUtils补充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteOutput</span><span class="params">(Configuration configuration, String output)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileSystem fileSystem = FileSystem.get(configuration);</span><br><span class="line">        Path path = <span class="keyword">new</span> Path(output);</span><br><span class="line">        <span class="keyword">if</span>(fileSystem.exists(path))&#123;</span><br><span class="line">            fileSystem.delete(path, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive之Join详解</title>
    <url>/2020/02/03/21.Hive%E4%B9%8BJoin%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reduce&#x2F;Shuffle&#x2F;Common Join</span><br><span class="line">	join操作是在reduce端完成的</span><br><span class="line">Map Join</span><br><span class="line">	join操作是在map端完成的</span><br></pre></td></tr></table></figure>

<p>Map Join</p>
<p>join操作是在map端完成的，无Shuffle和Reduce</p>
<p>思路：小表加载到内存中，读取大表时，读一条和内存中的数据匹配一下</p>
<p>缺点：没办法处理大数据量的表，适合打表join小表</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的字典、集合</title>
    <url>/2020/02/02/20.Python%E7%9A%84%E5%AD%97%E5%85%B8%E3%80%81%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是一种用来存放若干键值对的数据类型。</p>
<p>什么是键值对呢？<strong>键值对</strong>就是两个对象，其中一个是用来做定位的数据，叫做<strong>键</strong>（Key），另一个是要存放的数据，叫做<strong>值</strong>（Value）。在字典中，键值对作为一个整体被存放，我们可以通过键来快速获取到对应的值。</p>
<p>在 Python 中字典用花括号（<code>{}</code>）来表示，键值对以 <code>键:值</code> 的方式写入花括号中，有多个键值对时用逗号分隔。</p>
<p>如 <code>{&#39;010&#39;: &#39;beijing&#39;, &#39;021&#39;: &#39;shanghai&#39;}</code> 便是一个字典，其中包含两个键值对。</p>
<p>使用时，我们可以通过 <code>&#39;010&#39;</code> 快速查询到其对应的值是 <code>&#39;beijing&#39;</code>。这就好比现实中的一本字典一样，通过拼音或偏旁来映射一个具体的字词，以此来实现字词的快速查找，而这个拼音或偏旁就相当于 Python 字典的键，而字词就相当于 Python 字典的值，它们在字典中是映射关系。</p>
<p>Python 字典中的键是有要求的，需要是不可变的类型，如元组、字符串、数字。而字典中的值可以是任意类型。字典本身是可变的，我们可以向其中添加、删除、修改键值对。</p>
<p>因为字典不是序列，更不是有序的，所有它没有列表那样的索引，也不能保证每个键值对的存放次序。</p>
<h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h3><p>1.创建空的字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字典 &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; empty_dict &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; empty_dict</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>2.创建包含键值对的字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典 = &#123;键<span class="number">1</span>:值<span class="number">1</span>, 键<span class="number">2</span>:值<span class="number">2</span>, ..., 键N:值N&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字典键值对的添加"><a href="#字典键值对的添加" class="headerlink" title="字典键值对的添加"></a>字典键值对的添加</h3><p>1.向字典中增加键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典[键] = 值</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes[‘tianjin’] = <span class="string">'022’</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; codes</span></span><br><span class="line"><span class="string">&#123;‘beijing’: ‘010’, ‘shanghai’: ‘021’, ‘tianjin’: ‘022’&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用这种方式时，若字典中没有这个键，则会创建这个键值对；若字典中原本已有这个键，则是修改键所对应的值。</p>
<h3 id="键值对的获取"><a href="#键值对的获取" class="headerlink" title="键值对的获取"></a>键值对的获取</h3><p>1.通过键获取值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值 = 字典[键]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes[‘beijing’]</span><br><span class="line">‘<span class="number">010</span>’</span><br></pre></td></tr></table></figure>

<p>注意若键不存在则将抛出 <code>KeyError</code> 异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes[‘a’]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">     File “”, line <span class="number">1</span>, <span class="keyword">in</span></span><br><span class="line">KeyError: ‘a’</span><br></pre></td></tr></table></figure>



<p>2.通过键获取值（ <code>get</code> 方法）</p>
<p>如果通过键获取值时不希望 <code>KeyError</code> 异常抛出，可以使用 <code>get</code> 方法，若键不存在，则直接返回 <code>None</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值 = 字典.get(键)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.get(‘a’)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>返回的 <code>None</code> 代表什么都没有，所以没有任何值显示</p>
<p>也可以给 <code>get</code> 方法传递第二个参数作为默认值，使得键不存在时直接返回默认值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值 = 字典.get(键, 默认值)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.get(‘a’, ‘<span class="number">000</span>’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘<span class="number">000</span>’</span><br></pre></td></tr></table></figure>



<p>3.判断字典中是否包含某个键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 键 <span class="keyword">in</span> 字典</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘beijing’ <span class="keyword">in</span> codes</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘guangzhou’ <span class="keyword">in</span> codes</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>4.获取所有键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">键的列表 = 字典.keys()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.keys()</span><br><span class="line">dict_keys([‘beijing’, ‘shanghai’])</span><br></pre></td></tr></table></figure>

<p>获取到的所有键是以迭代器的形式存在,在这里我们可以用 <code>list()</code> 函数将迭代器转换为列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(codes.keys())</span><br><span class="line">[‘beijing’, ‘shanghai’]</span><br></pre></td></tr></table></figure>



<p>5.获取所有值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值的列表 = 字典.values()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.values()</span><br><span class="line">dict_values([‘<span class="number">010</span>’, ‘<span class="number">021</span>’])</span><br></pre></td></tr></table></figure>

<p>获取到的所有值是以迭代器的形式存在，我们用 <code>list()</code> 函数将迭代器转换为列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(codes.values())</span><br><span class="line">[‘<span class="number">010</span>’, ‘<span class="number">021</span>’]</span><br></pre></td></tr></table></figure>



<p>6.获取所有键值对的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值的列表 = 字典.items()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.items()</span><br><span class="line">dict_items([(‘beijing’, ‘<span class="number">010</span>’), (‘shanghai’, ‘<span class="number">021</span>’)])</span><br></pre></td></tr></table></figure>

<p>获取到的所有键值对是以迭代器的形式存在，我们用 <code>list()</code> 函数将迭代器转换为列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(codes.items())</span><br><span class="line">[(‘beijing’, ‘<span class="number">010</span>’), (‘shanghai’, ‘<span class="number">021</span>’)]</span><br></pre></td></tr></table></figure>

<p>列表中的每一个元素是都是二元组（即包含两个元素的元组），每个二元组的第一个元素是键，第二个元素是值</p>
<h3 id="字典键值对的删除"><a href="#字典键值对的删除" class="headerlink" title="字典键值对的删除"></a>字典键值对的删除</h3><p>1.通过键删除键值对</p>
<p>可以使用 <code>pop</code> 方法删除一个键值对，并将值返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值 = 字典.pop(键)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.pop(‘beijing’)</span><br><span class="line">’<span class="number">010</span>’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>pop</code> 一个不存在的键，则会抛出 <code>KeyError</code> 异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.pop(‘a’)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">     File “”, line <span class="number">1</span>, <span class="keyword">in</span></span><br><span class="line">KeyError: ‘a’</span><br></pre></td></tr></table></figure>

<p>如果你不希望异常抛出，可以传递 <code>pop</code> 方法的第二个参数作为默认值。默认值仅在键不存在时生效，此时方法将直接返回这个默认值，且跳过删除操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值 = 字典.pop(键, 默认值)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.pop(‘guangzhou’, ‘<span class="number">000</span>’)</span><br><span class="line">’<span class="number">000</span>’</span><br></pre></td></tr></table></figure>



<p>2.通过键删除键值对（<code>del</code> 方法）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> 字典[键]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> codes[‘beijing’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br></pre></td></tr></table></figure>



<p>3.随机删除一个键值对</p>
<p>使用 <code>popitem</code> 随机删除一个键值对，并返回这个键值对的二元组，二元组的第一个元素是键，第二个元素是值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">键值二元组 = 字典.popitem()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.popitem()</span><br><span class="line">(‘shanghai’, ‘<span class="number">021</span>’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;‘beijing’: ‘<span class="number">010</span>’&#125;</span><br></pre></td></tr></table></figure>



<p>4.清空所有键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">键值二元组 = 字典.clear()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字典中键值对修改"><a href="#字典中键值对修改" class="headerlink" title="字典中键值对修改"></a>字典中键值对修改</h3><p>1.修改键对应的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典[键] = 值</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes[‘beijing’] = <span class="string">'021’</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; codes</span></span><br><span class="line"><span class="string">&#123;‘beijing’: ‘021’&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果键不存在，则创建键值对</p>
<p>2.用字典批量更新键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典.update(另一字典)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.update(&#123;‘guangzhou’: ‘<span class="number">020</span>’, ‘shanghai’: ‘<span class="number">000</span>’&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">000</span>’, ‘guangzhou’: ‘<span class="number">020</span>’&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到字典中新增了 <code>&#39;guangzhou&#39;: &#39;020&#39;</code> 这个键值对，同时将 <code>&#39;shanghai&#39;: &#39;021&#39;</code> 修改为 <code>&#39;shanghai&#39;: &#39;000&#39;</code></p>
<h3 id="什么时候用字典"><a href="#什么时候用字典" class="headerlink" title="什么时候用字典"></a>什么时候用字典</h3><p>字典的显著优势是可以通过键快速地查询数据。字典中的元素以键值对的形式存在，使用时通过键来获取和修改值，由于字典内部的特殊实现，字典通过键获取值的效率非常高。</p>
<p>如果我们希望将批量的数据存放起来，并且在需要时能以很高的执行效率来获取其中某个指定的数据，这时就可以使用字典。除此之外，如果我们想在程序中暂时维护一个映射关系，也可以使用字典，因为字典本质上就是一个映射关系。</p>
<p>如，我们可以将城市名和对应的区号保存在字典中，这样就可以通过城市名快速地查询到其区号，而不需要进行遍历。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是一个用于存放批量元素的数据类型，它不是有序的，其中的元素<strong>没有顺序</strong>关系。集合中的元素<strong>没有重复</strong>，重复的元素将被自动剔除最终只留下一个。</p>
<p>集合也是用花括号（<code>{}</code>）来表示，不同于字典的是，花括号中放的是一个个数据，而不是键值对。</p>
<p>集合是可变的，我们可以向其中添加、删除、修改元素。</p>
<h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>1.创建包含元素的集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合 = &#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素N&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>



<p>2.创建空集合</p>
<p>注意创建空集合不能直接使用 <code>{}</code>，那样是表示空字典，而是使用 <code>set()</code>，这才表示空集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合 = set()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>empty_set = set()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>empty_set</span><br><span class="line">set()</span><br></pre></td></tr></table></figure>



<h3 id="集合元素的添加"><a href="#集合元素的添加" class="headerlink" title="集合元素的添加"></a>集合元素的添加</h3><p>1.向集合中添加一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.add(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.add(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>向集合中添加重复元素时，会被去重处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.add(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>



<p>2.从另一集合中批量添加元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.update(另一集合)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.update(numbers_2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，集合<code>numbers_2</code> 中的所有元素被添加到了集合 <code>numbers_1</code> 中，并且其中重复的元素被剔除仅保留一份</p>
<h3 id="集合元素的获取"><a href="#集合元素的获取" class="headerlink" title="集合元素的获取"></a>集合元素的获取</h3><p>集合不能像列表那样通过索引来获取元素，也不能像字典那样通过键来获取值，集合没法直接获取到某个指定的元素。想要获取元素，只能通过遍历的方式。</p>
<p>虽然集合不能直接获取到元素，但是我们依然可以用 <code>in</code> 关键字来判断元素是否存在于集合中。</p>
<p>1.查看元素是否存在于集合中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 元素 <span class="keyword">in</span> 集合</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = &#123;‘a’, ‘b’, ‘c’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘a’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘z’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h3 id="集合元素的删除"><a href="#集合元素的删除" class="headerlink" title="集合元素的删除"></a>集合元素的删除</h3><p>1.随机删除一个元素，并返回这个元素</p>
<p>使用 <code>pop</code> 方法随机删除一个元素的时候，这个元素会被返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元素 = 集合.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.pop()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.pop()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>



<p>2.删除一个指定的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.remove(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.remove(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果要删除的元素不存在，则抛出 <code>KeyError</code> 异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.remove(<span class="number">4</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">     File “”, line <span class="number">1</span>, <span class="keyword">in</span></span><br><span class="line">KeyError: <span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>3.删除一个指定的元素，且不抛出 <code>KeyError</code> 异常</p>
<p>使用 <code>remove</code> 方法删除一个不存在的元素时，会抛出 <code>KeyError</code> 异常，如果我们不想让异常抛出，可以使用 <code>discard</code> 方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.discard(元素)</span><br><span class="line">           </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.discard(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>



<p>4.清空所有元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.clear()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">set()</span><br></pre></td></tr></table></figure>

<p>为什么元组没有这个方法？因为元组是不可变的！我们不能删除元组的元素，也不能添加和修改元素。</p>
<h3 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h3><p>Python 中的集合和数学中的集合颇为相似，首先集合的所有元素都是唯一的，不存在重复；此外集合有子集、超集的概念，也可以进行交集、并集、差集的运算</p>
<p>1.求交集</p>
<p>可以通过 <code>intersection</code> 方法求多个集合的交集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1.</span>intersection(集合<span class="number">2</span>, 集合<span class="number">3</span>, 集合N)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_3 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.intersection(numbers_2, numbers_3)</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接使用<strong>与运算符</strong> <code>&amp;</code> 来代替，完全等效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1</span> &amp; 集合<span class="number">2</span> &amp; 集合N</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 &amp; numbers_2 &amp; numbers_3</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>



<p>2.求并集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1.</span>union(集合<span class="number">2</span>, 集合<span class="number">3</span>, 集合N)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_3 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.union(numbers_2, numbers_3)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接使用<strong>或运算符</strong> <code>|</code> 来代替，完全等效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1</span> | 集合<span class="number">2</span> | 集合N</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 | numbers_2 | numbers_3</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>



<p>3.求差集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1.</span>difference(集合<span class="number">2</span>, 集合<span class="number">3</span>, 集合N)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_3 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.difference(numbers_2, numbers_3)</span><br><span class="line">&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接使用运算符 <code>-</code> 来代替，完全等效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1</span> - 集合<span class="number">2</span> - 集合N</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 - numbers_2 - numbers_3</span><br><span class="line">&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>



<p>4.判断是否为子集</p>
<p>判断 <code>集合1</code> 是否为 <code>集合2</code> 的子集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 集合<span class="number">1.</span>issubset(集合<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.issubset(numbers_2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_3 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.issubset(numbers_3)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>5.判断是否为超集</p>
<p>判断 <code>集合1</code> 是否为 <code>集合2</code> 的超集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 集合<span class="number">1.</span>issuperset(集合<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.issuperset(numbers_2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_3 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.issuperset(numbers_3)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h3 id="什么时候用集合"><a href="#什么时候用集合" class="headerlink" title="什么时候用集合"></a>什么时候用集合</h3><p>集合非常重要的一个特性是元素无重复，每个元素都是唯一的，重复的元素将被自动剔除（去重）。</p>
<p>所以如果我们需要存放一系列的数据，并且不希望其中出现重复，那么就可以使用集合。</p>
<p>另外如果想计算两个数据集的交集、并集、差集，使用集合来承载数据再合适不过了，集合自带的集合运算能轻松解决这些问题。</p>
<h3 id="获取字典和集合中的元素数量"><a href="#获取字典和集合中的元素数量" class="headerlink" title="获取字典和集合中的元素数量"></a>获取字典和集合中的元素数量</h3><p>我们可以通过 <code>len()</code> 函数来获取字典中的键值对数量和集合中的元素数量</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>字典是一种用来存放若干键值对的数据类型，可通过键来快速查找值。</p>
<p>字典的键需要是不可变的类型，如数字，字符串和元组。字典的值可以是任意类型。字典本身是可变的，所以可向其中添加、修改、删除键值对。</p>
<p>集合是一个用于存放批量元素的序列。它不是有序的，且元素<strong>不会有重复</strong>。集合也是可变的，我们可以向其中添加、删除、修改元素。</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的列表、元组、字符串</title>
    <url>/2020/02/02/19.Python%E7%9A%84%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%A5%96%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表是用于存放若干元素的<strong>有序序列</strong>。列表使用方括号（<code>[]</code>）来表示，其中的元素写入方括号中，多个元素时用逗号分隔，如 <code>[1, &#39;go&#39;, [0.1, 0.2]]</code>。它的元素可以是任意数据类型，甚至也可以是个列表。</p>
<p>元素之间有顺序关系，每个元素都有自己的位置，每个位置从 0 开始依次标号，这个表示位置的数字叫作<strong>索引</strong>。</p>
<p>列表被创建之后，我们可以对它做很多操作，包括添加元素，删除元素，修改元素，查找元素等。</p>
<h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><p>1.创建空的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表 = []</span><br><span class="line"></span><br><span class="line">items = []</span><br></pre></td></tr></table></figure>



<p>2.创建包含元素的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表 = [元素<span class="number">1</span>, 元素<span class="number">2</span>, ..., 元素N]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>



<h3 id="列表元素的获取"><a href="#列表元素的获取" class="headerlink" title="列表元素的获取"></a>列表元素的获取</h3><p>1.通过索引获取元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元素 = 列表[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>]</span><br><span class="line">’c’</span><br></pre></td></tr></table></figure>



<p>2.通过元素获取索引</p>
<p>这种方式和上面相反，首先在列表中寻找元素，然后返回元素对应的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">索引 = 列表.index(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.index(‘c’)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>3.查看元素是否存在于列表中</p>
<p>要想查看元素是否存在于列表中，需要借助 Python 的关键字 <code>in</code>，使用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 元素 <span class="keyword">in</span> 列表</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘a’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘z’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>4.统计元素在列表中的个数</p>
<p>统计元素在列表中的个数，或者说是元素在列表中出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">个数 = 列表.count(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.count(<span class="number">5</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<h3 id="列表元素的添加"><a href="#列表元素的添加" class="headerlink" title="列表元素的添加"></a>列表元素的添加</h3><p>我们可以很灵活地向列表添加元素，如以追加的形式向列表末尾添加一个元素；以插入的形式向列表的任意位置插入元素；或者将一个列表中的所有元素批量的添加到另一个列表中。</p>
<p>1.向列表末尾追加元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.append(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.append(‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘b’, ‘c’]</span><br></pre></td></tr></table></figure>



<p>2.向列表的任意位置插入元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.insert(索引, 元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.insert(<span class="number">0</span>, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘c’, ‘a’, ‘b’]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.insert(<span class="number">2</span>, ‘d’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘c’, ‘a’, ‘d’, ‘b’]</span><br></pre></td></tr></table></figure>



<p>3.列表末尾追加另一个列表的所有元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.extend(另一列表)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.extend([‘c’, ‘d’, ‘e’])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘b’, ‘c’, ‘d’, ‘e’]</span><br></pre></td></tr></table></figure>



<h3 id="列表元素的删除"><a href="#列表元素的删除" class="headerlink" title="列表元素的删除"></a>列表元素的删除</h3><p>1.按索引删除元素</p>
<p><strong>pop(索引)</strong> 会将索引对应的元素从列表中删除，同时返回这个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元素 = 列表.pop(索引)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.pop(<span class="number">0</span>)</span><br><span class="line">’a’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘b’, ‘c’]</span><br></pre></td></tr></table></figure>

<p>也可以不传递索引，这样的话默认删除并返回最后一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.pop()</span><br><span class="line">’c’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘b’]</span><br></pre></td></tr></table></figure>



<p>2.按索引删除元素（<code>del</code> 方法)</p>
<p>删除一个列表元素也可以使用 Python 中的 <code>del</code> 关键字，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> 列表[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> letters[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘b’, ‘c’]</span><br></pre></td></tr></table></figure>



<p>3.直接删除元素</p>
<p>直接删除元素时，Python 会先在列表中遍历该元素，然后将匹配到的第一个元素删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.remove(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.remove(‘b’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘c’]</span><br></pre></td></tr></table></figure>



<p>4.清空所有元素</p>
<p>清空所有元素即是把列表元素全部删除，最后仅为列表仅为 <code>[]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.clear()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>



<h3 id="列表元素的修改"><a href="#列表元素的修改" class="headerlink" title="列表元素的修改"></a>列表元素的修改</h3><p>1.通过赋值修改列表元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表[索引] = 新元素</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>] = <span class="string">'d’</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; letters</span></span><br><span class="line"><span class="string">[‘a’, ‘b’, ‘d’]</span></span><br></pre></td></tr></table></figure>



<p>2.反转整个列表</p>
<p>反转整个列表会将所有的元素倒序排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.reverse()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘c’, ‘b’, ‘a’]</span><br></pre></td></tr></table></figure>



<p>3.列表元素排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.sort()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>也可以通过指定 <code>sort</code> 方法的 <code>reverse</code> 参数来倒序排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组和列表非常相似，也是用于存放元素的有序序列。它用的圆括号（<code>()</code>）表示，元素写入圆括号中，多个元素时用逗号分隔，如 <code>(1, 2, 3)</code>。</p>
<p>元组同样具有索引，索引使用方式与列表一致。其元素同样可以是任意类型。</p>
<p>看起来元组就是披着圆括号外衣的列表嘛！有什么区别？</p>
<p>元组创建完成后，便不能向其中添加元素，也不能修改和删除其中的任何一个元素。所以它与列表相比，只能查找元素，也就是说只具备读的功能，不具备写的功能。元组的这一特性叫作<strong>不可变（性）</strong>（Immutable），而列表是<strong>可变的</strong>（Mutable）。</p>
<h3 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h3><p>1.创建空的元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元组 = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line">()</span><br></pre></td></tr></table></figure>



<p>2.创建包含多个元素的元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元组 = (元素<span class="number">1</span>, 元素<span class="number">2</span>, ..., 元素N)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>



<p>3.创建只包含一个元素的元组</p>
<p>只包含一个元素的情况需要单独说明一下，因为它的形式与直觉不相符。</p>
<p>创建只包含一个元素的元组，需要在唯一的那个元素后面<strong>加上逗号</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元组 = (元素,)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure>

<p>这是因为，如果括号中只有一个元素，那么 Python 会将这个括号当作优先级符号进行处理（像数学中的那样），而不是当作元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = (<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(items)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> ‘<span class="title">int</span>’&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="元组元素的获取"><a href="#元组元素的获取" class="headerlink" title="元组元素的获取"></a>元组元素的获取</h3><p>1.通过索引获取元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元素 = 元组[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>]</span><br><span class="line">’c’</span><br></pre></td></tr></table></figure>



<p>2.通过元素获取索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">索引 = 元组.index(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.index(‘c’)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>3.查看元素是否存在于元组中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 元素 <span class="keyword">in</span> 元组</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘a’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘z’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>4.统计元素在元组中出现的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">个数 = 元组.count(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.count(<span class="number">5</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<h2 id="元组和列表的差别"><a href="#元组和列表的差别" class="headerlink" title="元组和列表的差别"></a>元组和列表的差别</h2><p>我们可以看到，元组所具有的操作在使用方式上与和列表非常相似，甚至在一定程度上可以将元组看作是列表的精简版，但它们之间也有明显的差别。</p>
<ul>
<li>元组是不可变的（Immutable），列表是可变的（Mutable），元组在被创建之后，就不能添加、删除和修改元素，而列表可以</li>
<li>一般情况下元组的性能在略高于列表</li>
</ul>
<p>我们在什么时候用列表，什么时候用元组？</p>
<p>列表还是元组，通常性能不是从它们中做选择的主要考虑因素，因为它们之间的性能差异不是很大。我们的选择通常围绕着可变和不可变的特性进行，当我们需要添加元素或修改元素时，使用列表；当我们希望所有元素在创建之后便不再改变，可使用元组。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是 Python 中用来存放字符序列的数据类型，其中的元素只能是字符。字符串使用单引号或双引号来表示，如 <code>&#39;pick&#39;</code>，<code>&quot;cherry&quot;</code>，通常我们首先使用单引号。</p>
<p>字符串是有序序列，可以使用索引来获取其中某个位置的元素。它是不可变的，被创建之后其中的元素（也就是字符）不能被修改和删除。</p>
<h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><p>1.创建空字符串（即不包含字符的字符串）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串 = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string</span><br><span class="line">’’</span><br></pre></td></tr></table></figure>



<p>2.创建包含元素的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串 = <span class="string">'若干字符'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="string">'happy’</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; string</span></span><br><span class="line"><span class="string">’happy’</span></span><br></pre></td></tr></table></figure>



<h3 id="字符的获取"><a href="#字符的获取" class="headerlink" title="字符的获取"></a>字符的获取</h3><ol>
<li>通过索引获取字符<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符 = 字符串[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string[<span class="number">2</span>]</span><br><span class="line">’p’</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>2.通过子串获取索引</p>
<p>所谓子串就是从字符串中截取下来的一部分，可以是一个字符，一部分字符、全部字符、或空字符串，如 <code>&#39;a&#39;</code>、<code>&#39;ppy&#39;</code>、<code>&#39;happy&#39;</code>、<code>&#39;&#39;</code> 都是 ‘happy’ 的子串。查找子串时，返回的是子串的第一个字符的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">索引 = 字符串.index(字符)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.index(‘p’)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.index(‘app’)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>当字符或子串不存在时，<code>index</code> 方法将抛出 <code>ValueError</code> 错误。</p>
<p>也可采用字符串的 <code>find</code> 方法来查找子串，使用方式与 <code>index</code> 一致，不同点在于 <code>find</code> 方法未找到子串时返回数字 <code>-1</code>，而不抛异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.find(‘app’)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.find(‘z’)</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>



<p>3.查看字符是否存在于字符串中</p>
<p>查看字符是否存在于字符串中，需要借助 Python 的关键字 <code>in</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 字符 <span class="keyword">in</span> 字符串</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘a’ <span class="keyword">in</span> string</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘z’ <span class="keyword">in</span> string</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>4.统计字符在字符串中的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">个数 = 字符串.count(字符)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.count(‘p’)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串的处理"><a href="#字符串的处理" class="headerlink" title="字符串的处理"></a>字符串的处理</h3><p>字符串自带的方法非常多，除了上面介绍的几个之外还有四十多个，这是因为字符处理是编程时的一项高频工作。Python 将这些字符处理相关的功能以方法的形式集成在字符串里。这里列举几个常见的方法</p>
<p>1.startswith：判断字符串是否以某个子串开头，返回布尔值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.startswith(‘ha’)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>



<p>2.endswith：判断字符串是否以某个子串结尾，返回布尔值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.endswith(‘y’)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>



<p>3.replace：将字符串的子串用一个另一个字符串替换，返回一个新的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.replace(‘y’, ‘iness’)</span><br><span class="line">’happiness’</span><br></pre></td></tr></table></figure>



<p>4.strip：去除字符串前后的空白符号，如空格、换行符、制表符，返回一个新的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ’ \t happy \n’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.strip()</span><br><span class="line">’happy’</span><br></pre></td></tr></table></figure>



<p>5.split：将字符串用某个子串分隔开，分隔后的各个部分放入列表中，并返回这个列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘I am happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.split(’ <span class="string">')</span></span><br><span class="line"><span class="string">[‘I’, ‘am’, ‘happy’]</span></span><br></pre></td></tr></table></figure>



<p>6.join：将一个序列中的元素用某个字符（串）拼接，组成一个大的字符串，并返回这个字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = [‘I’, ‘am’, ‘happy’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>’ <span class="string">'.join(words)</span></span><br><span class="line"><span class="string">’I am happy’</span></span><br></pre></td></tr></table></figure>



<p>7.upper：将字符串转化为大写字母形式，返回一个新的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.upper()</span><br><span class="line">’HAPPY’</span><br></pre></td></tr></table></figure>



<p>8.lower：将字符串转化为小写字母形式，返回一个新的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘HAPPY’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.lower()</span><br><span class="line">’happy’</span><br></pre></td></tr></table></figure>

<p>注意上面的这些字符处理功能，对字符串作处理后都是返回一个新的字符串，而不会直接修改原有的字符串。为什么呢？<strong>字符串不可变呀！</strong></p>
<h2 id="列表、元组、字符串的通用操作"><a href="#列表、元组、字符串的通用操作" class="headerlink" title="列表、元组、字符串的通用操作"></a>列表、元组、字符串的通用操作</h2><p>我们把列表、元组、字符串统称为<strong>序列</strong></p>
<p>1.使用 <code>len()</code> 函数获取序列长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(letters)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = ‘abcd’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(letters)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>2.获取序列中的一个子序列</p>
<p>获取序列中的子序列可以使用<strong>切片</strong>，以 <code>[起始索引:结束索引]</code> 表示。切片其实代表一个索引区间，这个区间是一个<strong>左开右闭区间</strong>，该区间内的所有元素作为子序列被返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = ‘abcd’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">’bcd’</span><br></pre></td></tr></table></figure>



<p>3.使用 <code>+</code> 符号来拼接两个序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_1 = (‘a’, ‘b’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_2 = (‘c’, ‘d’, ‘e’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_1 + letters_2</span><br><span class="line">(‘a’, ‘b’, ‘c’, ‘d’, ‘e’)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_1 = ‘ab’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_2 = ‘cde’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_1 + letters_2</span><br><span class="line">’abcde’</span><br></pre></td></tr></table></figure>



<p>4.使用 <code>*</code> 符号来重复序列中的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters * <span class="number">3</span></span><br><span class="line">(‘a’, ‘b’, ‘a’, ‘b’, ‘a’, ‘b’)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = ‘abcd’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters * <span class="number">2</span></span><br><span class="line">’abcdabcd’</span><br></pre></td></tr></table></figure>

<p>注意上面的操作结果都是返回一个新的序列，不会对修改序列的内部元素</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>列表、元组、字符串都是有序序列，都可以使用索引。</p>
<p>列表和元组中可以存放任意数据类型的元素，而字符串中只能存放字符。</p>
<p>列表是可变的，而元组和字符串是不可变的。</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo d部署后需要在github上重新保存域名的问题</title>
    <url>/2020/02/01/18.hexo%20d%E9%83%A8%E7%BD%B2%E5%90%8E%E9%9C%80%E8%A6%81%E5%9C%A8github%E4%B8%8A%E9%87%8D%E6%96%B0%E4%BF%9D%E5%AD%98%E5%9F%9F%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>1.在根目录的source文件夹下新建一个CNAME文件（无后缀），内容就写自己的域名</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.maxinhong.com</span><br></pre></td></tr></table></figure>

<p>2.hexo g重新生成一下静态文件</p>
<p>3.hexo d部署</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive DDL之数据库操作</title>
    <url>/2020/01/30/17.Hive%20DDL%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>官方文档</strong>：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL</a></p>
<p>详情请看官方文档，本文只记录部分关键字便于回忆查询</p>
<p>DDL：Hive Data Definition Language</p>
<p>&emsp;&emsp;create、delete、alter…</p>
<p>Hive数据抽象/结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">database     HDFS一个目录</span><br><span class="line">	table    HDFS一个目录</span><br><span class="line">		data  文件 </span><br><span class="line">		partition 分区表  HDFS一个目录</span><br><span class="line">			data  文件 </span><br><span class="line">			bucket  分桶   HDFS一个文件</span><br></pre></td></tr></table></figure>



<p>创建数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (DATABASE|SCHEMA) [IF NOT EXISTS] database_name</span><br><span class="line">  [COMMENT database_comment]</span><br><span class="line">  [LOCATION hdfs_path]</span><br><span class="line">  [WITH DBPROPERTIES (property_name&#x3D;property_value, ...)];</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">CREATE DATABASE IF NOT EXISTS hive;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS hive2 LOCATION &#39;&#x2F;test&#x2F;location&#39;;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS hive3 WITH DBPROPERTIES(&#39;creator&#39;&#x3D;&#39;pearfl&#39;);</span><br></pre></td></tr></table></figure>

<p>/usr/hive/warehouse是Hive默认的存储在HDFS上的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD DATA LOCAL INPATH &#39;&#x2F;home&#x2F;hadoop&#x2F;data&#x2F;emp.txt&#39; OVERWRITE INTO TABLE emp;</span><br><span class="line"></span><br><span class="line">LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)]</span><br><span class="line"></span><br><span class="line">LOCAL：本地系统，如果没有local那么就是指的HDFS的路径</span><br><span class="line">OVERWRITE：是否数据覆盖，如果没有那么就是数据追加</span><br><span class="line"></span><br><span class="line">LOAD DATA LOCAL INPATH &#39;&#x2F;home&#x2F;hadoop&#x2F;data&#x2F;emp.txt&#39; OVERWRITE INTO TABLE emp;</span><br><span class="line"></span><br><span class="line">LOAD DATA INPATH &#39;hdfs:&#x2F;&#x2F;hadoop000:8020&#x2F;data&#x2F;emp.txt&#39; INTO TABLE emp;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT OVERWRITE LOCAL DIRECTORY &#39;&#x2F;tmp&#x2F;hive&#x2F;&#39;</span><br><span class="line">ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\t&#39;</span><br><span class="line">select empno,ename,sal,deptno from emp;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive部署</title>
    <url>/2020/01/28/16.Hive%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="Hive部署"><a href="#Hive部署" class="headerlink" title="Hive部署"></a>Hive部署</h2><p>1）下载</p>
<p>2）解压</p>
<p>3）添加HIVE_HOME到系统环境变量</p>
<p>4）修改配置 hive-env.sh</p>
<p>5）拷贝MySQL驱动包到$HIVE_HOME/lib</p>
<p>6）前提是要安装一个MySQL数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf hive-1.1.0-cdh5.16.2.tar.gz -C ~&#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line">配置.bash_profile</span><br><span class="line">export HIVE_HOME&#x3D;&#x2F;root&#x2F;app&#x2F;hive-1.1.0-cdh5.16.2</span><br><span class="line">export PATH&#x3D;$HIVE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>



<p>在hive文件夹的conf文件夹内进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cp hive-env.sh.template hive-env.sh</span><br></pre></td></tr></table></figure>

<p>若hadoop没有配置进环境变量，需要再hive-env.sh内配置HADOOP_HOME</p>
<p>配置hive-site.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;xsl&quot; href&#x3D;&quot;configuration.xsl&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionURL&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;jdbc:mysql:&#x2F;&#x2F;hadoop000:3306&#x2F;hadoop_hive?createDatabaseIfNotExist&#x3D;true&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;com.mysql.jdbc.Driver&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;root&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;root&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p>javax.jdo.option.ConnectionUserName对应mysql中的账号</p>
<p>javax.jdo.option.ConnectionPassword对应mysql中的密码</p>
<p>拷贝mysql的架包到hive文件夹下的lib文件夹中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp mysql-connector-java-5.1.28.jar &#x2F;root&#x2F;app&#x2F;hive-1.1.0-cdh5.16.2&#x2F;lib&#x2F;mysql-connector-java-5.1.28.jar</span><br></pre></td></tr></table></figure>



<h2 id="hive编译安装"><a href="#hive编译安装" class="headerlink" title="hive编译安装"></a>hive编译安装</h2><p>hive-1.1.0-cdh5.16.2-src.tar.gz已下载在~/tmp下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd &#x2F;tmp&#x2F;</span><br><span class="line"># tar -xf hive-1.1.0-cdh5.16.2-src.tar.gz</span><br><span class="line"># cd &#x2F;hive-1.1.0-cdh5.16.2</span><br><span class="line"># mvn clean package -DskipTests -Phadoop-2 -Pdist</span><br></pre></td></tr></table></figure>

<p>之后会有一个比较长时间的等待</p>
<p>编译生成的包在以下位置：</p>
<p>packaging/target/apache-hive-1.1.0-cdh5.7.1-bin.tar.gz，之后就是像之前博客一样配置环境变量</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j相关配置</title>
    <url>/2020/01/27/15.log4j%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>log4j.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootCategory&#x3D;info, console</span><br><span class="line">log4j.appender.console&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.target&#x3D;System.err</span><br><span class="line">log4j.appender.console.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern&#x3D;%p %c&#123;1&#125;: %m%n</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径算法</title>
    <url>/2020/01/26/14.%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><h3 id="1-Dijkstra-算法"><a href="#1-Dijkstra-算法" class="headerlink" title="1.$Dijkstra$算法"></a>1.$Dijkstra$算法</h3><p>解决单源最短路径问题常用 Dijkstra 算法，用于计算一个顶点到其他所有顶点的最短路径。Dijkstra 算法的主要特点是以起点为中心，逐层向外扩展（这一点类似于 bfs，但是不同的是，bfs 每次扩展一个层，但是 Dijkstra 每次只会扩展一个点），每次都会取一个最近点继续扩展，直到取完所有点为止。 </p>
<p>注意：Dijkstra 算法要求图中不能出现负权边。</p>
<h4 id="①、-Dijkstra-算法流程"><a href="#①、-Dijkstra-算法流程" class="headerlink" title="①、$Dijkstra$算法流程"></a>①、$Dijkstra$算法流程</h4><p>我们定义带权图$ G $所有顶点的集合为$ V$，接着我们再定义已确定从源点出发的最短路径的顶点集合为$ U$，初始集合 $U $为空，记从源点$ s $出发到每个顶点$ v $的距离为 $dist_v $，初始 $dist_s$=0。接着执行以下操作： </p>
<ol>
<li><p>从 $V−U $中找出一个距离源点最近的顶点$v$，将$v$加入集合$ U$。</p>
</li>
<li><p>并用 $dist_v$和顶点 $v $连出的边来更新和 $v $相邻的、不在集合 $U$中的顶点的 $dist$，这一步称为松弛操作。  </p>
</li>
<li><p>重复步骤 1 和 2，直到 $V=U$或找不出一个从$ s$ 出发有路径到达的顶点，算法结束。  </p>
</li>
</ol>
<p>如果最后 $V \neq U$，说明有顶点无法从源点到达；否则每个$ dist_i$表示从 $s$ 出发到顶点$ i $的最短距离。  </p>
<p>Dijkstra 算法的时间复杂度为$ \mathcal{O}(V^2)$，其中 $V$ 表示顶点的数量。</p>
<p>Dijkstra 是解决无负边权的图的单源最短路问题，经常使用邻接表存储。</p>
<p>不优化的时间复杂度是 $O(V^2 + E)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    edge() &#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[len] = edge(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    add(u, v, w);</span><br><span class="line">    add(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; mi) &#123;</span><br><span class="line">                mi = dis[u = j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mi == inf) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[u]; ~j; j = e[j].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[j].v;</span><br><span class="line">            <span class="keyword">int</span> w = e[j].w;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        add2(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dis[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="②、基于小根堆优化的-Dijkstra-算法"><a href="#②、基于小根堆优化的-Dijkstra-算法" class="headerlink" title="②、基于小根堆优化的$Dijkstra$算法"></a>②、基于小根堆优化的$Dijkstra$算法</h4><p>用一个set来维护点的集合，这样的时间复杂度就优化到了 $\mathcal{O}((V+E)\log V)$，对于稀疏图的优化效果非常好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125; e[MAX_M];</span><br><span class="line"><span class="keyword">int</span> p[MAX_N], eid, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mapinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    eid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权有向边</span></span><br><span class="line">    e[eid].v = v;</span><br><span class="line">    e[eid].w = w;</span><br><span class="line">    e[eid].next = p[u];</span><br><span class="line">    p[u] = eid++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权双向边</span></span><br><span class="line">    insert(u, v, w);</span><br><span class="line">    insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="built_in">set</span>&lt;PII, less&lt;PII&gt; &gt; min_heap;</span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];  <span class="comment">// 存储单源最短路的结果</span></span><br><span class="line"><span class="keyword">bool</span> vst[MAX_N];  <span class="comment">// 标记每个顶点是否在集合 U 中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 dist、小根堆和集合 U</span></span><br><span class="line">    <span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span>(vst));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    min_heap.insert(make_pair(<span class="number">0</span>, s));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min_heap.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;  <span class="comment">// 如果小根堆中没有可用顶点，说明有顶点无法从源点到达，算法结束</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取堆顶元素，并将堆顶元素从堆中删除</span></span><br><span class="line">        <span class="built_in">set</span>&lt;PII, less&lt;PII&gt; &gt;::iterator iter = min_heap.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> v = iter-&gt;second;</span><br><span class="line">        min_heap.erase(*iter);</span><br><span class="line">        vst[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 进行和普通 dijkstra 算法类似的松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = p[v]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = e[j].v;</span><br><span class="line">            <span class="keyword">if</span> (!vst[x] &amp;&amp; dist[v] + e[j].w &lt; dist[x]) &#123;</span><br><span class="line">                <span class="comment">// 先将对应的 pair 从堆中删除，再将更新后的 pair 插入堆</span></span><br><span class="line">                min_heap.erase(make_pair(dist[x], x));</span><br><span class="line">                dist[x] = dist[v] + e[j].w;</span><br><span class="line">                min_heap.insert(make_pair(dist[x], x));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 存储单源最短路的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="③、基于优先队列优化的-Dijkstra-算法"><a href="#③、基于优先队列优化的-Dijkstra-算法" class="headerlink" title="③、基于优先队列优化的$Dijkstra$算法"></a>③、基于优先队列优化的$Dijkstra$算法</h4><p>我们在 $node $节点里面记录对应的点的最短路，然后每次更新一个点的最短路后都把这个点压入到优先队列里面（不管之前有没有被压入到队列里面），这样就一定能够保证优先队列对的性质不会改变</p>
<p>这个代码的时间复杂度实际上会比用真正的堆要慢一点，因为有的点可能会入队多次，但是每一条边最多导致一次入队，所以这个算法的时间复杂度为 $\mathcal{O}(E\log E)$。其中$ E $为边的数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125; e[MAX_M];</span><br><span class="line"><span class="keyword">int</span> p[MAX_N], eid, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mapinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    eid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权有向边</span></span><br><span class="line">    e[eid].v = v;</span><br><span class="line">    e[eid].w = w;</span><br><span class="line">    e[eid].next = p[u];</span><br><span class="line">    p[u] = eid++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权双向边</span></span><br><span class="line">    insert(u, v, w);</span><br><span class="line">    insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];  <span class="comment">// 存储单源最短路的结果</span></span><br><span class="line"><span class="keyword">bool</span> vst[MAX_N];  <span class="comment">// 标记每个顶点是否在集合 U 中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">  <span class="keyword">int</span> dist;</span><br><span class="line">    node(<span class="keyword">int</span> _u, <span class="keyword">int</span> _dist) : u(_u), dist(_dist) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dist &gt; x.dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">// 记录点的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 dist、小根堆和集合 U</span></span><br><span class="line">    <span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span>(vst));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    priority_queue&lt;node&gt; min_heap;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    min_heap.push(node(s, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!min_heap.empty())</span><br><span class="line">        <span class="comment">// 获取堆顶元素，并将堆顶元素从堆中删除</span></span><br><span class="line">        <span class="keyword">int</span> v = min_heap.top().u;</span><br><span class="line">        min_heap.pop();</span><br><span class="line">        <span class="keyword">if</span> (vst[v]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vst[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 进行和普通 dijkstra 算法类似的松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = p[v]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = e[j].v;</span><br><span class="line">            <span class="keyword">if</span> (!vst[x] &amp;&amp; dist[v] + e[j].w &lt; dist[x]) &#123;</span><br><span class="line">                dist[x] = dist[v] + e[j].w;</span><br><span class="line">                min_heap.push(node(x, dist[x]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-SPFA-算法"><a href="#2-SPFA-算法" class="headerlink" title="2.$SPFA$算法"></a>2.$SPFA$算法</h3><p>SPFA（Shortest Path Faster Algorithm）算法是单源最短路径的一种算法，通常被认为是 Bellman-ford 算法的队列优化，在代码形式上接近于宽度优先搜索 BFS，是一个在实践中非常高效的单源最短路算法。</p>
<h4 id="①、-SPFA-算法流程"><a href="#①、-SPFA-算法流程" class="headerlink" title="①、$SPFA$算法流程"></a>①、$SPFA$算法流程</h4><p>在 $SPFA$ 算法中，使用 $d_i$表示从源点到顶点$i$的最短路，额外用一个队列来保存即将进行拓展的顶点列表，并用 $inq_i$来标识顶点$i$是不是在队列中。</p>
<p>1.初始队列中仅包含源点，且源点 $s$ 的 $d_s=0$。</p>
<p>2.取出队列头顶点 $u$，扫描从顶点 $u$ 出发的每条边，设每条边的另一端为 $v$，边$&lt;u,v&gt;$ 权值为 $w$，若 $d_u+w&lt;d_v$，则 </p>
<ul>
<li><p>将 $d_v$修改为 $d_u+w$</p>
</li>
<li><p>若 $v$ 不在队列中，则 </p>
</li>
<li><p>将 $v $入队 </p>
</li>
</ul>
<p>3.重复步骤 2 直到队列为空 </p>
<p>最终$ d$ 数组就是从源点出发到每个顶点的最短路距离。如果一个顶点从没有入队，则说明没有从源点到该顶点的路径。</p>
<p>$SPFA$ 的空间复杂度为$ \mathcal{O}(V)$。如果顶点的平均入队次数为 $k$，则 $SPFA $的时间复杂度为 $\mathcal{O}(kE)$O，对于较为随机的稀疏图，根据经验 $k$ 一般不超过 4。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    edge()&#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail)&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[len] = edge(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    add(u, v, w);</span><br><span class="line">    add(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = head[u];~j;j = e[j].fail)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[j].v;</span><br><span class="line">            <span class="keyword">int</span> w = e[j].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w)&#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add2(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dis[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②、-SPFA-判断负环"><a href="#②、-SPFA-判断负环" class="headerlink" title="②、$SPFA$判断负环"></a>②、$SPFA$判断负环</h4><p>$Dijkstra$不能处理有负权的图，而 $SPFA$ 可以处理任意不含负环（负环是指总边权和为负数的环）的图的最短路，并能判断图中是否存在负环</p>
<p>但是 $SPFA $可以用来判断负环，在进行 $SPFA $时，用一个数组 $cnt_i$来标记每个顶点入队次数。如果一个顶点入队次数 $cnt_i$大于顶点总数 n，则表示该图中包含负环。一般情况下，$SPFA$ 判负环都只用在有向图上，因为在无向图上，一条负边权的边就是一个负环了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span> in);</span><br><span class="line">in[u] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 修改入队部分的操作</span></span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">    q.push(v);</span><br><span class="line">    vis[v] = <span class="literal">true</span>;</span><br><span class="line">    ++in[v];</span><br><span class="line">    <span class="keyword">if</span>(in[v] &gt; n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、-floyd-多源最短路算法"><a href="#3、-floyd-多源最短路算法" class="headerlink" title="3、$floyd$多源最短路算法"></a>3、$floyd$多源最短路算法</h3><p>$∀1≤k≤n,dp [i] [j] = min（dp[i] [j]，dp[i][k]+ dp [k][j]）$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL创建用户与授权</title>
    <url>/2020/01/24/13.MySQL%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1.创建用户"></a>1.创建用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</span><br></pre></td></tr></table></figure>

<p>username：你将创建的用户名<br>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%<br>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;dog&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;192.168.1.101_&#39; IDENDIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>





<h2 id="2-授权"><a href="#2-授权" class="headerlink" title="2.授权"></a>2.授权</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;</span><br></pre></td></tr></table></figure>

<p>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL<br>databasename：数据库名<br>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</p>
<p>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:<br>GRANT privileges ON databasename.tablename TO ‘username’@’host’ WITH GRANT OPTION;</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON maindataplus.* TO &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>



<h2 id="3-设置与更改用户密码"><a href="#3-设置与更改用户密码" class="headerlink" title="3.设置与更改用户密码"></a>3.设置与更改用户密码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; &#x3D; PASSWORD(&#39;newpassword&#39;);</span><br></pre></td></tr></table></figure>

<p>如果是当前登陆用户用:<br>SET PASSWORD = PASSWORD(“newpassword”);</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR &#39;pig&#39;@&#39;%&#39; &#x3D; PASSWORD(&quot;123456&quot;);</span><br></pre></td></tr></table></figure>



<h2 id="4-撤销用户权限"><a href="#4-撤销用户权限" class="headerlink" title="4.撤销用户权限"></a>4.撤销用户权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure>

<p>privilege, databasename, tablename：同授权部分</p>
<p>假如你在给用户‘pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。</p>
<p>相反，如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。</p>
<p>具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>



<h2 id="5-删除用户"><a href="#5-删除用户" class="headerlink" title="5.删除用户"></a>5.删除用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP USER &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7使用firewalld打开关闭防火墙与端口</title>
    <url>/2020/01/23/12.CentOS7%E4%BD%BF%E7%94%A8firewalld%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E7%AB%AF%E5%8F%A3%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="CentOS7使用firewalld打开关闭防火墙与端口"><a href="#CentOS7使用firewalld打开关闭防火墙与端口" class="headerlink" title="CentOS7使用firewalld打开关闭防火墙与端口"></a>CentOS7使用firewalld打开关闭防火墙与端口</h2><p>1、firewalld的基本使用</p>
<p>启动： systemctl start firewalld</p>
<p>关闭： systemctl stop firewalld</p>
<p>查看状态： systemctl status firewalld </p>
<p>开机禁用 ： systemctl disable firewalld</p>
<p>开机启用 ： systemctl enable firewalld</p>
<p>2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。</p>
<p>启动一个服务：systemctl start firewalld.service<br>关闭一个服务：systemctl stop firewalld.service<br>重启一个服务：systemctl restart firewalld.service<br>显示一个服务的状态：systemctl status firewalld.service<br>在开机时启用一个服务：systemctl enable firewalld.service<br>在开机时禁用一个服务：systemctl disable firewalld.service<br>查看服务是否开机启动：systemctl is-enabled firewalld.service<br>查看已启动的服务列表：systemctl list-unit-files|grep enabled<br>查看启动失败的服务列表：systemctl –failed</p>
<p>3.配置firewalld-cmd</p>
<p>查看版本： firewall-cmd –version</p>
<p>查看帮助： firewall-cmd –help</p>
<p>显示状态： firewall-cmd –state</p>
<p>查看所有打开的端口： firewall-cmd –zone=public –list-ports</p>
<p>更新防火墙规则： firewall-cmd –reload</p>
<p>查看区域信息:  firewall-cmd –get-active-zones</p>
<p>查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0</p>
<p>拒绝所有包：firewall-cmd –panic-on</p>
<p>取消拒绝状态： firewall-cmd –panic-off</p>
<p>查看是否拒绝： firewall-cmd –query-panic</p>
<p>那怎么开启一个端口呢</p>
<p>添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent   （--permanent永久生效，没有此参数重启后失效）</span><br></pre></td></tr></table></figure>

<p>重新载入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D; public --query-port&#x3D;80&#x2F;tcp</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D; public --remove-port&#x3D;80&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>firewalld</tag>
      </tags>
  </entry>
  <entry>
    <title>pip源以及virtualenv基本操作</title>
    <url>/2020/01/22/11.pip%E6%BA%90%E4%BB%A5%E5%8F%8Avirtualenv%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="virtualenv基本操作（windows环境）"><a href="#virtualenv基本操作（windows环境）" class="headerlink" title="virtualenv基本操作（windows环境）"></a>virtualenv基本操作（windows环境）</h2><p>1、下载virtualenv</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure>

<p>2、创建一个virtualenv工作目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir myproject_env</span><br></pre></td></tr></table></figure>

<p>3、穿件一个python项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtualenv venv</span><br></pre></td></tr></table></figure>

<p>4、启动virtualenv中的venv项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd venv\Scripts&#96;&#96;activate</span><br></pre></td></tr></table></figure>

<p>5、关闭virtualenv</p>
<p>需要在venv\Scripts内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>



<h2 id="pip源修改"><a href="#pip源修改" class="headerlink" title="pip源修改"></a>pip源修改</h2><p>国内源：<br>新版ubuntu要求使用https源，要注意。</p>
<p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>华中理工大学：<a href="http://pypi.hustunique.com/" target="_blank" rel="noopener">http://pypi.hustunique.com/</a></p>
<p>山东理工大学：<a href="http://pypi.sdutlinux.org/" target="_blank" rel="noopener">http://pypi.sdutlinux.org/</a></p>
<p>豆瓣：<a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></p>
<p>临时使用：<br>可以在使用pip的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>例如：pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyspider，这样就会从清华这边的镜像去安装pyspider库。</p>
<p>永久修改，一劳永逸：<br>Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)</p>
<p>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<p>windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini。内容同上。</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>无法停止hadoop集群</title>
    <url>/2020/01/20/10.%E6%97%A0%E6%B3%95%E5%81%9C%E6%AD%A2hadoop%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>问题描述：</p>
<p>执行 ./bin/stop-all.sh 脚本一直提示没有可停止的namenode、datanode、secondarynode。</p>
<p>可是输入 jps 命令，发现hadoop 已经启动。</p>
<p>原因：</p>
<p>hadoop在stop的时候依据的是datanode上的mapred和dfs进程号。而默认的进程号保存在/tmp下，linux默认会每 隔一段时间（一般是一个月或者7天左右）去删除这个目录下的文件。因此删掉hadoop-hadoop-jobtracker.pid和hadoop- hadoop-namenode.pid两个文件后，namenode自然就找不到datanode上的这两个进程了。</p>
<p>解决方法：</p>
<p>jps查看所有进程的pid，手动杀死进程 kill -9 pid，多个节点都需要操作！<br>为了避免下次也出现问题，在配置文件中$HADOOP_HOME/etc/hadoop/hadoop-env.sh中添加如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HADOOP_PID_DIR&#x3D;$&#123;HADOOP_HOME&#125;&#x2F;pids</span><br></pre></td></tr></table></figure>

<p>重启Hadoop集群，即可</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>DBWritable与Writable的坑</title>
    <url>/2020/01/18/%EF%BC%819.DBWritable%E4%B8%8EWritable%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>export HADOOP_CLASSPATH=$HADOOP_CLASSPATH:~/lib/mysql-connector-java-5.1.28-bin.jar</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql5.6安装</title>
    <url>/2020/01/15/8.mysql5.6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>本次操作在centos7.2版本的服务器上成功实现，本文不涉及rpm和源码安装2种方式，本文采用二进制安装</p>
<h2 id="1-首先我们需要卸载内置的mariadb"><a href="#1-首先我们需要卸载内置的mariadb" class="headerlink" title="1.首先我们需要卸载内置的mariadb"></a>1.首先我们需要卸载内置的mariadb</h2><p>原因是以前的Linux系统中数据库大部分是mysql，不过自从被sun收购之后，就没用集成在centos这些开源Linux系统中了，那么如果想用的话就需要自己安装了，首先centos7 已经不支持mysql，因为收费了你懂得，所以内部集成了mariadb，而安装mysql的话会和mariadb的文件冲突，所以需要先卸载掉mariadb</p>
<p>操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum search mysql &#x2F;&#x2F;检查是否有mariadb.x86_64</span><br><span class="line"># yum remove mariadb-libs.x86_64</span><br></pre></td></tr></table></figure>



<h2 id="2-下载mysql"><a href="#2-下载mysql" class="headerlink" title="2.下载mysql"></a>2.下载mysql</h2><p>安装包：mysql-5.6.47-linux-glibc2.12-x86_64.tar.gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 下载</span><br><span class="line">#wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;Downloads&#x2F;MySQL-5.6&#x2F;mysql-5.6.47-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line">&#x2F;&#x2F; 解压</span><br><span class="line"># tar -zxvf mysql-5.6.47-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line">&#x2F;&#x2F; 复制解压后的mysql目录</span><br><span class="line"># cp -r mysql-5.6.47-linux-glibc2.12-x86_64 &#x2F;usr&#x2F;local&#x2F;mysql</span><br></pre></td></tr></table></figure>



<h2 id="3-添加用户组和用户"><a href="#3-添加用户组和用户" class="headerlink" title="3.添加用户组和用户"></a>3.添加用户组和用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;添加用户组</span><br><span class="line"># groupadd mysql</span><br><span class="line">&#x2F;&#x2F;添加用户mysql 到用户组mysql</span><br><span class="line"># useradd -g mysql mysql</span><br></pre></td></tr></table></figure>



<h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4.安装"></a>4.安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;</span><br><span class="line"># mkdir .&#x2F;data&#x2F;mysql</span><br><span class="line"># chown -R mysql:mysql .&#x2F;</span><br><span class="line"># .&#x2F;scripts&#x2F;mysql_install_db --user&#x3D;mysql --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql</span><br><span class="line"># cp support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br><span class="line"># chmod 755 &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br><span class="line"># cp support-files&#x2F;my-default.cnf &#x2F;etc&#x2F;my.cnf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;修改启动脚本</span><br><span class="line"># vi &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;修改项：</span><br><span class="line">basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;</span><br><span class="line">datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动服务</span><br><span class="line"># service mysqld start</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加入环境变量，编辑 &#x2F;etc&#x2F;profile，这样可以在任何地方用mysql命令了</span><br><span class="line"># export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;&#x2F;bin&lt;br&gt;source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动mysql</span><br><span class="line"># service mysqld start</span><br><span class="line">&#x2F;&#x2F;关闭mysql</span><br><span class="line"># service mysqld stop</span><br><span class="line">&#x2F;&#x2F;查看运行状态</span><br><span class="line"># service mysqld status</span><br></pre></td></tr></table></figure>



<p>可能出现的问题↓</p>
<p>问题1:：FATAL ERROR: please install the following Perl modules before executing</p>
<p>问题原因：缺少autoconf库</p>
<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install autoconf</span><br></pre></td></tr></table></figure>



<p>问题2：Installing MySQL system tables…./bin/mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory</p>
<p>问题原因：缺少libaio库文件</p>
<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install libaio*</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>手机流量统计-自定义序列化类</title>
    <url>/2020/01/14/7.%E6%89%8B%E6%9C%BA%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB/</url>
    <content><![CDATA[<p>Access.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Writable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInput;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutput;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Access</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> up;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> down;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone + <span class="string">'\t'</span> + up + <span class="string">'\t'</span> + down + <span class="string">'\t'</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Access</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Access</span><span class="params">(String phone, <span class="keyword">long</span> up, <span class="keyword">long</span> down)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        <span class="keyword">this</span>.up = up;</span><br><span class="line">        <span class="keyword">this</span>.down = down;</span><br><span class="line">        <span class="keyword">this</span>.sum = up + down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeUTF(phone);</span><br><span class="line">        dataOutput.writeLong(up);</span><br><span class="line">        dataOutput.writeLong(down);</span><br><span class="line">        dataOutput.writeLong(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = dataInput.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.up = dataInput.readLong();</span><br><span class="line">        <span class="keyword">this</span>.down = dataInput.readLong();</span><br><span class="line">        <span class="keyword">this</span>.sum = dataInput.readLong();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> up;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">(<span class="keyword">long</span> up)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.up = up;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDown</span><span class="params">(<span class="keyword">long</span> down)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.down = down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">(<span class="keyword">long</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SerDriver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ruozedata.bigdata.hadoop.utils.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 千篇一律</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 获取Job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 本job对应要执行的主类是哪个</span></span><br><span class="line">        job.setJarByClass(SerDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(MyReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(Access<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 设置Reducer阶段输出数据的类型</span></span><br><span class="line">        job.setOutputKeyClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(Access<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6) 设置输入和输出路径</span></span><br><span class="line">        String input = <span class="string">"data/access.log"</span>;</span><br><span class="line">        String output = <span class="string">"out"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FileUtils.deleteOutput(configuration, output);</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7) 提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Access</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String[] splits = value.toString().split(<span class="string">"\t"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手机号</span></span><br><span class="line">            String phone = splits[<span class="number">1</span>]; <span class="comment">//index是从0开始的</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上行流量</span></span><br><span class="line">            <span class="keyword">long</span> up = Long.parseLong(splits[splits.length - <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下行流量</span></span><br><span class="line">            <span class="keyword">long</span> down = Long.parseLong(splits[splits.length - <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写出去</span></span><br><span class="line"><span class="comment">//            Access access = new Access();</span></span><br><span class="line"><span class="comment">//            access.setPhone(phone);</span></span><br><span class="line"><span class="comment">//            access.setUp(up);</span></span><br><span class="line"><span class="comment">//            access.setDown(down);</span></span><br><span class="line"><span class="comment">//            access.setSum(up + down);</span></span><br><span class="line"></span><br><span class="line">            context.write(<span class="keyword">new</span> Text(phone), <span class="keyword">new</span> Access(phone, up, down));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">Access</span>, <span class="title">NullWritable</span>, <span class="title">Access</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text phone, Iterable&lt;Access&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> ups = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> downs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            Iterator&lt;Access&gt; iterator = values.iterator();</span></span><br><span class="line"><span class="comment">//            while(iterator.hasNext())&#123;</span></span><br><span class="line"><span class="comment">//                Access next = iterator.next();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(Access access : values)&#123;</span><br><span class="line">                ups += access.getUp();</span><br><span class="line">                downs += access.getDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            context.write(NullWritable.get(), <span class="keyword">new</span> Access(phone.toString(), ups, downs));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>hdfs简单API编程</title>
    <url>/2020/01/07/6.hdfs%E7%AE%80%E5%8D%95API%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.permission.FsPermission;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HDFSAPITest2</span> </span>&#123;</span><br><span class="line">    FileSystem fileSystem;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        URI uri = <span class="keyword">new</span> URI(<span class="string">"hdfs://hadoop:8020"</span>);</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line"></span><br><span class="line">        configuration.set(<span class="string">"dfs.client.use.datanode.hostname"</span>, <span class="string">"true"</span>);</span><br><span class="line">        configuration.set(<span class="string">"dfs.replication"</span>, <span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">// 1) 获取HDFS客户端</span></span><br><span class="line">        fileSystem = FileSystem.get(uri, configuration, <span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 3) 关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(fileSystem != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fileSystem.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mkdir</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        fileSystem.mkdirs(<span class="keyword">new</span> Path(<span class="string">"hdfs://hadoop:8020/hdfstest0"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFromLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Path src = <span class="keyword">new</span> Path(<span class="string">"data/ruozedata.txt"</span>);</span><br><span class="line">        Path dst = <span class="keyword">new</span> Path(<span class="string">"/hdfstest"</span>);</span><br><span class="line">        fileSystem.copyFromLocalFile(src, dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyToLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Path src = <span class="keyword">new</span> Path(<span class="string">"/20201011/146.txt"</span>);</span><br><span class="line">        Path dst = <span class="keyword">new</span> Path(<span class="string">"output/146.txt"</span>);</span><br><span class="line">        fileSystem.copyToLocalFile(src, dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rename</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Path src = <span class="keyword">new</span> Path(<span class="string">"/20201011/20201011-0.txt"</span>);</span><br><span class="line">        Path dst = <span class="keyword">new</span> Path(<span class="string">"/20201011/146.txt"</span>);</span><br><span class="line">        fileSystem.rename(src, dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RemoteIterator&lt;LocatedFileStatus&gt; files = fileSystem.listFiles(<span class="keyword">new</span> Path(<span class="string">"/20201011"</span>), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(files.hasNext())&#123;</span><br><span class="line">            LocatedFileStatus fileStatus = files.next();</span><br><span class="line">            String path = fileStatus.getPath().toString();</span><br><span class="line">            <span class="keyword">long</span> len = fileStatus.getLen();</span><br><span class="line">            <span class="keyword">short</span> replication = fileStatus.getReplication();</span><br><span class="line">            FsPermission permission = fileStatus.getPermission();</span><br><span class="line">            String isDir = fileStatus.isDirectory()? <span class="string">"文件夹"</span> : <span class="string">"文件"</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(path + <span class="string">"\t"</span> + len + <span class="string">"\t"</span> + replication + <span class="string">"\t"</span> + permission + <span class="string">"\t"</span> + isDir);</span><br><span class="line"></span><br><span class="line">            BlockLocation[] blockLocations = fileStatus.getBlockLocations();</span><br><span class="line">            <span class="keyword">for</span>(BlockLocation location : blockLocations)&#123;</span><br><span class="line">                String[] hosts = location.getHosts();</span><br><span class="line">                <span class="keyword">for</span>(String host : hosts)&#123;</span><br><span class="line">                    System.out.println(host + <span class="string">"........"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        fileSystem.delete(<span class="keyword">new</span> Path(<span class="string">"/hdfstest"</span>), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop单结点集群搭建</title>
    <url>/2020/01/06/5.hadoop%E5%8D%95%E7%BB%93%E7%82%B9%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>官网描述:<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="noopener">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html</a></p>
<p>本文在官网描述的基础上做翻译和细节补充</p>
<h2 id="hadoop部署"><a href="#hadoop部署" class="headerlink" title="hadoop部署"></a>hadoop部署</h2><p>类似于前一篇章的jdk部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf hadoop-2.6.0-cdh5.16.2.tar.gz -C ~&#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line">hadoop软件包常见目录说明</span><br><span class="line">	bin: hadoop客户端命令</span><br><span class="line">	etc: hadoop相关的配置文件存放目录</span><br><span class="line">	sbin:启动hadoop相关进程的脚本</span><br><span class="line">	share:常用例子</span><br><span class="line"></span><br><span class="line">配置.bash_profile</span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;root&#x2F;app&#x2F;hadoop-2.6.0-cdh5.16.2</span><br><span class="line">export PATH&#x3D;$HADOOP_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>



<p>修改相关的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop-env.sh内需要配置JAVA_HOME</span><br><span class="line">localhost:8020中的localhost需要修改</span><br><span class="line"></span><br><span class="line">core-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:8020&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">hdfs-site.xml</span><br><span class="line">其中hadoop.tmp.dir修改是因为机器每次重启时候会清空tmp目录</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;root&#x2F;app&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">slaves</span><br><span class="line">	mxh(设置成你喜欢的就行了，注意需要与hostname一致)</span><br></pre></td></tr></table></figure>



<p>启动HDFS：第一次执行的时候一定要格式化文件系统，不要重复执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>


<p>启动集群</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$HADOOP_HOME&#x2F;sbin&#x2F;start-dfs.sh</span><br><span class="line">验证:</span><br><span class="line">#jps</span><br><span class="line">8148 NameNode</span><br><span class="line">8245 DataNode</span><br><span class="line">8540 SecondaryNameNode</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop学习前置部署</title>
    <url>/2020/01/04/4.hadoop%E5%AD%A6%E4%B9%A0%E5%89%8D%E6%9C%9F%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="jdk部署"><a href="#jdk部署" class="headerlink" title="jdk部署"></a>jdk部署</h2><p><strong>Hadoop安装前置要求Java版本在1.8+</strong></p>
<p>安装过程（本过程在root用户下进行，非root用户目录有轻微变动）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拷贝本地软件包到服务器（wget等方法均可）</span><br><span class="line"></span><br><span class="line">解压jdk:tar -zvxf jdk-8u231-linux-x64.tar.gz -C ~&#x2F;app&#x2F;</span><br><span class="line"># 解压的包放置在app文件夹内，根据个人需要选择</span><br><span class="line"></span><br><span class="line">把jdk配置在系统环境变量中: ~&#x2F;.bash_profile</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;root&#x2F;app&#x2F;jdk1.8.0_231</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">之后source一下使其生效:source .bash_profile</span><br><span class="line">可以通过echo $JAVA_HOME检查是否生效</span><br><span class="line">提示：此处&#x3D;左右不可有空格</span><br></pre></td></tr></table></figure>



<h2 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ssh-keygen -t rsa  #一路回车</span><br><span class="line">此时.ssh文件夹下有3个新文件</span><br><span class="line">id_rsa          # 私钥</span><br><span class="line">id_rsa.pub      # 公钥</span><br><span class="line">known_hosts     # </span><br><span class="line"></span><br><span class="line"># cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line"># chmod 600 authorized_keys</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>linux用户管理</title>
    <url>/2019/12/30/3.linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="简易命令"><a href="#简易命令" class="headerlink" title="简易命令"></a>简易命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd testuser  创建用户testuser</span><br><span class="line">passwd testuser  给已创建的用户testuser设置密码</span><br><span class="line">说明：新创建的用户会在&#x2F;home下创建一个用户目录testuser</span><br><span class="line">usermod --help  修改用户这个命令的相关参数</span><br><span class="line">userdel testuser  删除用户testuser</span><br><span class="line">rm -rf testuser  删除用户testuser所在目录</span><br></pre></td></tr></table></figure>



<h2 id="给用户添加root权限"><a href="#给用户添加root权限" class="headerlink" title="给用户添加root权限"></a>给用户添加root权限</h2><p>使用Linux系统时，经常会被要求使用超级权限，但是root的权限太过大了，一般慎用！！！因此可以通过给普通用户添加sudo权限，平常用普通用户进行操作，当需要root权限的时候进行sudo操作。以下为解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 进入超级用户模式，也就是输入”su root”，系统会让你输入超级用户密码，输入密码后就进入了超级用户模式。（当然，你也可以直接用root进入修改）</span><br><span class="line">2. 添加文件的写权限，也就是输入命令”chmod u+w &#x2F;etc&#x2F;sudoers”。</span><br><span class="line">3. 编辑&#x2F;etc&#x2F;sudoers文件，也就是输入命令”vim &#x2F;etc&#x2F;sudoers”，进入编辑模式，找到这一 行：”root ALL&#x3D;(ALL) ALL”（会用vim编辑器的可以使用“&#x2F;root ALL&#x3D;(ALL)ALL”定位）在其下面添加”xxx ALL&#x3D;(ALL) ALL”(这里的xxx是你的用户名)，然后保存退出。</span><br><span class="line">4. 撤销文件的写权限，也就是输入命令”chmod u-w &#x2F;etc&#x2F;sudoers”。</span><br></pre></td></tr></table></figure>



<h2 id="修改hostname"><a href="#修改hostname" class="headerlink" title="修改hostname"></a>修改hostname</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hostnamectl set-hostname &lt;newhostname&gt;</span><br></pre></td></tr></table></figure>





<h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><p>用户：使用操作系统的人</p>
<p>用户组：具有相同系统权限的一组用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;group 存储当前系统中所有用户组信息</span><br><span class="line">- Group:     x    : 123 : abc,def,xyz</span><br><span class="line">- 组名称:组密码占位符:组编号:组中用户列表名</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;gshadow 存储当前系统中用户组的密码信息</span><br><span class="line">- Group:  *  :       :abc,def,xyz</span><br><span class="line">- 组名称:组密码:组管理者:组中用户列表名</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;passwd 存储当前系统中所有用户的信息</span><br><span class="line">- user :    x   :   123 :   456   : xxxxxxx : &#x2F;home&#x2F;user : &#x2F;bin&#x2F;bash</span><br><span class="line">- 用户名:密码占位符:用户编号:用户组编号:用户注释信息: 用户主目录  : shell类型</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;shadow 存储当前系统中所有用户的密码信息</span><br><span class="line">- user : xxx :::::</span><br><span class="line">- 用户名: 密码 ::::</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一套样例</span><br><span class="line"></span><br><span class="line"># groupadd sexy 创建sexy用户组</span><br><span class="line"># groupadd -n market sexy 用sexy组名改为market</span><br><span class="line"># groupmod -g 668 market 修改market用户组编号</span><br><span class="line"># groupadd -g 888 boss 创建boss用户组，编号为888</span><br><span class="line"># groupdel market 删除market用户组</span><br><span class="line"># useradd -g sexy sdf 添加用户</span><br><span class="line"># useradd -g sexy jzmb</span><br><span class="line"># useradd -d &#x2F;home&#x2F;xxx imooc 添加用户并指定用户文件夹所在位置</span><br><span class="line"># usermod -c dgdzmx sdf 修改sdf注释</span><br><span class="line"># usermod -l cls sdf 用户名sdf更改为cls</span><br><span class="line"># usermod -d &#x2F;home&#x2F;cls cls 修改cls文件夹路径</span><br><span class="line"># usermod -g sexy imooc imooc切换进sexy用户组</span><br><span class="line"># userdel jzmb 删除jzmb账号</span><br><span class="line"># userdel -r jzmb 删除jzmb用户文件夹</span><br><span class="line"></span><br><span class="line">touch &#x2F;etc&#x2F;nologin 禁止root以外的其他账户登录</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd -l cls 锁定cls</span><br><span class="line"># passwd -u cls 解锁cls</span><br><span class="line"># passwd -d cls cls账户无密码登录</span><br></pre></td></tr></table></figure>



<h2 id="主要组和附属组"><a href="#主要组和附属组" class="headerlink" title="主要组和附属组"></a>主要组和附属组</h2><p>用户可以同时属于多个组</p>
<ul>
<li>一个主要组</li>
<li>多个附属组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一套样例</span><br><span class="line"></span><br><span class="line"># gpasswd -a cls boss boss组变为cls的附属组,用逗号可以添加多个附属组</span><br><span class="line"># newgrp boss （cls自己执行，切换到boss组）</span><br><span class="line"># gpasswd -a cls boss cls不在是boss组的附属组</span><br></pre></td></tr></table></figure>







<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>权限</tag>
        <tag>linux</tag>
        <tag>用户</tag>
      </tags>
  </entry>
  <entry>
    <title>frp实现内网穿透</title>
    <url>/2019/12/29/%EF%BC%812.frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;对于没有公网ip的内网用户来说，远程管理或在外网访问内网机器上的服务是一个比较麻烦的问题，为了解决这个问题，我介绍一款相当好用的内网穿透工具frp。<br>&emsp;&emsp;frp 是一个使用 Go 语言开发的高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务。FRP 支持 TCP、UDP、HTTP、HTTPS等协议类型，并且支持 Web 服务根据域名进行路由转发。<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frp项目地址: https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp</span><br></pre></td></tr></table></figure>



<h1 id="frp的作用"><a href="#frp的作用" class="headerlink" title="frp的作用"></a>frp的作用</h1><p>1.利用处于内网或防火墙后的机器，对外网环境提供 HTTP 或 HTTPS 服务。</p>
<p>2.对于 HTTP, HTTPS 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个 80 端口。</p>
<p>3.利用处于内网或防火墙后的机器，对外网环境提供 TCP 和 UDP 服务，例如在家里通过 SSH 访问处于公司内网环境内的主机。</p>
<h1 id="frp安装"><a href="#frp安装" class="headerlink" title="frp安装"></a>frp安装</h1><p>FRP 采用 Go 语言开发，支持 Windows、Linux、MacOS、ARM等多平台部署。FRP 安装非常容易，只需下载对应系统平台的软件包，并解压就可用。</p>
<p>这里以 Linux 为例，为了方便管理我们把解压后的目录重命名为 frp ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.30.0&#x2F;frp_0.30.0_linux_amd64.tar.gz</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>新篇章，新世界</title>
    <url>/2019/12/23/1.hello-world/</url>
    <content><![CDATA[<p>&emsp;&emsp;我在之前的hexo博客中写了50+篇文章，但质量都不太让我满意，解决问题的效率甚至比不上百度，恰巧之前的文档因操作失误丢失了，于是我就重置了整个博客内容从零开始</p>
<p>&emsp;&emsp;今后的每一篇文章我都会尽心尽力而为，不灌水，如果对文章有问题或者想要交流的小伙伴，可以加我的qq或给我发送邮件进行联系。</p>
<p>&emsp;&emsp;那么，加油！</p>
<p>hexo搭建及相关教程可参考这→ <a href="https://io-oi.me/tech/hexo-next-optimization/" target="_blank" rel="noopener">https://io-oi.me/tech/hexo-next-optimization/</a></p>
]]></content>
      <categories>
        <category>个人感想</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
