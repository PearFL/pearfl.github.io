<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>机器学习之梯度下降法</title>
    <url>/2020/03/17/56.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</url>
    <content><![CDATA[<h1 id="梯度下降法（Gradient-Descent）"><a href="#梯度下降法（Gradient-Descent）" class="headerlink" title="梯度下降法（Gradient Descent）"></a>梯度下降法（Gradient Descent）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>梯度下降法本身不是一个机器学习算法，它是一种基于搜索的最优化方法</p>
<p><strong>作用</strong>：最小化一个损失函数</p>
<p><strong>梯度上升法</strong>：最大化一个效用函数</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>梯度下降法</tag>
      </tags>
  </entry>
  <entry>
    <title>scala隐式转换</title>
    <url>/2020/03/16/%EF%BC%8156.scala%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>参考文档：<a href="https://docs.scala-lang.org/zh-cn/tour/implicit-conversions.html" target="_blank" rel="noopener">https://docs.scala-lang.org/zh-cn/tour/implicit-conversions.html</a></p>
<p>占坑</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>shell基础语法</title>
    <url>/2020/03/16/55.shell%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h1><h2 id="指定脚本要使用的-Shell"><a href="#指定脚本要使用的-Shell" class="headerlink" title="指定脚本要使用的 Shell"></a>指定脚本要使用的 Shell</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>


<p>上面这句代码中， /bin/bash 是 Bash 程序在大多数 Linux 系统中的存放路径，而最前面的 #! 被称作 Sha-bang，或者 Shebang。</p>
<blockquote>
<p>在计算机科学中，Shebang（也称为 Hashbang ）是一个由井号和叹号构成的字符串 <code>#!</code> ，其出现在文本文档的第一行的前两个字符。<br>在文档中存在 Shebang 的情况下，类 Unix 操作系统的进程载入器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文档路径作为该解释器的参数。</p>
</blockquote>
<a id="more"></a>

<h2 id="给脚本文件添加可执行的权限"><a href="#给脚本文件添加可执行的权限" class="headerlink" title="给脚本文件添加可执行的权限"></a>给脚本文件添加可执行的权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x test.sh</span><br></pre></td></tr></table></figure>



<h2 id="以调试模式运行"><a href="#以调试模式运行" class="headerlink" title="以调试模式运行"></a>以调试模式运行</h2><p>随着我们渐渐深入 Shell 编程，你也许会写出很长的 Shell 脚本，代码一多很可能就会有 Bug。</p>
<p>因此，我们需要学习如何调试一个脚本程序。用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -x test.sh</span><br></pre></td></tr></table></figure>

<p>我们直接调用 Bash 这个 Shell 程序，并且给它一个参数 -x （表示以调试模式运行），后面再跟上要调试运行的脚本文件。</p>
<h1 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h1><p><strong>定义变量的时候=左右不要加空格！</strong></p>
<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>我们可以用引号来界定包含空格的字符串。</p>
<p>引号一共有三种：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">表示</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单引号</td>
<td align="left">’</td>
</tr>
<tr>
<td align="left">双引号</td>
<td align="left">“</td>
</tr>
<tr>
<td align="left">反引号</td>
<td align="left">`</td>
</tr>
</tbody></table>
<p>根据引号类型不同，Bash 的处理方式也会不同。</p>
<h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><p>我们从单引号开始学习吧。美式键盘中，单引号( ’ ) 位于 Enter 键（回车键）的左方。</p>
<p>之前的例子里，我们也已经使用过单引号了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">message&#x3D;&#39;Hello World&#39;</span><br><span class="line">echo &#39;The message is $message&#39;</span><br></pre></td></tr></table></figure>

<p>正如之前我们测试的一样，如果变量被包含在单引号里面，那么变量不会被解析，美元符号（ $ ）保持原样输出。</p>
<p>显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The message is $message</span><br></pre></td></tr></table></figure>

<p>因为：单引号忽略被它括起来的所有特殊字符。</p>
<h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><p>一般来说，要输入双引号，需要用 “Shift键 + 单引号的按键”。</p>
<p>不同于单引号忽略所有特殊字符，双引号忽略大多数特殊字符，但不包括：美元符号（ $ ）、反引号（ ` ）、反斜杠（ \ ），这 3 种特殊字符将不被忽略。 不忽略美元符号意味着 Shell 在双引号内部可进行变量名替换。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">message&#x3D;&#39;Hello World&#39;</span><br><span class="line">echo &quot;The message is $message&quot;</span><br></pre></td></tr></table></figure>

<p>执行以上脚本，显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The message is Hello World</span><br></pre></td></tr></table></figure>

<h3 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h3><p>反引号 ( ` ) 不太常用，位于键盘的 Tab 键的上方、数字键 1 的左方。</p>
<p>反引号要求 Shell 执行被它括起来的内容。 什么意思呢？我们来看一个例子你就懂了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">message&#x3D;&#96;pwd&#96;</span><br><span class="line">echo &quot;You are in the directory $message&quot;</span><br></pre></td></tr></table></figure>

<p>运行这个脚本，显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You are in the directory &#x2F;home&#x2F;pearfl</span><br></pre></td></tr></table></figure>



<h2 id="read-请求输入"><a href="#read-请求输入" class="headerlink" title="read : 请求输入"></a>read : 请求输入</h2><h3 id="p-：显示提示信息"><a href="#p-：显示提示信息" class="headerlink" title="-p ：显示提示信息"></a>-p ：显示提示信息</h3><p>目前来说，read 命令提供了 -p 参数，p 是 prompt 的首字母，表示“提示”。</p>
<h3 id="n-：限制字符数目"><a href="#n-：限制字符数目" class="headerlink" title="-n ：限制字符数目"></a>-n ：限制字符数目</h3><p>用 -n 参数，我们可以限制用户输入的字符串的最大长度（字符数）。n 是 number 的首字母，是英语“数目”的意思。</p>
<h3 id="t-：限制输入时间"><a href="#t-：限制输入时间" class="headerlink" title="-t ：限制输入时间"></a>-t ：限制输入时间</h3><p>用 -t 参数，我们可以限定用户的输入时间（以秒为单位），也就是说超过这个时间，就不读取输入了。t 是 time 的首字母，是英语“时间”的意思。</p>
<h4 id="s-：隐藏输入内容"><a href="#s-：隐藏输入内容" class="headerlink" title="-s ：隐藏输入内容"></a>-s ：隐藏输入内容</h4><p>用 -s 参数，我们可以隐藏输入内容。一般用不到，但是如果你想要用户输入的是一个密码，那 -s 参数还是有用的。</p>
<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p><strong>在 Bash 中，所有的变量都是字符串</strong></p>
<p><strong>let 命令可以用于赋值</strong></p>
<p>可用的运算符是以下几种：</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">符号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">加法</td>
<td align="left">+</td>
</tr>
<tr>
<td align="left">减法</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">乘法</td>
<td align="left">*</td>
</tr>
<tr>
<td align="left">除法</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">幂（乘方）</td>
<td align="left">**</td>
</tr>
<tr>
<td align="left">余（整数除法的余数）</td>
<td align="left">%</td>
</tr>
</tbody></table>
<p><strong>如果你要做带小数的运算，那么需要用到 bc 命令</strong></p>
<h2 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h2><p>假设，我们可以这样调用我们的脚本文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;variable.sh 参数1 参数2 参数3 ...</span><br></pre></td></tr></table></figure>

<p>这些个 参数1，参数2，参数3 … 被称为“参数变量”。</p>
<p>但问题是我们还不知道如何接收这些参数到我们的脚本中。</p>
<blockquote>
<p>其实不难，因为这些变量是被自动创建的。</p>
</blockquote>
<ul>
<li><code>$#</code> ：包含参数的数目。</li>
<li><code>$0</code> ：包含被运行的脚本的名称 （我们的示例中就是 variable.sh ）。</li>
<li><code>$1</code>：包含第一个参数。</li>
<li><code>$2</code>：包含第二个参数。<br>…</li>
<li><code>$8</code> ：包含第八个参数。<br>…<br>以此类推。</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array&#x3D;(&#39;value0&#39; &#39;value1&#39; &#39;value2&#39;)</span><br></pre></td></tr></table></figure>

<p>上面的语句定义了一个数组变量，名叫 array（array 是英语“数组”的意思），其中包含三个值：value0，value1，value2。</p>
<p>如果要访问其中一个格子的内容，要用到这样的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;array[2]&#125;</span><br></pre></td></tr></table></figure>

<p>以上语句表示数组中编号为 2 的元素（在我们的情况就是 value2 ）。</p>
<blockquote>
<p>注意：和大多数编程语言一样，Shell 中的数组的下标（index）也基本是从 0 开始的，而不是从 1 开始。因此，第一个元素的编号（下标）就是 0，第二个元素的下标就是 1，以此类推。<br>不过，也不是所有 Shell 语言的数组下标都是从 0 开始，不少 Shell 语言（例如 Csh，Tcsh，Zsh，等等）的数组下标是从 1 开始的。</p>
</blockquote>
<h1 id="判断条件"><a href="#判断条件" class="headerlink" title="判断条件"></a>判断条件</h1><h2 id="if-最简单的条件"><a href="#if-最简单的条件" class="headerlink" title="if : 最简单的条件"></a>if : 最简单的条件</h2><p>if 条件语句的基本格式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ 条件测试 ]</span><br><span class="line">then </span><br><span class="line">    做这个</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>fi 是 if 的反转写法，表示“if 语句结束”。then 是英语“那么”的意思。</p>
<p>“做这个”只有在“条件测试”为真时，才会被执行。</p>
<blockquote>
<p>注意：方括号 <code>[]</code> 中的 <code>条件测试</code> 两边必须要空一格。不能写成 <code>[test]</code>，而要写成 <code>[ test ]</code>。</p>
</blockquote>
<p>当然了，if 语句的基本写法还有一种，那就是把 then 写在 <code>if [ 条件测试 ]</code> 后面，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ 条件测试 ]; then</span><br><span class="line">    做这个</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用这种写法时，在 if 条件判断和 then 之间要加一个分号。</p>
</blockquote>
<p><strong>需要注意在 Shell 语言中，“等于”是用一个等号（ = ）来表示的，这和大多数主流编程语言不同。</strong></p>
<h3 id="else-否则"><a href="#else-否则" class="headerlink" title="else : 否则"></a>else : 否则</h3><p>既然有“如果”的条件判断，那么也会存在条件不成立的时候</p>
<p>if 和 else 两者配合的逻辑是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ 条件测试 ]</span><br><span class="line">then</span><br><span class="line">    做这个</span><br><span class="line">else</span><br><span class="line">    做那个</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>也就是：如果“条件测试”为真，那么“做这个”被执行；否则，“做那个”被执行。</p>
<h3 id="elif-否则，如果"><a href="#elif-否则，如果" class="headerlink" title="elif : 否则，如果"></a>elif : 否则，如果</h3><p>一般来说 if 和 else 已经能满足我们的大部分条件判断需要了，但有些时候，存在好几种情况。</p>
<p>光是 if 和 else 表示的两种对立的情况已经不足以满意要求了，因此我们再来一个关键字：elif 。</p>
<p>elif 是 else if 的缩写，表示“否则 - 如果”。</p>
<p>if， elif 和 else 三者配合的逻辑是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ 条件测试 1 ]</span><br><span class="line">then</span><br><span class="line">    做事情 1</span><br><span class="line">elif [ 条件测试 2 ]</span><br><span class="line">then</span><br><span class="line">    做事情 2</span><br><span class="line">elif [ 条件测试 3 ]</span><br><span class="line">then</span><br><span class="line">    做事情 3</span><br><span class="line">else</span><br><span class="line">    做其他事情</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="不同的测试类型"><a href="#不同的测试类型" class="headerlink" title="不同的测试类型"></a>不同的测试类型</h2><p>在 Bash 中我们可以做三种测试：</p>
<ul>
<li>测试字符串</li>
<li>测试数字</li>
<li>测试文件</li>
</ul>
<h4 id="测试字符串"><a href="#测试字符串" class="headerlink" title="测试字符串"></a>测试字符串</h4><p>我们之前的课程已经说过：在 Shell 中，所有的变量都是字符串。</p>
<p>因此，要做字符串的测试非常简单。记住以下表格：</p>
<table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$string1 = $string2</td>
<td align="left">两个字符串是否相等。Shell 大小写敏感，因此 A 和 a 是不一样的。</td>
</tr>
<tr>
<td align="left">$string1 != $string2</td>
<td align="left">两个字符串是否不同。</td>
</tr>
<tr>
<td align="left">-z $string</td>
<td align="left">字符串 string 是否为空。z 是 zero 的首字母，是英语“零”的意思。</td>
</tr>
<tr>
<td align="left">-n $string</td>
<td align="left">字符串 string 是否不为空。n 是英语 not 的首字母，是英语“不”的意思。</td>
</tr>
</tbody></table>
<h3 id="测试数字"><a href="#测试数字" class="headerlink" title="测试数字"></a>测试数字</h3><p>尽管 Shell 把所有变量都看成字符串，但是我们还是可以做数字的条件测试。记住以下表格：</p>
<table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$num1 -eq $num2</td>
<td align="left">两个数字是否相等。和判断字符串所用的符号（ = ）不一样。eq 是 equal 的缩写，是英语“等于”的意思。</td>
</tr>
<tr>
<td align="left">$num1 -ne $num2</td>
<td align="left">两个数字是否不同。ne 是 not equal 的缩写，是英语“不等于”的意思。</td>
</tr>
<tr>
<td align="left">$num1 -lt $num2</td>
<td align="left">数字 num1 是否小于 num2。lt 是 lower than 的缩写，是英语“小于”的意思。</td>
</tr>
<tr>
<td align="left">$num1 -le $num2</td>
<td align="left">数字 num1 是否小于或等于 num2。le 是 lower or equal 的缩写，是英语“小于或等于”的意思。</td>
</tr>
<tr>
<td align="left">$num1 -gt $num2</td>
<td align="left">数字 num1 是否大于 num2。gt 是 greater than 的缩写，是英语“大于”的意思。</td>
</tr>
<tr>
<td align="left">$num1 -ge $num2</td>
<td align="left">数字 num1 是否大于或等于 num2。ge 是 greater or equal 的缩写，是英语“大于或等于”的意思。</td>
</tr>
</tbody></table>
<h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><p>相比于主流编程语言，Shell 的一大优势就是可以非常方便地测试文件：文件存在吗？我们可以写入文件吗？这个文件比那个文件修改时间更早还是更晚？等等。</p>
<p>下表非常丰富：</p>
<table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-e $file</td>
<td align="left">文件是否存在。e 是 exist 的首字母，表示“存在”。</td>
</tr>
<tr>
<td align="left">-d $file</td>
<td align="left">文件是否是一个目录。因为 Linux 中一切都是文件，目录也是文件的一种。d 是 directory 的首字母，表示“目录”。</td>
</tr>
<tr>
<td align="left">-f $file</td>
<td align="left">文件是否是一个文件。f 是 file 的首字母，表示“文件”。</td>
</tr>
<tr>
<td align="left">-L $file</td>
<td align="left">文件是否是一个符号链接文件。L 是 link 的首字母，表示“链接”。</td>
</tr>
<tr>
<td align="left">-r $file</td>
<td align="left">文件是否可读。r 是 readable 的首字母，表示“可读的”。</td>
</tr>
<tr>
<td align="left">-w $file</td>
<td align="left">文件是否可写。w 是 writable 的首字母，表示“可写的”。</td>
</tr>
<tr>
<td align="left">-x $file</td>
<td align="left">文件是否可执行。x 是 executable 的首字母，表示“可执行的”。</td>
</tr>
<tr>
<td align="left">$file1 -nt $file2</td>
<td align="left">文件 file1 是否比 file2 更新。nt 是 newer than 的缩写，表示“更新的”。</td>
</tr>
<tr>
<td align="left">$file1 -ot $file2</td>
<td align="left">文件 file1 是否比 file2 更旧。ot 是 older than 的缩写，表示“更旧的”。</td>
</tr>
</tbody></table>
<h3 id="一次测试多个条件"><a href="#一次测试多个条件" class="headerlink" title="一次测试多个条件"></a>一次测试多个条件</h3><p>在一个条件测试中，我们可以同时测试多个条件。需要用到两种符号：</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">两个 &amp;。表示“逻辑与”。此符号两端的条件必须全为真，整个条件测试才为真；只要有一个不为真，整个条件测试为假。</td>
</tr>
<tr>
<td align="left">II</td>
<td align="left">两个竖线。表示“逻辑或”。此符号两端的条件只要有一个为真，整个条件测试就为真；只有两个都为假，整个条件测试才为假。</td>
</tr>
</tbody></table>
<h3 id="反转测试"><a href="#反转测试" class="headerlink" title="反转测试"></a>反转测试</h3><p>我们可以用“否定”来反转测试条件，要用到感叹号（ <code>!</code> ）。</p>
<h2 id="case-测试多个条件"><a href="#case-测试多个条件" class="headerlink" title="case : 测试多个条件"></a>case : 测试多个条件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">    &quot;Matthew&quot;)</span><br><span class="line">        echo &quot;Hello Matthew !&quot;</span><br><span class="line">        ;;</span><br><span class="line">    &quot;Mark&quot;)</span><br><span class="line">        echo &quot;Hello Mark !&quot;</span><br><span class="line">        ;;</span><br><span class="line">    &quot;Luke&quot;)</span><br><span class="line">        echo &quot;Hello Luke !&quot;</span><br><span class="line">        ;;</span><br><span class="line">    &quot;John&quot;)</span><br><span class="line">        echo &quot;Hello John !&quot;</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;Sorry, I do not know you.&quot;</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>来分析一下上面的程序，因为有很多新的内容：</p>
<ul>
<li><code>case $1 in</code> ：<code>$1</code> 表示我们要测试的变量是输入的第一个参数。in 是英语“在…之中”的意思。</li>
<li><code>&quot;Matthew&quot;)</code> ：测试其中一个 case，也就是 <code>$1</code> 是否等于 <code>&quot;Matthew&quot;</code>。当然，我们也可以用星号来做通配符来匹配多个字符，例如 <code>&quot;M*&quot;)</code> 可以匹配所有以 M 开头的字符串。</li>
<li><code>;;</code> ：类似于主流编程语言中的 <code>break;</code>，表示结束 case 的读取，程序跳转到 esac 后面执行。</li>
<li><code>*)</code> ：相当于 if 条件语句的 else，表示“否则”，就是“假如不等于上面任何一种情况”。</li>
<li><code>esac</code> ：是 case 的反写，表示 case 语句的结束。</li>
</ul>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>Shell 中，主要的循环语句有三种：</p>
<ul>
<li>while 循环</li>
<li>until 循环</li>
<li>for 循环</li>
</ul>
<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>在 Shell 中，我们最常用的循环是 while 循环。</p>
<p>while 循环的逻辑是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while [ 条件测试 ]</span><br><span class="line">do</span><br><span class="line">    做某些事</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>当然了，我们也可以像在 if 语句中那样，把关键字 do 放到与条件测试同一行上，但是之间要加分号，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while [ 条件测试 ]; do</span><br><span class="line">    做某些事</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h2 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h2><p>与 while 这个关键字相反的有一个 until 关键字，until 在英语中是“到…为止，直到…时”的意思。</p>
<p>把while改成until就一样了</p>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><p>for 循环可以遍历一个“取值列表”，基本的逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for 变量 in &#39;值1&#39; &#39;值2&#39; &#39;值3&#39; ... &#39;值n&#39;</span><br><span class="line">do</span><br><span class="line">    做某些事</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="更常规的-for-循环"><a href="#更常规的-for-循环" class="headerlink" title="更常规的 for 循环"></a>更常规的 for 循环</h3><p>刚才我们看到的 for 循环，和主流编程语言中的语法略有不同，不过我们可以借助 seq 命令，来实现类似主流编程语言中的 for 循环的语法。</p>
<p>seq 是 sequence 的缩写，是英语“序列”的意思。</p>
<p>来写一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">for i in &#96;seq 1 10&#96;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>定义（或创建） Shell 函数是非常容易的。有两种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数名 () &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function 函数名 &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这两种方式都是可行的。看你个人喜好用哪一种方式。</p>
</li>
<li><p>函数名后面跟着的圆括号里不加任何参数：这一点与主流编程语言很不相同。C 语言，Java，C++ 等语言中，函数的圆括号中是可以放置参数的（也就是函数的一部分输入），但是 <strong>Shell 中的函数的圆括号里不能放置参数</strong>。</p>
</li>
<li><p>函数的完整定义必须置于函数的调用之前。</p>
</li>
</ul>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>在 Shell 函数中，我们给它传递参数的方式其实很像给 Shell 脚本传递命令行参数。我们把参数直接置于函数名字后面，然后就像我们之前 Shell 脚本的参数那样：<code>$1</code>，<code>$2</code>，<code>$3</code>等等</p>
<p>我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">print_something () &#123;</span><br><span class="line">    echo Hello $1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_something Matthew</span><br><span class="line">print_something Mark</span><br><span class="line">print_something Luke</span><br><span class="line">print_something John</span><br></pre></td></tr></table></figure>



<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>Shell 的函数却没办法做到。但是 Shell 的函数可以返回一个状态，有点类似一个程序或命令退出时会有一个退出状态，表明是否成功。</p>
<p>Shell 函数要返回状态，也用 return 这个关键字（ return 是英语“返回”的意思）。</p>
<p>一般来说，返回状态 0 表示一切顺利；一个非零值表示有错误。</p>
<p><strong>值得一提的是exit和return有很多有意思的相同点，但exit是系统级的比return更强大，return仅在函数中使用,exit可以在任何地方使用，有兴趣的可以了解其中的区别</strong></p>
<h2 id="变量作用范围"><a href="#变量作用范围" class="headerlink" title="变量作用范围"></a>变量作用范围</h2><p>变量的作用范围意味着一个 Shell 脚本的哪些部分可以访问到这个变量。</p>
<p>默认来说，一个变量是“全局的”（global），意味着在脚本的任何地方都可以访问它。</p>
<p>我们也可以创建局部（local）变量。当我们在函数中创建局部变量时，这个变量就只能在这个函数中被访问。</p>
<p>要定义一个局部变量，我们只要在第一次给这个变量赋值时在变量名前加上关键字 local 即可（ local 是英语“本地的”的意思）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">local_global () &#123;</span><br><span class="line">    local var1&#x3D;&#39;local 1&#39;</span><br><span class="line">    echo Inside function: var1 is $var1 : var2 is $var2</span><br><span class="line">    var1&#x3D;&#39;changed again&#39;   # 这里的 var1 是函数中定义的局部变量</span><br><span class="line">    var2&#x3D;&#39;2 changed again&#39; # 这里的 var2 是函数外定义的全局变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义局部变量有一个好处，就是可以防止被脚本的其它地方的代码意外改变数值。</p>
<blockquote>
<p>在函数中，尽量用局部变量。只有实在不行才用全局变量，毕竟全局变量不太安全。</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Maven新建工程卡顿问题</title>
    <url>/2020/03/14/54.%E8%A7%A3%E5%86%B3Maven%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>通过链接<a href="https://repo.maven.apache.org/maven2/archetype-catalog.xml下载" target="_blank" rel="noopener">https://repo.maven.apache.org/maven2/archetype-catalog.xml下载</a></p>
<p>拷贝到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F:\software\maven_repository\</span><br></pre></td></tr></table></figure>

<p>如果你没有修改默认路径的话，应该是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\.m2\repository\org\apache\maven\archetype\archetype-catalog\3.1.2</span><br></pre></td></tr></table></figure>

<p>IDEA创建的时候添加参数命令<strong>archetypeCatalog=local</strong></p>
<p>或者命令行然后在执行的命令后面加上增加参数<strong>-DarchetypeCatalog=local</strong>，变成读取本地文件即可。</p>
<p>不想这么麻烦直接弄阿里云镜像也可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">     &lt;id&gt;alimaven&lt;&#x2F;id&gt;</span><br><span class="line">     &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">     &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;</span><br><span class="line">     &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;central&lt;&#x2F;url&gt;</span><br><span class="line">   &lt;&#x2F;mirror&gt;</span><br></pre></td></tr></table></figure>





<a id="more"></a>

<p>私用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\Programme\apache\apache-maven-3.6.3</span><br><span class="line"></span><br><span class="line">D:\Programme\apache\apache-maven-3.6.3\conf\settings.xml</span><br><span class="line"></span><br><span class="line">archetypeCatalog&#x3D;local</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>生产必知</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx安装</title>
    <url>/2020/03/13/53.Nginx%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>依赖安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake wget http-tools vim</span><br></pre></td></tr></table></figure>

<p>Nginx官网：<a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a></p>
<p>本文版本选择Stable version中的1.16.1版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.1.tar.gz</span><br><span class="line">tar -zxvf nginx-1.16.1.tar.gz -C ~&#x2F;app&#x2F;</span><br><span class="line">cd ~&#x2F;app&#x2F;nginx-1.16.1</span><br><span class="line"></span><br><span class="line">.&#x2F;configure  --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx  --sbin-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx --conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log  --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  --pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid --lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx.lock  --user&#x3D;nginx --group&#x3D;nginx --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --http-client-body-temp-path&#x3D;&#x2F;var&#x2F;tmp&#x2F;nginx&#x2F;client&#x2F; --http-proxy-temp-path&#x3D;&#x2F;var&#x2F;tmp&#x2F;nginx&#x2F;proxy&#x2F; --http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;tmp&#x2F;nginx&#x2F;fcgi&#x2F; --http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;tmp&#x2F;nginx&#x2F;uwsgi --http-scgi-temp-path&#x3D;&#x2F;var&#x2F;tmp&#x2F;nginx&#x2F;scgi --with-pcre</span><br><span class="line"></span><br><span class="line">useradd -s &#x2F;sbin&#x2F;nologin -M nginx</span><br><span class="line">mkdir -p &#x2F;var&#x2F;tmp&#x2F;nginx&#x2F;client&#x2F;</span><br><span class="line"></span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure>



<p>查找nginx安装地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure>

<p>结果：/usr/local/nginx</p>
<h2 id="Nginx常用操作"><a href="#Nginx常用操作" class="headerlink" title="Nginx常用操作"></a>Nginx常用操作</h2><p>启动、停止nginx</p>
<p>cd /usr/local/nginx/sbin/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx 	#启动</span><br><span class="line">.&#x2F;nginx -s stop		#停止</span><br><span class="line">.&#x2F;nginx -s quit		#退出</span><br><span class="line">.&#x2F;nginx -s reload	#重新加载配置文件</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda基础操作</title>
    <url>/2020/03/10/52.Anaconda%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>1.添加清华仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>



<p>2.升级当前版本的conda</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure>



<p>3.创建并激活一个环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create --name snowflake</span><br><span class="line"></span><br><span class="line">Linux，OS X: source activate snowflakes</span><br><span class="line">Windows：activate snowflake&#96;</span><br></pre></td></tr></table></figure>



<p>4.切换到另一个环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux，OS X: source activate snowflakes</span><br><span class="line">Windows：activate snowflakes</span><br><span class="line"></span><br><span class="line">Linux，OS X: source deactivate</span><br><span class="line">Windows: deactivate</span><br></pre></td></tr></table></figure>



<p>5.删除环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove -n flowers --all</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>流与输出重定向</title>
    <url>/2020/03/10/51.%E6%B5%81%E4%B8%8E%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<p>流就是读一点数据, 处理一点点数据</p>
<p>重定向，是什么意思呢？简单来说，就是我们可以把本来要显示在终端的命令结果，输送到别的地方：到文件中或者作为其他命令的输入（命令的链接，或者叫命令管道）。</p>
<ul>
<li>&gt; ：重定向到文件中。如果文件已存在，则覆盖文件内容；文件不存在，则创建文件。</li>
<li>&gt;&gt; ：重定向到文件末尾。如果文件不存在，则创建文件。</li>
</ul>
<p>&gt; 和 &gt;&gt; 符号只是将标准输出重定向到文件，并不能将标准错误输出重定向到文件。</p>
<p>那么我们要重定向标准错误输出，该怎么办呢？</p>
<p>我们就要用到 2&gt; 这个符号。是的，就是在 &gt; 这个符号左边紧挨着写一个 2。</p>
<p>为什么是 2 呢？标准错误输出的文件描述符是 2，所以这里的 2 表示标准错误输出。如果没有 2，单独的 &gt; 符号就是重定向标准输出（文件描述符为 1）。</p>
<p>我们补充一下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat not_exist_file.csv &gt; results.txt 2&gt; errors.log</span><br></pre></td></tr></table></figure>

<p>这个命令里有两个重定向：</p>
<ul>
<li>&gt; results.txt ：将标准输出重定向到 results.txt 文件中；</li>
<li>2&gt; errors.log ：将标准错误输出重定向到 errors.log 文件中。</li>
</ul>
<p>也就是说：</p>
<ul>
<li>假如 not_exist_file.csv 这个文件确实存在，将其内容写入 results.txt 文件中。</li>
<li>假如 not_exist_file.csv 这个文件不存在，将错误信息写入 errors.log 文件中。</li>
</ul>
<h4 id="合并输出"><a href="#合并输出" class="headerlink" title="合并输出"></a>合并输出</h4><p>上面我们学习了如何将标准输出和标准错误输出分别重定向到不同文件。但是有的时候，我们比较“任性”，就想把标准输出和标准错误输出都重定向到同一个地方。怎么做呢？</p>
<p>须要使用 2&gt;&amp;1 这个组合符号。</p>
<p>看着怪怪的对吧？仅由四个字符组成。这个符号的作用是：将标准错误输出重定向到与标准输出相同的地方。</p>
<p>我们用实例演示一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat not_exist_file.csv &gt; results.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>上面的命令的作用是：将 <code>cat not_exist_file.csv</code> 这个命令的所有输出（标准输出和标准错误输出）都重定向到 results.txt 文件中。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>2&gt; ：将标准错误输出重定向到文件。如果文件已经存在，则覆盖文件内容；如果不存在，则创建文件。</li>
<li>2&gt;&gt; ：将标准错误输出重定向到文件末尾。如果文件不存在，则创建文件。</li>
<li>2&gt;&amp;1 ：将标准输出和标准错误输出重定向到同一个地方。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title>nohup与前台后台操作</title>
    <url>/2020/03/10/50.nohup%E4%B8%8E%E5%89%8D%E5%8F%B0%E5%90%8E%E5%8F%B0%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="1-amp-符号和-nohup-命令：后台运行进程"><a href="#1-amp-符号和-nohup-命令：后台运行进程" class="headerlink" title="1. &amp; 符号和 nohup 命令：后台运行进程"></a>1. &amp; 符号和 nohup 命令：后台运行进程</h2><p>我们到目前为止用终端做的事情都是目所能及的，也就是说：我们运行的命令都是在前台可见的。</p>
<p>这样的一个好处是我们可以看到命令运行的过程，有什么问题可以及时发现。但是也有缺陷，例如有的命令运行耗时良久，我们又不想无所事事，怎么办呢？难道我开一个终端专门执行一个耗时命令，然后为了能做其他事情，我再启动一个终端，那也很不方便。</p>
<p>事实上，我们可以在同一个终端中同时运行好几个命令。怎么做呢？就需要用到后台进程的概念。</p>
<a id="more"></a>

<h4 id="前台进程和后台进程"><a href="#前台进程和后台进程" class="headerlink" title="前台进程和后台进程"></a>前台进程和后台进程</h4><p>默认情况下，用户创建的进程都是前台进程。前台进程从键盘读取数据，并把处理结果输出到显示器。</p>
<p>我们可以看到前台进程的运行过程。例如，使用 ls 命令来遍历当前目录下的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>这个程序就运行在前台，它会直接把结果输出到显示器。如果 ls 命令需要数据（实际上不需要），那么它会等待用户从键盘输入。</p>
<p>当程序运行在前台时，由于命令提示符（$）还未出现，用户不能输入其他命令；即使程序需要运行很长时间，也必须等待程序运行结束才能输入其他命令。</p>
<p>后台进程与键盘没有必然的关系。当然，后台进程也可能会等待键盘输入。</p>
<p>后台进程的优点是不必等待程序运行结束就可以输入其他命令。</p>
<p>那么怎么使一个进程（程序的实例）运行在后台呢？</p>
<h4 id="amp-符号：在后台运行进程"><a href="#amp-符号：在后台运行进程" class="headerlink" title="&amp; 符号：在后台运行进程"></a>&amp; 符号：在后台运行进程</h4><p>前面说过，让一个进程在后台运行有几种方法。</p>
<p>我们带大家来学习第一种，很简单：就是在你要运行的命令最后加上 &amp; 这个符号。</p>
<p>我们可以用熟悉的 cp 命令做例子。例如，我运行 cp 命令来拷贝文件：emacs 的软件包。当然了，你可以用其他文件来测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp emacs-26.2.tar.gz emacs-26.2-copy.tar.gz &amp;</span><br></pre></td></tr></table></figure>

<p>命令最后加了 &amp; 符号，运行时此进程就成为了后台进程。终端输出了一些信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1] 2051</span><br></pre></td></tr></table></figure>

<ul>
<li><p>[1] ：这是此终端的后台进程的标号。因为这是第一个后台进程，所以标号为 1。</p>
</li>
<li><p>2051 ：这是进程号（PID），如果你想要结束这个后台进程，你可以用 kill 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill 2051</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>我们虽然看不到这个拷贝进程的“所作所为”，但它确实在后台默默进行着文件的拷贝。</p>
<p>可以看到，终端显示了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1]+  Done    cp emacs-26.2.tar.gz emacs-26.2-copy.tar.gz</span><br></pre></td></tr></table></figure>

<p>Done 是英语“完成的”的意思，表示这个后台进程的任务已经完成了。</p>
<h4 id="nohup-命令：使进程与终端分离"><a href="#nohup-命令：使进程与终端分离" class="headerlink" title="nohup 命令：使进程与终端分离"></a>nohup 命令：使进程与终端分离</h4><p>&amp; 符号虽然常用，但却有一个不可忽视的缺点：后台进程与终端相关联。一旦终端关闭或者用户登出，进程就自动结束。</p>
<p>如果我们想让进程在以上情况下仍然继续在后台运行，那么我们须要用到 nohup 命令。</p>
<p>当用户注销（logout）或者网络断开时，终端会收到 HUP（是 hangup 的缩写，英语“挂断”的意思）信号从而关闭其所有子进程；终端被关闭时也会关闭其子进程。</p>
<p>我们可以用 nohup 命令使命令不受 HUP 信号影响。</p>
<p>我们用 man 来看一下 nohup 命令的解释：</p>
<p>nohup 命令的简单描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run a command immune to hangups, with output to a non-tty</span><br></pre></td></tr></table></figure>

<p>翻译出来大致就是：“使得运行的命令不受 hangup 信号影响，而且输出会存放到一个非 tty 中”。</p>
<p>nohup 命令的用法很简单：在 nohup 命令之后接要运行的命令。例如，我们可以用 nohup 配合 cp 命令来实现文件的拷贝（这次拷贝的是 node.js 的源码。当然了，你可以用其他文件来测试）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup cp node-v10.15.3.tar.gz node-v10.15.3-copy.tar.gz</span><br></pre></td></tr></table></figure>

<p>可以看到这次的输出信息是：“ignoring input and appending output to nohup.out”。</p>
<p>大致意思是：“忽略输入，把输出追加到 nohup.out 文件中”。</p>
<p>使用 nohup 命令后，输出会被默认地追加写入到一个叫 nohup.out 的文件里。</p>
<p>现在，我们的进程已经不受终端关闭或者用户断开连接的影响了，会一直运行。当然了，用 kill 命令还是可以结束此进程的。要获知进程号，可以用我们之前学过的 ps 命令配合 grep 来查找。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ax | grep command</span><br></pre></td></tr></table></figure>

<p>上面命令里的 command 指代 nohup 后面跟着的命令。</p>
<p>nohup 命令相当有用。想象以下场景：</p>
<blockquote>
<p>我登录远程服务器，然后运行了一个耗时命令，或者一个需要一直运行的命令，例如一个游戏的服务器程序。这时假如我掉线了，或者我不小心用 exit 命令退出了登录。那么这个耗时命令也会中止运行。那就很麻烦了。而且，如果这个程序本应该一直运行很久的，我也不可能一直保持登录状态等它结束啊。<br>我家里还有老婆孩子呢，不能不去做饭啊，我要下班… 开个小玩笑。</p>
</blockquote>
<p>幸好，nohup 命令解决了这样的难题。</p>
<p>一般我们也会把 nohup 和 &amp; 一起使用，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup cp node-v10.15.3.tar.gz node-v10.15.3-copy.tar.gz &amp;</span><br></pre></td></tr></table></figure>

<h2 id="2-Ctrl-Z，jobs，bg-和-fg-命令：控制进程的前后台切换"><a href="#2-Ctrl-Z，jobs，bg-和-fg-命令：控制进程的前后台切换" class="headerlink" title="2. Ctrl + Z，jobs，bg 和 fg 命令：控制进程的前后台切换"></a>2. Ctrl + Z，jobs，bg 和 fg 命令：控制进程的前后台切换</h2><p>我们来考虑一种情况：假如你要将进程转到后台运行，但是执行命令时忘记了在最后加上 &amp; 符号。</p>
<p>如何再使此进程转为后台进程呢？有几种方法。我们一一来学习。</p>
<h4 id="Ctrl-Z：转到后台，并暂停运行"><a href="#Ctrl-Z：转到后台，并暂停运行" class="headerlink" title="Ctrl + Z：转到后台，并暂停运行"></a>Ctrl + Z：转到后台，并暂停运行</h4><p>我们用 top 命令来演示。运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>

<p>因为 top 命令的作用是实时地显示各种系统信息和进程列表。这时，我们按下 Ctrl + Z 这个组合键</p>
<p>可以看到终端显示了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1]+ Stopped top</span><br></pre></td></tr></table></figure>

<p>这行信息。</p>
<p>stopped 是英语“停止的”的意思，我们又看到 [1] 这个熟悉的信息，表示这是此终端第一个后台进程。</p>
<p>所以表示 top 命令被放到了后台，此进程还是驻留在内存中，但是被暂停运行了。这个时候命令提示符又出现了，我们可以做其他事情了。</p>
<h4 id="bg-命令：使进程转到后台"><a href="#bg-命令：使进程转到后台" class="headerlink" title="bg 命令：使进程转到后台"></a>bg 命令：使进程转到后台</h4><p>经过上面的 Ctrl + Z 操作，我们可怜的 top 进程已经被“打入冷宫”（转入后台，并且被暂停运行了）。</p>
<blockquote>
<p>但是皇后不甘心啊：“臣妾虽然做不到，但即使在冷宫中，我也要工于心计、运筹帷幄，以期早日打败甄嬛。”</p>
</blockquote>
<p>那怎么办呢？可以运行 bg 命令。</p>
<p>就是很简单地输入 bg，然后回车。bg 是英语 background 的缩写，表示“后台”。</p>
<p>bg 命令的作用是将命令转入后台运行。假如命令已经在后台，并且暂停着，那么 bg 命令会将其状态改为运行。</p>
<p>不加任何参数，bg 命令会默认作用于最近的一个后台进程，也就是刚才被 Ctrl + Z 暂停的 top 进程。如果后面加 %1，%2 这样的参数（不带 %，直接 1，2 这样也可以），则是作用于指定标号的进程。因为进程转入后台之后，会显示它在当前终端下的后台进程编号。例如目前 top 进程转入了后台，它的进程编号是 1（可以由 [1]+ 推断）。依次类推，bg %2 就是作用于编号为 2 的后台进程。</p>
<p>补充一些知识：</p>
<blockquote>
<p>Linux 中，进程有 5 种状态：</p>
<ol>
<li>运行 (正在运行或在运行队列中等待)</li>
<li>中断 (休眠中, 受阻, 在等待某个条件的形成或接受到信号)</li>
<li>不可中断 (收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li>
<li>僵死 (进程已终止, 但进程描述符存在, 直到父进程使用 wait4() 系统调用后释放)</li>
<li>停止 (进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行)</li>
</ol>
</blockquote>
<blockquote>
<p>ps 命令标识进程的 5 种状态码如下：</p>
<ol>
<li>D 不可中断 uninterruptible sleep (usually IO)</li>
<li>R 运行 runnable (on run queue)</li>
<li>S 中断 sleeping</li>
<li>T 停止 traced or stopped</li>
<li>Z 僵死 a defunct (“zombie”) process</li>
</ol>
</blockquote>
<h4 id="jobs-命令：显示后台进程状态"><a href="#jobs-命令：显示后台进程状态" class="headerlink" title="jobs 命令：显示后台进程状态"></a>jobs 命令：显示后台进程状态</h4><p>这个命令很强大，毕竟和乔布斯乔老爷子（乔布斯的英文就是 jobs，全名是 Steve Jobs。job 是英语“工作”的意思，jobs 是复数形式）一样名字么。</p>
<p>jobs 命令的作用是显示当前终端里的后台进程状态。虽然我们可以用 ps 命令来查看进程状态，但是 ps 命令输出的进程列表太长了。</p>
<p>jobs 命令的输出共分三列，我们逐列来说明：</p>
<ol>
<li>显示后台进程标号：比如上例中 top 进程的标号是 1，grep 进程的标号是 2，如果还有其他后台进程，那么就会有 [3]，[4]等等。这个标号和 PID（进程号）是不一样的。这个标号只是显示当前终端下的后台进程的一个编号；</li>
<li>显示后台进程状态：比如 Stopped 是“停止的”的意思，Running 是“运行的”的意思。还有其他状态；</li>
<li>命令本身。</li>
</ol>
<h4 id="fg-命令：使进程转到前台"><a href="#fg-命令：使进程转到前台" class="headerlink" title="fg 命令：使进程转到前台"></a>fg 命令：使进程转到前台</h4><p>fg 是英语 foreground 的意思，表示“前台”。</p>
<p>与 bg 命令相反，fg 命令的作用是：使进程转为前台运行。</p>
<p>用法也很简单，和 bg 一样，如果不加参数，那么 fg 命令作用于最近的一个后台进程；如果加参数，如 %2，那么表示作用于本终端中第二个后台进程。</p>
<p><img src="http://img1.sycdn.imooc.com/5d27ed94000124f610581196.png" alt="图片描述"></p>
<p>解释一下上图：</p>
<ol>
<li>如果我们运行一个程序，默认情况下，它会成为一个前台运行的进程。我们可以按组合键 Ctrl + C 来销毁此进程。</li>
<li>我们也可以使此进程在后台运行。假如运行程序时就用 &amp; 放在命令最后，那么进程就会在后台运行。</li>
<li>假如在进程运行起来后，按 Ctrl + Z，则进程会转到后台，并且停止。此时如果运行 bg 命令，则进程重新运行，并继续在后台。</li>
<li>fg 命令可以使进程转到前台，并且运行。</li>
</ol>
<p>花点时间好好理解一下这个状态图。这个图很重要，几乎概括了后台前台进程切换的所有情况。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ol>
<li>我们可以使程序在后台运行，成为后台进程。这样在当前终端中我们就可以做其他事了，而不必等待此进程运行结束。</li>
<li>为了使一个程序在后台运行，可以在命令的最后加上 &amp; 这个符号。但是，如果你关闭终端或退出登录，此后台进程还是会结束。为了将后台进程与本终端分离，可以使用 nohup 命令，使得进程不再受终端关闭或用户登出的影响。</li>
<li>如果你运行了一个前台进程，但是想要将其转为后台运行进程。你可以先用 Ctrl + Z 组合键将其转为后台暂停，然后运行 bg 命令使其在后台重新运行。如果你要将一个后台命令（不管它是后台运行还是后台暂停）重新转为前台运行，只要用 fg 命令就可以了。</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>screen</tag>
        <tag>nohub</tag>
      </tags>
  </entry>
  <entry>
    <title>python虚拟环境</title>
    <url>/2020/03/09/45.python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>Python 3 中自带有虚拟环境模块，通过它即可创建虚拟环境，无需借助其它工具。</p>
<p>创建虚拟环境使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m venv 虚拟环境名称</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m venv venv</span><br></pre></td></tr></table></figure>

<p>此时将在当前目录中创建出 <code>venv</code> 目录，这即是虚拟环境目录，其中包含 Python 运行环境。</p>
<h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><p>要使用虚拟环境首先需要激活它，激活后当前命令行所执行的 Python 代码都将运行于该虚拟环境中。</p>
<p>Windows 操作系统中使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd venv\Scripts</span><br><span class="line">activate.bat</span><br></pre></td></tr></table></figure>

<p>Linux 和 MacOS 中使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source venv/bin/activate</span><br></pre></td></tr></table></figure>

<p>上述命令执行过后，命令行的提示符前将显示 <code>(venv)</code>，如下：</p>
<blockquote>
<p>(venv) ➜</p>
</blockquote>
<p>这表示当前已处于虚拟环境中。此后在该命令行中所执行的所有 Python 代码都运行于该虚拟环境中。</p>
<h3 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h3><p>当我们不要使用虚拟环境时，可以退出当前虚拟环境。</p>
<p>Windows 操作系统中使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd venv\Scripts</span><br><span class="line">deactivate.bat</span><br></pre></td></tr></table></figure>

<p>Linux 和 MacOS 中使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<p>此后命令行的提示符将恢复回原本状态。</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>linux数据处理</title>
    <url>/2020/03/09/35.linux%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ol>
<li>grep 命令：筛选数据</li>
<li>sort 命令：为文件排序</li>
<li>wc 命令：文件的统计</li>
<li>uniq 命令：删除文件中的重复内容</li>
<li>cut 命令：剪切文件的一部分内容</li>
</ol>
<a id="more"></a>



<h2 id="1-grep-命令：筛选数据"><a href="#1-grep-命令：筛选数据" class="headerlink" title="1. grep 命令：筛选数据"></a>1. grep 命令：筛选数据</h2><p>grep 是 Globally search a Regular Expression and Print 的缩写，意思是“全局搜索一个正则表达式，并且打印”。</p>
<p>grep 命令的功能简单说来是在文件中查找关键字，并且显示关键字所在的行。</p>
<p>grep 命令极为强大，也是 Linux 中使用最多的命令之一。它的强大之处在于它不仅可以实现简单的查找，而且可以配合 <a href="http://baike.baidu.com/view/94238.htm" target="_blank" rel="noopener">正则表达式</a> 来实现比较复杂的查找。</p>
<h4 id="grep-的简单用法"><a href="#grep-的简单用法" class="headerlink" title="grep 的简单用法"></a>grep 的简单用法</h4><p>grep 的使用方法有很多种，我们一开始先学习最基本的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep text file</span><br></pre></td></tr></table></figure>

<p>可以看到，上面就是 grep 命令的最基本用法。</p>
<p>text 代表要搜索的文本，file 代表供搜索的文件。</p>
<p>我们用实际的例子来学习：比如我要在用户的家目录的 .bashrc 文件中搜索 alias 这个文本，而且显示所有包含alias的行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep alias .bashrc</span><br></pre></td></tr></table></figure>

<p>如果我们要用 grep 命令在一个文件中查找用空格隔开的文本，那么就要加上双引号，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;Hello World&quot; file2</span><br></pre></td></tr></table></figure>

<p>如果我们要用 grep 命令在一个文件中查找用空格隔开的文本，那么就要加上双引号，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;Hello World&quot; file2</span><br></pre></td></tr></table></figure>



<h4 id="i-参数：忽略大小写"><a href="#i-参数：忽略大小写" class="headerlink" title="-i 参数：忽略大小写"></a>-i 参数：忽略大小写</h4><p>默认的情况下，grep 命令是区分大小写的，也就是说搜索的文本将严格按照大小写来搜索。比如我搜索的文本是 text，那么就不会搜出 Text，tExt，TEXT 等等文本。</p>
<p>但是我们可以给 grep 加上 -i 参数，使得 grep 可以忽略大小写。i 是英语 ignore 的缩写，表示“忽略”。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -i alias .bashrc</span><br></pre></td></tr></table></figure>



<h4 id="n-参数：显示行号"><a href="#n-参数：显示行号" class="headerlink" title="-n 参数：显示行号"></a>-n 参数：显示行号</h4><p>-n 参数的作用很简单，就是显示搜索到的文本所在的行号。n 是英语 number 的缩写，表示“数字，编号”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -n alias .bashrc</span><br></pre></td></tr></table></figure>



<h4 id="v-参数：只显示文本不在的行"><a href="#v-参数：只显示文本不在的行" class="headerlink" title="-v 参数：只显示文本不在的行"></a>-v 参数：只显示文本不在的行</h4><p>-v 参数很有意思，v 是 invert 的缩写，表示“颠倒，倒置”。-v 参数的作用与正常 grep 的作用正好颠倒，就是只显示搜索的文本不在的那些行。</p>
<h4 id="r-参数：在所有子目录和子文件中查找"><a href="#r-参数：在所有子目录和子文件中查找" class="headerlink" title="-r 参数：在所有子目录和子文件中查找"></a>-r 参数：在所有子目录和子文件中查找</h4><p>如果你不知道你要找的文本在哪个文件里，你可以用强大的 -r 参数。</p>
<p>r 是英语 recursive 的缩写，表示“递归”。</p>
<p>如果用了 -r 参数，那么 grep 命令使用时的最后一个参数（grep text file 这个模式中的 file）需要换成 directory，也就是必须是一个目录。因为 -r 参数是让 grep 命令能够在指定目录的所有子目录和子文件中查找文本。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -r &quot;Hello World&quot; folder&#x2F;</span><br></pre></td></tr></table></figure>

<p>表示在 folder 这个目录的所有子目录和子文件中查找 Hello World 这个文本。当然了，以上例子中，folder 后面的斜杠（/）不是必须的，这里只是为了清楚表明 folder 是一个目录。只要 folder 是一个目录，Linux 系统是不会搞错的。</p>
<p>Linux 中还有一个 rgrep 的命令，它的作用相当于 grep -r 。</p>
<h4 id="grep-的高级用法：配合正则表达式"><a href="#grep-的高级用法：配合正则表达式" class="headerlink" title="grep 的高级用法：配合正则表达式"></a>grep 的高级用法：配合正则表达式</h4><p>正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p>
<p>grep 配合正则表达式就可以实现比较高级的搜索了。</p>
<p>我们首先来看一眼以下的这个表格，表格中列出了最常用的一些正则表达式的字符以及其含义：</p>
<table>
<thead>
<tr>
<th align="left">特殊字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.</td>
<td align="left">匹配除 “\n” 之外的任何单个字符</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">行首（匹配输入字符串的开始位置）</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">行尾（匹配输入字符串的结束位置）</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">在中括号中的任意一个字符</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">问号前面的元素出现零次或一次</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">星号前面的元素可能出现零次、一次或多次</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">加号前面的元素必须出现一次以上（包含一次）</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">逻辑或</td>
</tr>
<tr>
<td align="left">()</td>
<td align="left">表达式的分组（表示范围和优先度）</td>
</tr>
</tbody></table>
<p>当然了，上表没有列出所有的正则表达式的字符。</p>
<p>首先，为了让 grep 命令知道我们要使用正则表达式，须要加上 -E 参数（E 是 extended regular expression 的第一个字母，表示“扩展的正则表达式”）。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -E Alias .bashrc</span><br></pre></td></tr></table></figure>

<p>当然了，Linux 也有一个命令 egrep，其效果等同 grep -E 。</p>
<p>到此为止，没什么新鲜的。我们用正则表达式只是和之前的搜索类似。接下来，我们才真的要用到正则表达式的特殊字符了。</p>
<p>首先来看这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -E ^alias .bashrc</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们用到了 ^ 这个特殊符号，上面的表格里对于 ^ 已经做了说明：行首（匹配输入字符串的开始位置）。也就是说，^ 后面的字符须要出现在一行的开始。</p>
<p>再来举几个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -E [Aa]lias .bashrc</span><br></pre></td></tr></table></figure>

<p> [] 的作用，是将 [] 中的字符任取其一，因此 [Aa]lias 的意思就是既可以是 Alias，又可以是 alias。因此 grep 的搜索结果把包含 Alias 和 alias 的行都列出来了。</p>
<p>再比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -E [0-4] .bashrc</span><br></pre></td></tr></table></figure>

<p>用于搜索包含 0 至 4 的任一数字的行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -E [a-zA-Z] .bashrc</span><br></pre></td></tr></table></figure>

<p>用于搜索包含在 a 至 z 之间的任意字母或者 A 至 Z 之间的任意字母的行。</p>
<p>其他正则表达式还有很多例子。就不一一列举了。</p>
<h2 id="2-sort-命令：为文件排序"><a href="#2-sort-命令：为文件排序" class="headerlink" title="2. sort 命令：为文件排序"></a>2. sort 命令：为文件排序</h2><p>我们用 sort 命令来举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort name.txt</span><br></pre></td></tr></table></figure>

<p>sort 命令将 name.txt 文件中的行按照首字母的英文字典顺序进行了排列。</p>
<p>sort 命令并不区分大小写，小写字母开头的 jude 还是排在 John 之后。</p>
<h4 id="o-参数：将排序后的内容写入新文件"><a href="#o-参数：将排序后的内容写入新文件" class="headerlink" title="-o 参数：将排序后的内容写入新文件"></a>-o 参数：将排序后的内容写入新文件</h4><p>如果你打开 name.txt 文件，你会发现，经过了 sort 命令的“洗礼”，name.txt 中的内容还是维持原来的顺序。</p>
<p>单独使用 sort 命令是不会真正改变文件内容的，只是把排序结果显示在终端上。</p>
<p>那我们要存储排序结果到新的文件怎么办呢？可以用 -o 参数。</p>
<p>o 是 output 的首字母，表示“输出”，就是将排序结果输出到文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -o name_sorted.txt name.txt</span><br></pre></td></tr></table></figure>

<p>name.txt 经过 sort 命令排序之后的内容被储存在了新的文件 name_sorted.txt 中，而 name.txt 的内容是不变的。</p>
<h4 id="r-参数：倒序排列"><a href="#r-参数：倒序排列" class="headerlink" title="-r 参数：倒序排列"></a>-r 参数：倒序排列</h4><p>-r 参数中的 r 是 reverse 的缩写，是“相反”的意思，与普通的仅用 sort 命令正好相反。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -r name.txt</span><br></pre></td></tr></table></figure>

<h4 id="R-参数：随机排序"><a href="#R-参数：随机排序" class="headerlink" title="-R 参数：随机排序"></a>-R 参数：随机排序</h4><p>R 是英语 random 的首字母，表示“随机的，任意的”。</p>
<p>-R 参数比较“无厘头”，因为它会让 sort 命令的排序变为随机，就是任意排序，也许每次都不一样。</p>
<p>但在有些时候，-R 参数还是很有用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort -R name.txt</span><br></pre></td></tr></table></figure>

<h4 id="n-参数：对数字排序"><a href="#n-参数：对数字排序" class="headerlink" title="-n 参数：对数字排序"></a>-n 参数：对数字排序</h4><p>对数字的排序有点特殊。默认仅用 sort 命令的时候，是不区分字符是否是数字的，会把这些数字看成字符串，按照 1-9 的顺序来排序。例如 138 会排在 25 前面，因为 1 排在 2 的前面。</p>
<p>那如果我们要 sort 命令识别整个数字，比如按照整个数值的大小顺序来说，25 应该排在 138 前面，那该怎么办呢？</p>
<p>就可以请出我们的 -n 参数了。n 是 number 的缩写。是英语“数字”的意思。-n 参数用于对数字进行排序，按从小到大排序。</p>
<p>为了演示，我们再用文本编辑器来创建一个文件，就叫 number.txt 好了。</p>
<p>里面随便填一些数字，每行一个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">9</span><br><span class="line">216</span><br><span class="line">28</span><br><span class="line">174</span><br><span class="line">35</span><br><span class="line">68</span><br></pre></td></tr></table></figure>

<p>然后用 sort 不加 -n 参数和加上 -n 参数分别测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">174</span><br><span class="line">216</span><br><span class="line">28</span><br><span class="line">35</span><br><span class="line">68</span><br><span class="line">9</span><br><span class="line">---------------------------分割线</span><br><span class="line">9</span><br><span class="line">12</span><br><span class="line">28</span><br><span class="line">35</span><br><span class="line">68</span><br><span class="line">174</span><br><span class="line">216</span><br></pre></td></tr></table></figure>

<p>可以看到，不加 -n 参数时，sort 就会把这些数字看成字符串，按字符依次来排序，按照 1-9 的顺序。</p>
<p>加上 -n 参数，就会把各行的数字看成一个整体，按照大小从小到大来排序了。</p>
<h2 id="3-wc-命令：文件的统计"><a href="#3-wc-命令：文件的统计" class="headerlink" title="3. wc 命令：文件的统计"></a>3. wc 命令：文件的统计</h2><p>wc 是 word count 的缩写</p>
<p>wc 命令看起来是用来统计单词数目的，但其实 wc 的功能不仅止于此。wc 命令还可以用来统计行数，字符数，字节数等。</p>
<p>跟前面的命令一样，wc 命令的用法也是后接文件名。wc 命令很有用，应该会成为你常用的命令之一。</p>
<p>如果不加选项参数，那么 wc 命令的返回值会有些特殊，有点晦涩难懂。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc name.txt</span><br></pre></td></tr></table></figure>

<p>可以看到返回值是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 9 50 name.txt</span><br></pre></td></tr></table></figure>

<p>最后的 name.txt 只是表示文件名，不需考虑。</p>
<p>那么这三个数字：9，9，和 50 分别表示什么呢？</p>
<p>这三个数字，按顺序，分别表示：</p>
<ul>
<li>行数（newline counts）：newline 是英语“换行、换行符”的意思。统计行数其实就是统计换行符的数目。</li>
<li>单词数（word counts）</li>
<li>字节数（byte counts）：byte 是英语“字节”的意思，等于 8 个二进制位（bit）。</li>
</ul>
<p>可以用 man wc 查看 wc 的命令手册得知：</p>
<p>wc 的命令描述是“print newline, word, and byte counts for each file”，翻成中文就是“对每个文件，打印其行数，单词数和字节数”。</p>
<p>因为我们之前创建 name.txt 时，每一行只有一个单词（英语名字），所以这里统计的行数和单词数都是 9。</p>
<p>50 代表字节数。我数了一下，name.txt 里的 9 个英语单词一共包含 41 个英语字母（也就是 41 个英语字符），占用 41 个字节。再加上每行结尾的换行符（Linux 中换行符是 ‘\n’），共有 9 个换行符，占用 9 个字节。41 + 9 = 50，正好是 50 个字节。</p>
<p>我们稍微讲一下字符和字节的一些联系和区别：</p>
<ul>
<li>字节（Byte 或 Octet）是计量单位，表示数据量多少，是计算机存储容量的计量单位。一个字节等于 8 位（Bit，比特位，是计算机最小的存储单位。就是 0 或 1 这样的二进制位）。</li>
<li>字符（Character）是计算机中使用的文字和符号，比如 “a”、“B”、“7”、“&amp;”、“%”等。不同语言有不同的字符，一般我们中国人接触比较多的是英语和中文的字符。</li>
</ul>
<p>字符在不同的编码中所占字节数是不一样的。字符的编码和标准有不少，这里我们就不深入展开了，大家可以看这个链接来深入了解：<a href="https://baike.baidu.com/item/字符集" target="_blank" rel="noopener">字符集</a> 。</p>
<h4 id="l-参数：统计行数"><a href="#l-参数：统计行数" class="headerlink" title="-l 参数：统计行数"></a>-l 参数：统计行数</h4><p>为了只统计行数，我们可以加上 -l 参数。l 是 line 的缩写，表示“行”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc -l name.txt</span><br></pre></td></tr></table></figure>

<h4 id="w-参数：统计单词数"><a href="#w-参数：统计单词数" class="headerlink" title="-w 参数：统计单词数"></a>-w 参数：统计单词数</h4><p>w 是word 的缩写，表示“单词”。因此 -w 参数用于统计单词。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc -w name.txt</span><br></pre></td></tr></table></figure>

<h4 id="c-参数：统计字节数"><a href="#c-参数：统计字节数" class="headerlink" title="-c 参数：统计字节数"></a>-c 参数：统计字节数</h4><p>不知道为什么是 c，因为 byte 或者 octet（都表示“字节”）的首字母都不是 c 啊。也许 c 是 character（英语“字符”的意思）的缩写吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc -c name.txt</span><br></pre></td></tr></table></figure>

<h4 id="m-参数：统计字符数"><a href="#m-参数：统计字符数" class="headerlink" title="-m 参数：统计字符数"></a>-m 参数：统计字符数</h4><p>不知道为什么是 m，因为 character（英语“字符”）的首字母不是 m ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc -m name.txt</span><br></pre></td></tr></table></figure>



<p>为了加深理解，我们来测试一下。创建一个只包含中文字符的文本文件，可以起名叫 chinese.txt（chinese 是“中文”的意思）。在里面写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你好吗</span><br><span class="line">我很好</span><br></pre></td></tr></table></figure>

<p>这 6 个汉字。</p>
<p>我们用 wc 命令来统计一下 chinese.txt 的字节数和字符数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc -c chinese.txt</span><br><span class="line">wc -m chinese.txt</span><br></pre></td></tr></table></figure>

<p>chinese.txt 包含的字节数是 20，字符数是 8</p>
<p>其实这是因为使用的是 Unicode 标准 的 UTF-8 编码方式。中文字符占 3 个字节，一共有 6 个中文字符，6 * 3 = 18，再加上 2 个换行符占 2 个字节，18 + 2 = 20。</p>
<p>字符数则是 6 + 2 = 8 个</p>
<p>我们可以用 file 命令来确定文件的类型，运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file chinese.txt</span><br><span class="line">file name.txt</span><br></pre></td></tr></table></figure>

<p>chinese.txt 的编码是 UTF-8 Unicode，name.txt 的编码是 ASCII</p>
<h2 id="4-uniq-命令：删除文件中的重复内容"><a href="#4-uniq-命令：删除文件中的重复内容" class="headerlink" title="4. uniq 命令：删除文件中的重复内容"></a>4. uniq 命令：删除文件中的重复内容</h2><p>有时候，文件中包含重复的行，我们想要将重复的内容删除，</p>
<p>这时，uniq 命令就显得很有用了。</p>
<p>uniq 是英语 unique 的缩写，表示“独一无二的”。</p>
<p>为了演示，我们创建一个文件 repeat.txt（repeat 是英语“重复”的意思），里面写入如下排序好的内容（因为 uniq 命令有点“呆”，只能将连续的重复行变为一行）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Albert</span><br><span class="line">China</span><br><span class="line">France</span><br><span class="line">France</span><br><span class="line">France</span><br><span class="line">John</span><br><span class="line">Matthew</span><br><span class="line">Matthew</span><br><span class="line">patrick</span><br><span class="line">Steve</span><br><span class="line">Vincent</span><br></pre></td></tr></table></figure>

<p>可以看到，有三个 France 连在一起，两个 Matthew 连在一起。</p>
<p>我们用 uniq 命令来处理看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniq repeat.txt</span><br></pre></td></tr></table></figure>

<p>可以看到，三个连续的 France 只剩下一个了，两个连续的 Matthew 也只剩一个了。</p>
<p>和 sort 命令类似，uniq 命令并不会改变原文件的内容，只会把处理后的内容显示出来。</p>
<p>如果想将处理后的内容储存到一个新文件中，可以使用如下的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniq repeat.txt unique.txt</span><br></pre></td></tr></table></figure>

<h4 id="c-参数：统计重复的行数"><a href="#c-参数：统计重复的行数" class="headerlink" title="-c 参数：统计重复的行数"></a>-c 参数：统计重复的行数</h4><p>-c 参数用于显示重复的行数，如果是独一无二的行，那么数目就是 1。c 是 count 的缩写，表示“统计，计数”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniq -c repeat.txt</span><br></pre></td></tr></table></figure>

<h4 id="d-参数：只显示重复行的值"><a href="#d-参数：只显示重复行的值" class="headerlink" title="-d 参数：只显示重复行的值"></a>-d 参数：只显示重复行的值</h4><p>-d 参数只显示重复的行的值。d 是 duplicated 的缩写，表示“重复的”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniq -d repeat.txt</span><br></pre></td></tr></table></figure>



<h2 id="5-cut-命令：剪切文件的一部分内容"><a href="#5-cut-命令：剪切文件的一部分内容" class="headerlink" title="5. cut 命令：剪切文件的一部分内容"></a>5. cut 命令：剪切文件的一部分内容</h2><p>cut 是英语“剪切”的意思。大家平时肯定有剪切文本内容的经历吧，一般剪切之后还会把剪切的内容粘贴到某处。</p>
<p>cut 命令用于对文件的每一行进行剪切处理。</p>
<h4 id="c-参数：根据字符数来剪切"><a href="#c-参数：根据字符数来剪切" class="headerlink" title="-c 参数：根据字符数来剪切"></a>-c 参数：根据字符数来剪切</h4><p>c 是 character 的缩写，表示“字符”。</p>
<p>比如，我们要 name.txt 的每一行只保留第 2 至第 4 个字符。可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cut -c 2-4 name.txt</span><br></pre></td></tr></table></figure>



<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ol>
<li>grep 命令应该算是在文件中查找关键字最常用的工具了。</li>
<li>grep 命令可以通过正则表达式来查找。一开始正则表达式会比较难记，但是功能很强大。我们可以调用 egrep 命令，其等价于 grep -E。</li>
<li>sort 命令用于为文件中的行按字母顺序排序。使用 -n 参数可以按照数字顺序排序。</li>
<li>wc 命令可以统计文件中行数，单词数或者字节数。</li>
<li>uniq 命令可以用于删除文件中重复的内容。</li>
<li>cut 命令用于剪切文件的一部分内容。</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sqoop安装及配置</title>
    <url>/2020/03/09/49.sqoop%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="sqoop安装"><a href="#sqoop安装" class="headerlink" title="sqoop安装"></a>sqoop安装</h2><p>下载地址：<a href="http://archive.cloudera.com/cdh5/cdh/5/sqoop-1.4.6-cdh5.16.2.tar.gz" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/sqoop-1.4.6-cdh5.16.2.tar.gz</a></p>
<p>1.解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf sqoop-1.4.6-cdh5.16.2.tar.gz -C ~&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure>



<p>2.配置系统环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export SQOOP_HOME&#x3D;&#x2F;home&#x2F;hadoop&#x2F;app&#x2F;sqoop-1.4.6-cdh5.16.2</span><br><span class="line">export PATH&#x3D;$SQOOP_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>



<p>3.配置conf文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp sqoop-env-template.sh sqoop-env.sh</span><br><span class="line">export HADOOP_COMMON_HOME&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;hadoop-2.6.0-cdh5.16.2</span><br><span class="line">export HADOOP_MAPRED_HOME&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;hadoop-2.6.0-cdh5.16.2</span><br><span class="line">export HIVE_HOME&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;hive-1.1.0-cdh5.16.2</span><br></pre></td></tr></table></figure>



<p>4.导入mysql的jar包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp mysql-connector-java-5.1.47-bin.jar $SQOOP_HOME&#x2F;lib&#x2F;</span><br></pre></td></tr></table></figure>



<p>5.测试是否与mysql连通</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqoop list-databases --connect jdbc:mysql:&#x2F;&#x2F;hadoop000:3306&#x2F; --username root --password xxxxxx</span><br></pre></td></tr></table></figure>



<h2 id="导数据模板"><a href="#导数据模板" class="headerlink" title="导数据模板"></a>导数据模板</h2><h3 id="mysql-gt-hdfs"><a href="#mysql-gt-hdfs" class="headerlink" title="mysql-&gt;hdfs"></a>mysql-&gt;hdfs</h3><p>(1).全部导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;hadoop000:3306&#x2F;database \</span><br><span class="line">--username root \</span><br><span class="line">--password xxxxxx \</span><br><span class="line">--table staff \</span><br><span class="line">--target-dir &#x2F;user&#x2F;database \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--fields-terminated-by &quot;\t&quot;</span><br></pre></td></tr></table></figure>

<p>(2).查询导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;hadoop000:3306&#x2F;database \</span><br><span class="line">--username root \</span><br><span class="line">--password xxxxxx \</span><br><span class="line">--table staff \</span><br><span class="line">--target-dir &#x2F;user&#x2F;database \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--fields-terminated-by &quot;\t&quot;</span><br><span class="line">--query &quot;select name,sex from table where id &lt;&#x3D;1 and \$CONDITIONS;&quot;</span><br></pre></td></tr></table></figure>

<p>(3).导入指定的列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;hadoop000:3306&#x2F;database \</span><br><span class="line">--username root \</span><br><span class="line">--password xxxxxx \</span><br><span class="line">--table staff \</span><br><span class="line">--colums id,sex</span><br><span class="line">--target-dir &#x2F;user&#x2F;database \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--fields-terminated-by &quot;\t&quot;</span><br></pre></td></tr></table></figure>

<p>(4).查询条件导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;hadoop000:3306&#x2F;database \</span><br><span class="line">--username root \</span><br><span class="line">--password xxxxxx \</span><br><span class="line">--table staff \</span><br><span class="line">--colums id,sex</span><br><span class="line">--where &quot;id&#x3D;1&quot;</span><br><span class="line">--target-dir &#x2F;user&#x2F;database \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--fields-terminated-by &quot;\t&quot;</span><br></pre></td></tr></table></figure>



<h3 id="hdfs-gt-mysql"><a href="#hdfs-gt-mysql" class="headerlink" title="hdfs-&gt;mysql"></a>hdfs-&gt;mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqoop export \</span><br><span class="line">-Dsqoop.export.records.per.statement&#x3D;10 \</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;hadoop000:3306&#x2F;sqoop \</span><br><span class="line">--password xxxxxx \</span><br><span class="line">--username root \</span><br><span class="line">--table emp_demo \</span><br><span class="line">--export-dir &#x2F;user&#x2F;hadoop&#x2F;EMP_COLUMN_SPLIT \</span><br><span class="line">--columns &quot;EMPNO,ENAME,JOB,SAL,COMM&quot; \</span><br><span class="line">--fields-terminated-by &#39;\t&#39; \</span><br><span class="line">-m 1</span><br></pre></td></tr></table></figure>



<h3 id="mysql-gt-Hive"><a href="#mysql-gt-Hive" class="headerlink" title="mysql-&gt;Hive"></a>mysql-&gt;Hive</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;hadoop000:3306&#x2F;sqoop \</span><br><span class="line">--password xxxxxx \</span><br><span class="line">--username root \</span><br><span class="line">--table emp \</span><br><span class="line">--hive-overwrite \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--hive-import --hive-database hadoop_hive \</span><br><span class="line">--hive-table emp_import_partition \</span><br><span class="line">--hive-partition-key &#39;pt&#39; \</span><br><span class="line">--hive-partition-value &#39;2019-12-30&#39; \</span><br><span class="line">--fields-terminated-by &#39;\t&#39; \</span><br><span class="line">-m 1</span><br></pre></td></tr></table></figure>



<h3 id="hive-gt-mysql"><a href="#hive-gt-mysql" class="headerlink" title="hive-&gt;mysql"></a>hive-&gt;mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqoop export \</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;hadoop000:3306&#x2F;sqoop \</span><br><span class="line">--password xxxxxx \</span><br><span class="line">--username root \</span><br><span class="line">--table dept_demo \</span><br><span class="line">--export-dir &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;hadoop_hive.db&#x2F;dept \</span><br><span class="line">--fields-terminated-by &#39;\t&#39; \</span><br><span class="line">-m 1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>kdevtmpfsi,kinsing挖矿病毒清理</title>
    <url>/2020/03/08/48.kdevtmpfsi,kinsing%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<p>1.top命令  找到挖矿程序(kdevtmpfsi)进程号 CUP 占用100%</p>
<p>ps -ef |grep kdevtmpfsi</p>
<p>ps -ef |grep kinsing</p>
<p>直接kill -9 (PID) 把这个线程干掉了 过一阵子又回来了，crontab也需要修改</p>
<p>2.一般情况下你第一反应只能找到kdevtmpfsi，kinsing怎么找到的？</p>
<p>pstree -a</p>
<p>(如果没有下载， yum -y install psmisc)</p>
<p>3.到的并kill线程和它的守护线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux | grep kinsing</span><br><span class="line">ps -aux | grep kdevtmpfsi</span><br><span class="line">kill  -9   23437</span><br><span class="line">kill  -9   18534</span><br><span class="line">cd  &#x2F;tmp</span><br><span class="line">ls</span><br><span class="line">rm -rf kdevtmpfsi </span><br><span class="line">rm -rf &#x2F;var&#x2F;tmp&#x2F;kinsing  记得这个守护进程的文件也要删掉，找不到的话，也可以用这个命令</span><br><span class="line">find &#x2F; -name kdevtmpfsi</span><br><span class="line">find &#x2F; -name kinsing</span><br><span class="line"></span><br><span class="line">5.查找可疑定时任务</span><br><span class="line">crontab -l</span><br><span class="line">crontab -e删掉不可靠的定时任务</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>解决病毒</category>
      </categories>
      <tags>
        <tag>kdevtmpfsi</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper配置</title>
    <url>/2020/03/06/47.zookeeper%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>本文zookeeper采用zookeeper-3.4.5-cdh5.16.2版本</p>
<p>下载安装步骤本文不再提</p>
<p>下载地址：<a href="http://archive.cloudera.com/cdh5/cdh/5/zookeeper-3.4.5-cdh5.16.2.tar.gz" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/zookeeper-3.4.5-cdh5.16.2.tar.gz</a></p>
<p>1.配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ZOOKEEPER_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;zookeeper-3.4.5-cdh5.16.2</span><br><span class="line">export PATH&#x3D;$ZOOKEEPER_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>



<p>2.配置zoo.cfg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;pearfl&#x2F;app&#x2F;zookeeper-3.4.5-cdh5.16.2&#x2F;conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">vim zoo.cfg</span><br><span class="line"></span><br><span class="line">dataDir&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;tmp&#x2F;zookeeper0000(配置)</span><br></pre></td></tr></table></figure>

<p>修改临时目录，zookeeper0000会自动创建的</p>
<p>3.开启单机zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zkServer.sh</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Hue安装及部署</title>
    <url>/2020/03/05/46.hue%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Hue安装及部署"><a href="#Hue安装及部署" class="headerlink" title="Hue安装及部署"></a>Hue安装及部署</h1><p>hue官网：<a href="http://gethue.com/" target="_blank" rel="noopener">http://gethue.com/</a><br>配置文档：<a href="http://archive.cloudera.com/cdh5/cdh/5/hue-3.9.0-cdh5.16.2" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/hue-3.9.0-cdh5.16.2</a><br>源码：<a href="https://github.com/cloudera/hue" target="_blank" rel="noopener">https://github.com/cloudera/hue</a></p>
<p>这里我们直接用下载Hue：<a href="http://archive.cloudera.com/cdh5/cdh/5/hue-3.9.0-cdh5.16.2.tar.gz" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/hue-3.9.0-cdh5.16.2.tar.gz</a></p>
<h2 id="Hue简介"><a href="#Hue简介" class="headerlink" title="Hue简介"></a>Hue简介</h2><p>Hue是一个开源的Apache Hadoop UI系统，最早是由Cloudera Desktop演化而来，由Cloudera贡献给开源社区，它是基于Python Web框架Django实现的。通过使用Hue我们可以在浏览器端的Web控制台上与Hadoop集群进行交互来分析处理数据，例如操作HDFS上的数据，运行MapReduce Job等等。很早以前就听说过Hue的便利与强大，一直没能亲自尝试使用，下面先通过官网给出的特性，通过翻译原文简单了解一下Hue所支持的功能特性集合：</p>
<ul>
<li>默认基于轻量级sqlite数据库管理会话数据，用户认证和授权，可以自定义为MySQL、Postgresql，以及Oracle</li>
<li>基于文件浏览器（File Browser）访问HDFS</li>
<li>基于Hive编辑器来开发和运行Hive查询</li>
<li>支持基于Solr进行搜索的应用，并提供可视化的数据视图，以及仪表板（Dashboard）</li>
<li>支持基于Impala的应用进行交互式查询</li>
<li>支持Spark编辑器和仪表板（Dashboard）</li>
<li>支持Pig编辑器，并能够提交脚本任务</li>
<li>支持Oozie编辑器，可以通过仪表板提交和监控Workflow、Coordinator和Bundle</li>
<li>支持HBase浏览器，能够可视化数据、查询数据、修改HBase表</li>
<li>支持Metastore浏览器，可以访问Hive的元数据，以及HCatalog</li>
<li>支持Job浏览器，能够访问MapReduce Job（MR1/MR2-YARN）</li>
<li>支持Job设计器，能够创建MapReduce/Streaming/Java Job</li>
<li>支持Sqoop 2编辑器和仪表板（Dashboard）</li>
<li>支持ZooKeeper浏览器和编辑器</li>
<li>支持MySql、PostGresql、Sqlite和Oracle数据库查询编辑器</li>
</ul>
<a id="more"></a>



<h2 id="Hue-编译"><a href="#Hue-编译" class="headerlink" title="Hue 编译"></a>Hue 编译</h2><p>1.安装系统包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install ant asciidoc cyrus-sasl-devel cyrus-sasl-gssapi cyrus-sasl-plain gcc gcc-c++ krb5-devel libffi-devel libxml2-devel libxslt-devel make  mysql mysql-devel openldap-devel python-devel sqlite-devel gmp-devel</span><br></pre></td></tr></table></figure>

<p>2.编译Hue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zxf hue-3.9.0-cdh5.16.2.tar.gz -C ~&#x2F;app&#x2F;</span><br><span class="line">cd ~&#x2F;app&#x2F;hue-3.9.0-cdh5.16.2</span><br><span class="line">make apps</span><br></pre></td></tr></table></figure>

<p>当出现类似下面文本时，说明编译成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1426 static files copied to &#39;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;hue-3.9.0-cdh5.16.2&#x2F;build&#x2F;static&#39;, 1426 post-processed.</span><br><span class="line">make[1]: Leaving directory &#96;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;hue-3.9.0-cdh5.16.2&#x2F;apps&#39;</span><br></pre></td></tr></table></figure>



<h2 id="Hue配置"><a href="#Hue配置" class="headerlink" title="Hue配置"></a>Hue配置</h2><p>配置文件地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$HUE_HOME&#x2F;desktop&#x2F;conf&#x2F;hue.ini</span><br><span class="line"></span><br><span class="line">[desktop]</span><br><span class="line">	secret_key&#x3D;23dsafksl;fkp2(随便写，做hash的)</span><br><span class="line">	http_host&#x3D;hadoop000(跑的机器)</span><br><span class="line">	http_port&#x3D;38888(8888容易被挖矿，修改)</span><br><span class="line">	time_zone&#x3D;Asia&#x2F;Shanghai(时区)</span><br><span class="line"></span><br><span class="line">启动HUE</span><br><span class="line">	build&#x2F;env&#x2F;bin&#x2F;supervisor</span><br></pre></td></tr></table></figure>



<p>1.HUE整合HDFS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">core-site.xml</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">	&lt;name&gt;hadoop.proxyuser.hadoop.hosts&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">	&lt;name&gt;hadoop.proxyuser.hadoop.groups&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">hdfs-site.xml</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.webhdfs.enabled&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;true&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">修改完Hadoop相关的配置之后，肯定需要重启才生效</span><br><span class="line"></span><br><span class="line">hue.ini内修改</span><br><span class="line">[hadoop]</span><br><span class="line">	fs_defaultfs&#x3D;hdfs:&#x2F;&#x2F;hadoop000:8020</span><br><span class="line">	webhdfs_url&#x3D;http:&#x2F;&#x2F;hadoop000:50070&#x2F;webhdfs&#x2F;v1</span><br><span class="line">	hadoop_conf_dir&#x3D;$HADOOP_HOME&#x2F;etc&#x2F;conf(HADOOP_HOME自己写pwd的那个显示)</span><br></pre></td></tr></table></figure>



<p>2.HUE整合MR/YARN</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你需要启动mr-jobhistory-daemon.sh</span><br><span class="line">	mapred-site.xml</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;mapreduce.jobhistory.address&lt;&#x2F;name&gt;</span><br><span class="line">		&lt;value&gt;hadoop000:10020&lt;&#x2F;value&gt;</span><br><span class="line">	&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;&#x2F;name&gt;</span><br><span class="line">		&lt;value&gt;hadoop000:19888&lt;&#x2F;value&gt;</span><br><span class="line">	&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;mapreduce.jobhistory.done-dir&lt;&#x2F;name&gt;</span><br><span class="line">		&lt;value&gt;&#x2F;history&#x2F;done&lt;&#x2F;value&gt;</span><br><span class="line">	&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;mapreduce.jobhistory.intermediate-done-dir&lt;&#x2F;name&gt;</span><br><span class="line">		&lt;value&gt;&#x2F;history&#x2F;done_intermediate&lt;&#x2F;value&gt;</span><br><span class="line">	&lt;&#x2F;property&gt;</span><br><span class="line">	</span><br><span class="line">	mr-jobhistory-daemon.sh start historyserver</span><br><span class="line">		jps进程: JobHistoryServer</span><br><span class="line">	</span><br><span class="line">	[yarn_clusters]</span><br><span class="line">	resourcemanager_host&#x3D;hadoop000</span><br><span class="line">	resourcemanager_port&#x3D;8032</span><br><span class="line">	resourcemanager_api_url&#x3D;http:&#x2F;&#x2F;hadoop000:8088</span><br><span class="line">	proxy_api_url&#x3D;http:&#x2F;&#x2F;hadoop000:8088</span><br><span class="line">	history_server_api_url&#x3D;http:&#x2F;&#x2F;hadoop000:19888</span><br><span class="line">	</span><br><span class="line">1.记得yarn已经配置过基础配置了，不然无法启动</span><br><span class="line">2.hue界面的超级用户名字需要和提交到yarn的用户名字相同</span><br></pre></td></tr></table></figure>



<p>3.HUE整合MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[librdbms]</span><br><span class="line">	打开mysql注释</span><br><span class="line">	nice_name&#x3D;&quot;pearflDB&quot;</span><br><span class="line">	name&#x3D;demo_hive</span><br><span class="line">	engine&#x3D;mysql</span><br><span class="line">	host&#x3D;hadoop000</span><br><span class="line">	port&#x3D;3306</span><br><span class="line">	user&#x3D;root</span><br><span class="line">	password&#x3D;password</span><br></pre></td></tr></table></figure>



<p>4.HUE整合Hive</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一定要先启动hiveserver2</span><br><span class="line">	hiveserver2 1&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">	[beeswax]</span><br><span class="line">	hive_server_host&#x3D;hadoop000</span><br><span class="line">	hive_server_port&#x3D;10000</span><br><span class="line">	hive_conf_dir&#x3D;$HIVE_HOME&#x2F;conf</span><br></pre></td></tr></table></figure>



<h2 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h2><p>1.database if locked问题要如何处理？</p>
<p>答：默认底层sqlite3，我们可以配置hue访问mysql</p>
<p>2.Cannot access: /. Note: you are a Hue admin but not a HDFS superuser, “hdfs” or part of HDFS supergroup, “supergroup”.</p>
<p>答：hue.ini配置文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_user&#x3D;root</span><br><span class="line">server_group&#x3D;root</span><br><span class="line">default_user&#x3D;root</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hue</tag>
      </tags>
  </entry>
  <entry>
    <title>linux上的一些快捷键</title>
    <url>/2020/02/23/44.linux%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>列举一些经常使用的快捷键：</p>
<ul>
<li>Ctrl + L 用于清理终端的内容，就是清屏的作用。其实 clear 命令也有同样效果，但是你不觉得 Ctrl + L 的按键比输入 clear 这五个字母更快速吗？</li>
<li>Ctrl + D 给终端传递 EOF （End Of File，文件结束符），在运行程序时很有用。有些程序我们需要在接收到 EOF 输入时结束，那么这个快捷键就可以派上用场了。比如我们之前演示过，退出 root 用户身份，就可以用 Ctrl + D。如果你在命令行提示符后什么也不输入的情况下直接按下这组快捷键，那么就会关闭当前的终端；</li>
<li>Shift + PgUp 用于向上滚屏，与鼠标的滚轮向上滚屏是一个效果；</li>
<li>Shift + PgDn 用于向下滚屏，与鼠标的滚轮向下滚屏是一个效果。</li>
</ul>
<p>下面的快捷键在你编辑一条比较长的命令时很有用：</p>
<ul>
<li>Ctrl + A 光标跳到一行命令的开头。一般来说，Home 键有相同的效果；</li>
<li>Ctrl + E 光标跳到一行命令的结尾。一般来说，End 键有相同的效果；。</li>
<li>Ctrl + U 删除所有在光标左侧的命令字符；</li>
<li>Ctrl + K 删除所有在光标右侧的命令字符；</li>
<li>Ctrl + W 删除光标左侧的一个“单词”，这里的“单词”指的是用空格隔开的一个字符串。例如 -a 就是一个“单词”；</li>
<li>Ctrl + Y 粘贴用 Ctrl + U、 Ctrl + K 或 Ctrl + W “删除”的字符串，有点像“剪切-粘贴”。</li>
</ul>
<p>当然了，好的快捷键绝不止这些。</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop jar跑mr作业的坑</title>
    <url>/2020/02/19/43.hadoop%20jar%E8%B7%91mr%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h2 id="1-Driver需要extends-Configured-implements-Tool"><a href="#1-Driver需要extends-Configured-implements-Tool" class="headerlink" title="1.Driver需要extends Configured implements Tool"></a>1.Driver需要extends Configured implements Tool</h2><p>如果你不调用run方法跑Driver，那么服务器上是绝对跑不出来的</p>
<h2 id="2-Too-many-open-files问题"><a href="#2-Too-many-open-files问题" class="headerlink" title="2.Too many open files问题"></a>2.Too many open files问题</h2><p>Linux中所有的事物或资源都是以文件的形式存在，比如消息、共享内存、连接等，句柄可以理解为指向这些文件的指针。</p>
<p>对于这些句柄，Linux是有数量限制的，单个进程默认可以打开的句柄数上限</p>
<p>我们可以通过修改句柄数来解决这个问题</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>scala之val与var</title>
    <url>/2020/02/16/42.scala%E4%B9%8Bval%E4%B8%8Evar/</url>
    <content><![CDATA[<p><strong>val vs var</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val:值</span><br><span class="line">	final</span><br><span class="line">	val 值名称:类型 &#x3D; xxx</span><br><span class="line">var:变量</span><br><span class="line">	var 值名称:类型 &#x3D; xxx</span><br></pre></td></tr></table></figure>

<p>其实简单的来说，就是一个可变，一个不可变</p>
<p>如果不需要变化，就使用val，能用val就不用var =3=</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈flume的基础使用</title>
    <url>/2020/02/13/41.%E6%B5%85%E8%B0%88flume/</url>
    <content><![CDATA[<p><strong>flume官方文档：</strong><a href="http://flume.apache.org/" target="_blank" rel="noopener">http://flume.apache.org/</a></p>
<p><img src="/images/41/41_1.png" alt="41_1"></p>
<p>从系统架构图上来看，用户只要产生行为，那么日志就会在Nginx服务器中保存，所以我们现在要做的就是把数据从Nginx服务器中使用Flume采集到HDFS上</p>
<a id="more"></a>

<h2 id="flume怎么用？"><a href="#flume怎么用？" class="headerlink" title="flume怎么用？"></a>flume怎么用？</h2><p><strong>flume</strong></p>
<p>Flume就是一个针对日志数据进行采集和汇总的一个框架</p>
<p>Flume的进程叫做Agent，每个Agent中有Srouce、Channel？Sink</p>
<p>Flume从使用层面来讲就是写配置文件，其实就是配置我们的Agent，只要学会从官网查配置就行了</p>
<p><strong>Agent</strong></p>
<p>Source中的常用方式有 avro、exec、spooling、taildir、kafka</p>
<p>Channel中的常用方式有 memory、kafka、file</p>
<p>Sink中的常用方式有 hdfs、logger、avro、kafka</p>
<h2 id="flume编译安装和配置"><a href="#flume编译安装和配置" class="headerlink" title="flume编译安装和配置"></a>flume编译安装和配置</h2><p>先配置好maven环境（参考之前的博文），解压flume-ng-1.6.0-cdh5.16.2-src.tar.gz并进入解压路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -zxvf flume-ng-1.6.0-cdh5.16.2-src.tar.gz</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean compile validate -Denforcer.skip&#x3D;true</span><br></pre></td></tr></table></figure>

<p>提示：flume-ng-morphline-solr-sink我们用不到，可以直接注释掉，在flume-ng-sinks下的pom中找到并注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">   &lt;module&gt;flume-hdfs-sink&lt;&#x2F;module&gt;</span><br><span class="line">   &lt;module&gt;flume-irc-sink&lt;&#x2F;module&gt;</span><br><span class="line">   &lt;module&gt;flume-ng-hbase-sink&lt;&#x2F;module&gt;</span><br><span class="line">   &lt;module&gt;flume-ng-elasticsearch-sink&lt;&#x2F;module&gt;</span><br><span class="line">   &lt;!--&lt;module&gt;flume-ng-morphline-solr-sink&lt;&#x2F;module&gt; --&gt;</span><br><span class="line">   &lt;module&gt;flume-ng-kafka-sink&lt;&#x2F;module&gt;</span><br><span class="line"> &lt;&#x2F;modules&gt;</span><br></pre></td></tr></table></figure>

<p>在.bash_profile里配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FLUME_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;apache-flume-1.6.0-cdh5.16.2-bin</span><br><span class="line">export PATH&#x3D;$FLUME_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<p>conf目录下的flume-env.sh需要配置jdk路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;jdk1.8.0_231</span><br></pre></td></tr></table></figure>



<!--more-->

<h2 id="flume核心组件"><a href="#flume核心组件" class="headerlink" title="flume核心组件"></a>flume核心组件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source	从哪收集</span><br><span class="line">	avro	序列化</span><br><span class="line">	exec	命令行</span><br><span class="line">	spooling	目录</span><br><span class="line">	taildir	******</span><br><span class="line">	kafka</span><br><span class="line"></span><br><span class="line">Channel	数据存哪里</span><br><span class="line">	memory</span><br><span class="line">	kafka</span><br><span class="line">	file</span><br><span class="line">	</span><br><span class="line">Sink	数据输出到哪里</span><br><span class="line">	hdfs	Hadoop</span><br><span class="line">	logger	控制台</span><br><span class="line">	avro	</span><br><span class="line">	kafka</span><br></pre></td></tr></table></figure>



<h2 id="flume简单配置文件"><a href="#flume简单配置文件" class="headerlink" title="flume简单配置文件"></a>flume简单配置文件</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example.conf: A single-node Flume configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe/configure the source</span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = 0.0.0.0</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a channel which buffers events in memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind the source and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<p>解释说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example.conf	&lt;&#x3D;	flume配置文件的文件名</span><br><span class="line">a1	&lt;&#x3D;	agent的名字</span><br><span class="line">r1	&lt;&#x3D;	source的名字</span><br><span class="line">k1	&lt;&#x3D;	sink的名字</span><br><span class="line">c1	&lt;&#x3D;	channel的名字</span><br></pre></td></tr></table></figure>

<p>我们在flume文件夹下，进去后新建script文件夹，在script文件夹内创建example.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkdir script</span><br><span class="line"># cd script&#x2F;</span><br><span class="line"># vi example.conf</span><br><span class="line"></span><br><span class="line">a1.sources &#x3D; r1</span><br><span class="line">a1.sinks &#x3D; k1</span><br><span class="line">a1.channels &#x3D; c1</span><br><span class="line"></span><br><span class="line">a1.sources.r1.type &#x3D; netcat</span><br><span class="line">a1.sources.r1.bind &#x3D; 0.0.0.0</span><br><span class="line">a1.sources.r1.port &#x3D; 44444</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type &#x3D; logger</span><br><span class="line"></span><br><span class="line">a1.channels.c1.type &#x3D; memory</span><br><span class="line"></span><br><span class="line">a1.sources.r1.channels &#x3D; c1</span><br><span class="line">a1.sinks.k1.channel &#x3D; c1</span><br></pre></td></tr></table></figure>

<p>启动命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># flume-ng agent --name a1 --conf $FLUME_HOME&#x2F;conf --conf-file $FLUME_HOME&#x2F;script&#x2F;example.conf -Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Event:	Flume数据传输的基本单元</span><br><span class="line">event	&#x3D;&#x3D;&gt;	flume	&#x3D;&#x3D;&gt;	dst</span><br><span class="line">	header	可选的</span><br><span class="line">		k-v</span><br><span class="line">	body	byte	array</span><br></pre></td></tr></table></figure>



<h2 id="flume进一步理解"><a href="#flume进一步理解" class="headerlink" title="flume进一步理解"></a>flume进一步理解</h2><p>追踪日志不断增加的内容，并且输出到hdfs中（单文件）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line">a1.sources.r1.type = exec</span><br><span class="line">a1.sources.r1.command = tail -F /home/pearfl/data/flume/data.log</span><br><span class="line">a1.sources.r1.shell = /bin/sh -c</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type = hdfs</span><br><span class="line">a1.sinks.k1.hdfs.path = hdfs://hadoop000:8020/ruozedata/flume/tail</span><br><span class="line">a1.sinks.k1.batchSize = 10</span><br><span class="line">a1.sinks.k1.fileType = DataStream</span><br><span class="line">a1.sinks.k1.writeFormat = Text</span><br><span class="line"></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># flume-ng agent --name a1 --conf $FLUME_HOME&#x2F;conf --conf-file $FLUME_HOME&#x2F;script&#x2F;flume-exec-hdfs.conf -Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure>



<p>目录</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line">a1.sources.r1.type = spooldir</span><br><span class="line">a1.sources.r1.spoolDir = /home/pearfl/data/flume/spool/</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type = hdfs</span><br><span class="line">a1.sinks.k1.hdfs.path = hdfs://hadoop000:8020/ruozedata/flume/spool/%Y%m%d%H%M</span><br><span class="line">a1.sinks.k1.batchSize = 10</span><br><span class="line">a1.sinks.k1.fileType = DataStream</span><br><span class="line">a1.sinks.k1.writeFormat = Text</span><br><span class="line">a1.sinks.k1.filePrefix = bigdata-</span><br><span class="line">a1.sinks.k1.useLocalTimeStamp = true</span><br><span class="line"></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># flume-ng agent --name a1 --conf $FLUME_HOME&#x2F;conf --conf-file $FLUME_HOME&#x2F;script&#x2F;flume-spool-hdfs.conf -Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure>



<h2 id="生产上常用tairdir"><a href="#生产上常用tairdir" class="headerlink" title="生产上常用tairdir"></a>生产上常用tairdir</h2><p>文档：<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#taildir-source" target="_blank" rel="noopener">http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#taildir-source</a></p>
<p>TAIRDIR<br>    offset<br>    不仅仅可以支持到file，也可以支持的directory</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line">a1.sources.r1.type = TAILDIR</span><br><span class="line">a1.sources.r1.filegroups = f1 f2</span><br><span class="line">a1.sources.r1.positionFile = /home/pearfl/data/flume/taildir_position.json</span><br><span class="line">a1.sources.r1.filegroups.f1 = /home/pearfl/data/flume/taildir/test1/example.log</span><br><span class="line">a1.sources.r1.headers.f1.headerKey1 = value1</span><br><span class="line">a1.sources.r1.filegroups.f2 = /home/pearfl/data/flume/taildir/test2/.*log.*</span><br><span class="line">a1.sources.r1.headers.f2.headerKey1 = value2</span><br><span class="line">a1.sources.r1.headers.f2.headerKey2 = value2-2</span><br><span class="line"></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># flume-ng agent --name a1 --conf $FLUME_HOME&#x2F;conf --conf-file $FLUME_HOME&#x2F;script&#x2F;flume-taildir-logger.conf -Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure>

<p>其中<code>taildir_position.json</code>文件是用来记录文件读取offset的位置，方便下次继续从offset位置读取</p>
<p>注意<code>taildir_position.json</code>文件不能存在上级目录，不然会报错</p>
<h2 id="Flume远程实时采集Windows产生的log4j产生的数据（控制台输出）"><a href="#Flume远程实时采集Windows产生的log4j产生的数据（控制台输出）" class="headerlink" title="Flume远程实时采集Windows产生的log4j产生的数据（控制台输出）"></a>Flume远程实时采集Windows产生的log4j产生的数据（控制台输出）</h2><p>IDEA上的pom.xml添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- flume采集 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.flume.flume-ng-clients&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;flume-ng-log4jappender&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.6.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>IDEA上的log4j.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger&#x3D;INFO,stdout,flume</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.target&#x3D;System.out</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c] [%p] - %m%n</span><br><span class="line"></span><br><span class="line">log4j.appender.flume &#x3D; org.apache.flume.clients.log4jappender.Log4jAppender</span><br><span class="line">log4j.appender.flume.Hostname &#x3D; hadoop000</span><br><span class="line">log4j.appender.flume.Port &#x3D; 41414</span><br><span class="line">log4j.appender.flume.UnsafeMode &#x3D; true</span><br><span class="line">log4j.appender.flume.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.flume.layout.ConversionPattern&#x3D;%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c] [%p] - %m%n</span><br></pre></td></tr></table></figure>



<p>streaming.conf</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"><span class="comment"># 配置监控文件</span></span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind=0.0.0.0</span><br><span class="line">a1.sources.r1.port=41414</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置sink</span></span><br><span class="line">a1.sinks.k1.type =logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># a1.sinks.k1.type = file_roll</span></span><br><span class="line"><span class="comment"># a1.sinks.k1.sink.directory =/home/pearfl/tmp/stream</span></span><br><span class="line"><span class="comment"># a1.sinks.k1.sink.rollInterval=300</span></span><br><span class="line"><span class="comment"># a1.sinks.k1.sink.batchSize=100</span></span><br><span class="line"><span class="comment"># a1.sinks.k1.sink.serializer=TEXT</span></span><br><span class="line"><span class="comment"># a1.sinks.k1.sink.serializer.appendNewline = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------</span></span><br><span class="line"><span class="comment"># 配置channel</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"><span class="comment"># 将三者串联</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># flume-ng agent --name a1 --conf $FLUME_HOME&#x2F;conf --conf-file $FLUME_HOME&#x2F;script&#x2F;streaming.conf -Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure>



<h2 id="Flume远程实时采集Windows产生的log4j产生的数据（控制台输出存入hdfs）"><a href="#Flume远程实时采集Windows产生的log4j产生的数据（控制台输出存入hdfs）" class="headerlink" title="Flume远程实时采集Windows产生的log4j产生的数据（控制台输出存入hdfs）"></a>Flume远程实时采集Windows产生的log4j产生的数据（控制台输出存入hdfs）</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"><span class="comment"># 配置监控文件</span></span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind=0.0.0.0</span><br><span class="line">a1.sources.r1.port=41414</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置sink</span></span><br><span class="line"><span class="comment"># a1.sinks.k1.type =logger</span></span><br><span class="line"><span class="comment">#a1.sinks.k1.maxBytesToLog = 50</span></span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type = hdfs</span><br><span class="line">a1.sinks.k1.hdfs.path = hdfs://hadoop000:8020/data/tmp/%Y%m%d%H%M</span><br><span class="line">a1.sinks.k1.hdfs.batchSize = 10</span><br><span class="line">a1.sinks.k1.hdfs.fileType = DataStream</span><br><span class="line">a1.sinks.k1.hdfs.writeFormat = Text</span><br><span class="line">a1.sinks.k1.hdfs.useLocalTimeStamp = true</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------</span></span><br><span class="line"><span class="comment"># 配置channel</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"><span class="comment"># 将三者串联</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># flume-ng agent --name a1 --conf $FLUME_HOME&#x2F;conf --conf-file $FLUME_HOME&#x2F;script&#x2F;hdfs-stream.conf -Dflume.root.logger&#x3D;INFO,console</span><br></pre></td></tr></table></figure>



<h2 id="解决Flume采集数据时生成大量小文件的问题"><a href="#解决Flume采集数据时生成大量小文件的问题" class="headerlink" title="解决Flume采集数据时生成大量小文件的问题"></a>解决Flume采集数据时生成大量小文件的问题</h2><p>在使用Flume采集数据时，由于默认参数的影响会生产大量小文件，我们先看默认参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs.rollInterval	30	滚动当前文件之前要等待的秒数</span><br><span class="line">hdfs.rollSize	1024	触发滚动当前文件的大小，单位bytes(B)</span><br><span class="line">hdfs.rollCount	10		触发滚动当前文件的events数量</span><br></pre></td></tr></table></figure>

<p>我们看到默认生成文件有三个条件，每30秒、每1M、每10个events，这样的配置会生成大量的小文件，所以我们要对这三个文件进行修改</p>
<p>最终生成的文件必须综合时间、文件大小、event数量来决定，时间太长或者文件太大都不利于最终生成的文件。该时间还需要配合<code>hdfs.path</code>参数指定的生成文件时间。</p>
<p>注意<code>sink.type</code>如果是<code>memory</code>模式，注意文件的大小，防止内存不足，太大可以设置<code>sink.type = file</code></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>flume</tag>
      </tags>
  </entry>
  <entry>
    <title>python的map()和 filter()</title>
    <url>/2020/02/12/40.python%E7%9A%84map()%E5%92%8C%20filter()/</url>
    <content><![CDATA[<h1 id="map-和-filter"><a href="#map-和-filter" class="headerlink" title="map() 和 filter()"></a>map() 和 filter()</h1><p>Python 内置有两个非常好用的高阶函数 <code>map()</code> 和 <code>filter()</code>。</p>
<p><code>filter()</code> 用于从可迭代对象中筛选元素。用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filter(筛选函数, 可迭代对象)</span><br></pre></td></tr></table></figure>

<p><code>filter()</code> 依次对 <code>可迭代对象</code> 中的每个元素调用 <code>筛选函数</code>，如果返回值为 <code>True</code>，则当前这个元素会被保留，否则被排除。最终返回一个包含所有被保留元素的迭代器。</p>
<p>显然这里的 <code>筛选函数</code> 可以用 lambda 表达式来创建。</p>
<p>例如，从 <code>[&#39;a&#39;, &#39;b&#39;, &#39;cd&#39;, &#39;efg&#39;, &#39;hig&#39;, &#39;klmn&#39;, &#39;opqr&#39;]</code> 筛选出长度为奇数的字符串。可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filter(<span class="keyword">lambda</span> x: len(x) % <span class="number">2</span> == <span class="number">1</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'cd'</span>, <span class="string">'efg'</span>, <span class="string">'hig'</span>, <span class="string">'klmn'</span>, <span class="string">'opqr'</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: len(x) % <span class="number">2</span> == <span class="number">1</span>, [‘a’, ‘b’, ‘cd’, ‘efg’, ‘hig’, ‘klmn’, ‘opqr’]))</span><br><span class="line">[‘a’, ‘b’, ‘efg’, ‘hig’]</span><br></pre></td></tr></table></figure>

<p>这里我们用 <code>list()</code> 将迭代器转换为列表。</p>
<a id="more"></a>

<p><code>map()</code> 用于对可迭代对象中每一个元素逐一作处理。用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">map(处理函数, 可迭代对象)</span><br></pre></td></tr></table></figure>

<p><code>map()</code>依次对<code>可迭代对象</code>中的每个元素调用<code>处理函数</code>，最终返回一个包含所有被处理过后的元素的迭代器。</p>
<p>显然这里的<code>处理函数</code>也可以用 lambda 表达式来创建。</p>
<p>例如，将<code>[&#39;a&#39;, &#39;b&#39;, &#39;cd&#39;, &#39;efg&#39;, &#39;hig&#39;, &#39;klmn&#39;, &#39;opqr&#39;]</code>全部转换为大写。可以这样来写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">map(<span class="keyword">lambda</span> x: x.upper(), [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'cd'</span>, <span class="string">'efg'</span>, <span class="string">'hig'</span>, <span class="string">'klmn'</span>, <span class="string">'opqr'</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x.upper(), [‘a’, ‘b’, ‘cd’, ‘efg’, ‘hig’, ‘klmn’, ‘opqr’]))</span><br><span class="line">[‘A’, ‘B’, ‘CD’, ‘EFG’, ‘HIG’, ‘KLMN’, ‘OPQR’]</span><br></pre></td></tr></table></figure>

<p>这里我们用 <code>list()</code> 将迭代器转换为列表</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中lambda 表达式的简单应用</title>
    <url>/2020/02/12/39.python%E4%B8%ADlambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>在 Python 中，可以通过 lambda 表达式来便捷地定义一个功能简单的函数，这个函数只有实现没有名字，所以叫作匿名函数</p>
<p>lambda 表达式的写法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数<span class="number">1</span>, 参数<span class="number">2</span>, 参数N: 函数实现</span><br></pre></td></tr></table></figure>

<p>使用上述表达式将定义一个匿名函数，这个匿名函数可接受若干参数，参数写在冒号前（<code>:</code>），多个参数时用逗号分隔，其实现写在冒号后（<code>:</code>）。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: x ** <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这个 lambda 表达式定义了一个匿名函数，这个匿名函数接受一个参数 <code>x</code>，返回 <code>x ** 2</code> 的计算结果。同时赋值语句将这个匿名函数赋值给了变量 <code>f</code>。<strong>注意 <code>f</code> 保存的是函数，而不是函数结果。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function at <span class="number">0x10bcba0d0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">4</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">9</span>)</span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>

<p>通过观察上述示例可以发现，lambda 表达式中并没有 <code>return</code> 关键字，但结果被返回出来。是的，匿名函数的 <code>函数实现</code> 的执行结果就会作为它的返回值，无需使用 <code>return</code> 关键字。</p>
<p>从功能上来看，<code>lambda x: x ** 2</code> 等同于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no_name</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>no_name(<span class="number">4</span>)</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>



<p>一般情况下，我们不会像 <code>f = lambda x: x ** 2</code> 这样直接将匿名函数赋值给变量，然后去用这个变量。而是在需要将函数作为参数时，才去使用 lambda 表达式，这样就无需在函数调用前去定义另外一个函数了。</p>
<p>如我们刚才写的函数 <code>filter_nums</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_nums</span><span class="params">(nums, want_it)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [n <span class="keyword">for</span> n <span class="keyword">in</span> nums <span class="keyword">if</span> want_it(n)]</span><br></pre></td></tr></table></figure>

<p>它的 <code>want_it</code> 参数需要是一个函数 ，这时用 lambda 表达式便能方便的解决问题。可以像这样来使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter_nums([<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>], <span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">[<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br></pre></td></tr></table></figure>

<p>以前讲内置函数的时候，我们介绍过排序函数 <code>sorted()</code>。它有一个参数 <code>key</code>，用来在排序复杂元素时，指定排序所使用的字段，这个参数需要是个函数，同样可以用 lambda 表达式来解决：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = [(‘上海’, ‘<span class="number">021</span>’), (‘北京’, ‘<span class="number">010</span>’), (‘成都’, ‘<span class="number">028</span>’), (‘广州’, ‘<span class="number">020</span>’)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(codes, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment"># 以区号字典来排序</span></span><br><span class="line">[(‘北京’, ‘<span class="number">010</span>’), (‘广州’, ‘<span class="number">020</span>’), (‘上海’, ‘<span class="number">021</span>’), (‘成都’, ‘<span class="number">028</span>’)]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark编译安装</title>
    <url>/2020/02/11/38.Spark%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>官方文档：<a href="http://spark.apache.org/docs/latest/building-spark.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/building-spark.html</a></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1.JDK:Spark 2.2.0及以上版本只支持JDK1.8</p>
<p>2.Maven：3.6.3</p>
<ol>
<li><p>设置maven环境变量时，需设置maven内存：</p>
</li>
<li><p>export MAVEN_OPTS=”-Xmx2g -XX:ReservedCodeCacheSize=512m”</p>
</li>
</ol>
<p>3.Scala：2.13.1</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ol>
<li><strong>下载spark的tar包，并解压</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;spark&#x2F;spark-2.4.5&#x2F;spark-2.4.5.tgz</span><br><span class="line"># tar -xzvf spark-2.4.5.tgz</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>编辑dev/make-distribution.sh</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  vi dev&#x2F;make-distribution.sh</span><br></pre></td></tr></table></figure>


<p>注释以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#VERSION&#x3D;$(&quot;$MVN&quot; help:evaluate -Dexpression&#x3D;project.version $@ 2&gt;&#x2F;dev&#x2F;null | grep -v &quot;INFO&quot; | tail -n 1)</span><br><span class="line">#SCALA_VERSION&#x3D;$(&quot;$MVN&quot; help:evaluate -Dexpression&#x3D;scala.binary.version $@ 2&gt;&#x2F;dev&#x2F;null\</span><br><span class="line">#    | grep -v &quot;INFO&quot;\</span><br><span class="line">#    | tail -n 1)</span><br><span class="line">#SPARK_HADOOP_VERSION&#x3D;$(&quot;$MVN&quot; help:evaluate -Dexpression&#x3D;hadoop.version $@ 2&gt;&#x2F;dev&#x2F;null\</span><br><span class="line">#    | grep -v &quot;INFO&quot;\</span><br><span class="line">#    | tail -n 1)</span><br><span class="line">#SPARK_HIVE&#x3D;$(&quot;$MVN&quot; help:evaluate -Dexpression&#x3D;project.activeProfiles -pl sql&#x2F;hive $@ 2&gt;&#x2F;dev&#x2F;null\</span><br><span class="line">#    | grep -v &quot;INFO&quot;\</span><br><span class="line">#    | fgrep --count &quot;&lt;id&gt;hive&lt;&#x2F;id&gt;&quot;;\</span><br><span class="line">#    # Reset exit status to 0, otherwise the script stops here if the last grep finds nothing\</span><br><span class="line">#    # because we use &quot;set -o pipefail&quot;</span><br><span class="line">#    echo -n)</span><br></pre></td></tr></table></figure>

<p> 添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VERSION&#x3D;2.4.5</span><br><span class="line">SCALA_VERSION&#x3D;2.13</span><br><span class="line">SPARK_HADOOP_VERSION&#x3D;2.6.0-cdh5.16.2</span><br><span class="line">SPARK_HIVE&#x3D;1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>编辑pom.xml</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加</span><br><span class="line"></span><br><span class="line">&lt;repository&gt;</span><br><span class="line">    &lt;id&gt;clouders&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;name&gt;clouders Repository&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;url&gt;https:&#x2F;&#x2F;repository.cloudera.com&#x2F;artifactory&#x2F;cloudera-repos&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">&lt;&#x2F;repository&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装</strong></p>
<p>在解压后的spark目录下</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># $ .&#x2F;dev&#x2F;make-distribution.sh --name 2.6.0-cdh5.16.2 --tgz -Dhadoop.version&#x3D;2.6.0-cdh5.16.2 -Phadoop-2.6 -Phive -Phive-thriftserver -Pyarn</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala安装</title>
    <url>/2020/02/10/37.Scala%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>需要预先安装好jdk8+</p>
<p>已经下载好scala包放置于software目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -zxvf scala-2.13.1.tgz -C ~&#x2F;app&#x2F;</span><br><span class="line"># vi ~&#x2F;.bash_profile</span><br><span class="line">export SCALA_HOME&#x3D;&#x2F;root&#x2F;app&#x2F;scala-2.13.1</span><br><span class="line">export PATH&#x3D;$SCALA_HOME&#x2F;bin:$PATH</span><br><span class="line"># source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>



<p>非常的简单哟</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底明白Java的值传递和引用传递</title>
    <url>/2020/02/10/36.%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDJava%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/bntx2jsqfehy7/article/details/83508006" target="_blank" rel="noopener">https://blog.csdn.net/bntx2jsqfehy7/article/details/83508006</a></p>
<h2 id="一、形参与实参"><a href="#一、形参与实参" class="headerlink" title="一、形参与实参"></a>一、形参与实参</h2><ol>
<li>形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了</li>
<li>实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</li>
</ol>
<h2 id="二、-java的数据类型"><a href="#二、-java的数据类型" class="headerlink" title="二、 java的数据类型"></a>二、 java的数据类型</h2><p>所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行</p>
<p>数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</p>
<p>所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。</p>
<a id="more"></a>

<p>1.基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>种整数类型：<span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">int</span>、<span class="keyword">long</span></span><br><span class="line"><span class="number">2</span>种浮点数类型：<span class="keyword">float</span>、<span class="keyword">double</span></span><br><span class="line"><span class="number">1</span>种字符类型：<span class="keyword">char</span></span><br><span class="line"><span class="number">1</span>种布尔类型：<span class="keyword">boolean</span></span><br></pre></td></tr></table></figure>

<p>2.引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类</span><br><span class="line">接口</span><br><span class="line">数组</span><br></pre></td></tr></table></figure>

<p>有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。</p>
<h2 id="三、JVM内存的划分及职能"><a href="#三、JVM内存的划分及职能" class="headerlink" title="三、JVM内存的划分及职能"></a>三、JVM内存的划分及职能</h2><p>Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：</p>
<p><img src="/images/36/36_1.png" alt="36_1"></p>
<p>有图可以看出：Java代码被编译器编译成字节码之后，JVM开辟一片内存空间（也叫运行时数据区），通过类加载器加到到运行时数据区来存储程序执行期间需要用到的数据和相关信息，在这个数据区中，它由以下几部分组成：</p>
<ol>
<li><p>虚拟机栈</p>
</li>
<li><p>堆</p>
</li>
<li><p>程序计数器</p>
</li>
<li><p>方法区</p>
</li>
<li><p>本地方法栈</p>
</li>
</ol>
<p>我们接着来了解一下每部分的原理以及具体用来存储程序执行过程中的哪些数据。</p>
<h3 id="1-虚拟机栈"><a href="#1-虚拟机栈" class="headerlink" title="1.虚拟机栈"></a>1.虚拟机栈</h3><p>虚拟机栈是Java方法执行的内存模型，栈中存放着栈帧，每个栈帧分别对应一个被调用的方法，方法的调用过程对应栈帧在虚拟机中入栈到出栈的过程。</p>
<p>栈是线程私有的，也就是线程之间的栈是隔离的；当程序中某个线程开始执行一个方法时就会相应的创建一个栈帧并且入栈（位于栈顶），在方法结束后，栈帧出栈。</p>
<p>下图表示了一个Java栈的模型以及栈帧的组成：</p>
<p><img src="/images/36/36_2.png" alt="36_2"></p>
<p><strong>栈帧</strong>:是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>
<p>每个栈帧中包括：</p>
<ol>
<li><strong>局部变量表</strong>:用来存储方法中的局部变量（非静态变量、函数形参）。当变量为基本数据类型时，直接存储值，当变量为引用类型时，存储的是指向具体对象的引用。</li>
<li><strong>操作数栈</strong>:Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，其中所指的栈就是指操作数栈。</li>
<li><strong>指向运行时常量池的引用</strong>:存储程序执行时可能用到常量的引用。</li>
<li><strong>方法返回地址</strong>:存储方法执行完成后的返回地址。</li>
</ol>
<h3 id="2-堆"><a href="#2-堆" class="headerlink" title="2.堆"></a>2.堆</h3><p>堆是用来存储对象本身和数组的，在JVM中只有一个堆，因此，堆是被所有线程共享的。</p>
<h3 id="3-方法区"><a href="#3-方法区" class="headerlink" title="3.方法区"></a>3.方法区</h3><p>方法区是一块所有线程共享的内存逻辑区域，在JVM中只有一个方法区，用来存储一些线程可共享的内容，它是线程安全的，多个线程同时访问方法区中同一个内容时，只能有一个线程装载该数据，其它线程只能等待。</p>
<p>方法区可存储的内容有：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、常量池（字段，方法信息，静态变量，类型引用（class））等。</p>
<h3 id="4-本地方法栈："><a href="#4-本地方法栈：" class="headerlink" title="4.本地方法栈："></a>4.本地方法栈：</h3><p>本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。</p>
<h3 id="5-程序计数器"><a href="#5-程序计数器" class="headerlink" title="5. 程序计数器"></a>5. 程序计数器</h3><p>线程私有的。<br>记录着当前线程所执行的字节码的行号指示器，在程序运行过程中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p>
<h2 id="四、数据如何在内存中存储"><a href="#四、数据如何在内存中存储" class="headerlink" title="四、数据如何在内存中存储"></a>四、数据如何在内存中存储</h2><p>从上面程序运行图我们可以看到，JVM在程序运行时的内存分配有三个地方：</p>
<ul>
<li>堆</li>
<li>栈</li>
<li>静态方法区</li>
<li>常量区</li>
</ul>
<p>相应地，每个存储区域都有自己的内存分配策略：</p>
<ul>
<li>堆式</li>
<li>栈式</li>
<li>静态</li>
</ul>
<p>我们已经知道：Java中的数据类型有基本数据类型和引用数据类型，那么这些数据的存储都使用哪一种策略呢？<br>这里要分以下的情况进行探究：</p>
<p><strong>1.基本数据类型的存储：</strong></p>
<ul>
<li>A、基本数据类型的局部变量</li>
<li>B、基本数据类型的成员变量</li>
<li>C、基本数据类型的静态变量</li>
</ul>
<p><strong>2、引用数据类型的存储</strong></p>
<h4 id="1-基本数据类型的存储"><a href="#1-基本数据类型的存储" class="headerlink" title="1.基本数据类型的存储"></a>1.基本数据类型的存储</h4><p>我们分别来研究一下：</p>
<p><strong>A.基本数据类型的局部变量</strong></p>
<p>1.定义基本数据类型的局部变量以及数据都是直接存储在内存中的栈上，也就是前面说到的<strong>“虚拟机栈”</strong>，数据本身的值就是存储在栈空间里面。</p>
<p><img src="/images/36/36_3.png" alt="36_3"></p>
<p>如上图，在方法内定义的变量直接存储在栈中，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int age&#x3D;50;</span><br><span class="line">int weight&#x3D;50;</span><br><span class="line">int grade&#x3D;6;</span><br></pre></td></tr></table></figure>

<p>当我们写“int age=50；”，其实是分为两步的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int age;&#x2F;&#x2F;定义变量</span><br><span class="line">age&#x3D;50;&#x2F;&#x2F;赋值</span><br></pre></td></tr></table></figure>

<p>首先JVM创建一个名为age的变量，存于局部变量表中，然后去栈中查找是否存在有字面量值为50的内容，如果有就直接把age指向这个地址，如果没有，JVM会在栈中开辟一块空间来存储“50”这个内容，并且把age指向这个地址。因此我们可以知道：<br><strong>我们声明并初始化基本数据类型的局部变量时，变量名以及字面量值都是存储在栈中，而且是真实的内容。</strong></p>
<p>我们再来看“int weight=50；”，按照刚才的思路：字面量为50的内容在栈中已经存在，因此weight是直接指向这个地址的。由此可见：<strong>栈中的数据在当前线程下是共享的</strong>。</p>
<p>那么如果再执行下面的代码呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weight&#x3D;40；</span><br></pre></td></tr></table></figure>

<p>当代码中重新给weight变量进行赋值时，JVM会去栈中寻找字面量为40的内容，发现没有，就会开辟一块内存空间存储40这个内容，并且把weight指向这个地址。由此可知：</p>
<p><strong>基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存存新数据，并且把要重新赋值的局部变量的引用指向新数据所在地址。</strong></p>
<p><strong>B.</strong>基本数据类型的成员变量****</p>
<p>成员变量：顾名思义，就是在类体中定义的变量。<br>看下图：</p>
<p><img src="/images/36/36_4.jpg" alt="36_4"></p>
<p>我们看per的地址指向的是堆内存中的一块区域，我们来还原一下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">	private int age;</span><br><span class="line">	private String name;</span><br><span class="line">	private int grade;</span><br><span class="line">	&#x2F;&#x2F;篇幅较长，省略setter getter方法</span><br><span class="line">	static void run()&#123;</span><br><span class="line">	System.out.println(&quot;run....&quot;); </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">Person per&#x3D;new Person();</span><br></pre></td></tr></table></figure>

<p>同样是局部变量的age、name、grade却被存储到了堆中为per对象开辟的一块空间中。因此可知：<strong>基本数据类型的成员变量名和值都存储于堆中，其生命周期和对象的是一致的。</strong></p>
<h5 id="C-基本数据类型的静态变量"><a href="#C-基本数据类型的静态变量" class="headerlink" title="C. 基本数据类型的静态变量"></a><strong>C. 基本数据类型的静态变量</strong></h5><p>前面提到<strong>方法区</strong>用来存储一些共享数据，因此<strong>基本数据类型的静态变量名以及值存储于方法区的运行时常量池中，静态变量随类加载而加载，随类消失而消失</strong></p>
<h4 id="2-引用数据类型的存储"><a href="#2-引用数据类型的存储" class="headerlink" title="2.引用数据类型的存储"></a>2.引用数据类型的存储</h4><p>上面提到：堆是用来存储对象本身和数组，而引用（句柄）存放的是实际内容的地址值，因此通过上面的程序运行图，也可以看出，当我们定义一个对象时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person per&#x3D;new Person();</span><br></pre></td></tr></table></figure>

<p>实际上，它也是有两个过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person per;&#x2F;&#x2F;定义变量</span><br><span class="line">per&#x3D;new Person();&#x2F;&#x2F;赋值</span><br></pre></td></tr></table></figure>

<p>在执行Person per;时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=new Person()时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。因此可见：<br><strong>对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。</strong></p>
<h2 id="6-值传递和引用传递"><a href="#6-值传递和引用传递" class="headerlink" title="6.值传递和引用传递"></a>6.值传递和引用传递</h2><p>前面已经介绍过形参和实参，也介绍了数据类型以及数据在内存中的存储形式，接下来，就是文章的主题：值传递和引用的传递。</p>
<p><strong>值传递：</strong></p>
<p>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</p>
<p>来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void valueCrossTest(int age,float weight)&#123;</span><br><span class="line">    System.out.println(&quot;传入的age：&quot;+age);</span><br><span class="line">    System.out.println(&quot;传入的weight：&quot;+weight);</span><br><span class="line">    age&#x3D;33;</span><br><span class="line">    weight&#x3D;89.5f;</span><br><span class="line">    System.out.println(&quot;方法内重新赋值后的age：&quot;+age);</span><br><span class="line">    System.out.println(&quot;方法内重新赋值后的weight：&quot;+weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int a&#x3D;25;</span><br><span class="line">        float w&#x3D;77.5f;</span><br><span class="line">        valueCrossTest(a,w);</span><br><span class="line">        System.out.println(&quot;方法执行后的age：&quot;+a);</span><br><span class="line">        System.out.println(&quot;方法执行后的weight：&quot;+w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传入的age：25</span><br><span class="line">传入的weight：77.5</span><br><span class="line"></span><br><span class="line">方法内重新赋值后的age：33</span><br><span class="line">方法内重新赋值后的weight：89.5</span><br><span class="line"></span><br><span class="line">方法执行后的age：25</span><br><span class="line">方法执行后的weight：77.5</span><br></pre></td></tr></table></figure>

<p>从上面的打印结果可以看到：<br>a和w作为实参传入valueCrossTest之后，无论在方法内做了什么操作，最终a和w都没变化。</p>
<p>这是什么造型呢？！！</p>
<p>下面我们根据上面学到的知识点，进行详细的分析：</p>
<p>首先程序运行时，调用mian()方法，此时JVM为main()方法往虚拟机栈中压入一个栈帧，即为当前栈帧，用来存放main()中的局部变量表(包括参数)、操作栈、方法出口等信息，如a和w都是mian()方法中的局部变量，因此可以断定，a和w是躺着mian方法所在的栈帧中<br>如图：</p>
<p><img src="/images/36/36_5.png" alt="36_5"></p>
<p>而当执行到valueCrossTest()方法时，JVM也为其往虚拟机栈中压入一个栈，即为当前栈帧，用来存放valueCrossTest()中的局部变量等信息，因此age和weight是躺着valueCrossTest方法所在的栈帧中，而他们的值是从a和w的值copy了一份副本而得，如图：</p>
<p><img src="/images/36/36_6.png" alt="36_6"></p>
<p>因而可以a和age、w和weight对应的内容是不一致的，所以当在方法内重新赋值时，实际流程如图：</p>
<p><img src="/images/36/36_7.png" alt="36_7"></p>
<p>也就是说，age和weight的改动，只是改变了当前栈帧（valueCrossTest方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，mian方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。<br>因此：<br><strong>值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。</strong></p>
<p><strong>引用传递：</strong><br>”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。</p>
<p>举个例子：<br>先定义一个对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">        public int getAge() &#123;</span><br><span class="line">            return age;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setAge(int age) &#123;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写个函数测试一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void PersonCrossTest(Person person)&#123;</span><br><span class="line">        System.out.println(&quot;传入的person的name：&quot;+person.getName());</span><br><span class="line">        person.setName(&quot;我是张小龙&quot;);</span><br><span class="line">        System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;测试</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Person p&#x3D;new Person();</span><br><span class="line">        p.setName(&quot;我是马化腾&quot;);</span><br><span class="line">        p.setAge(45);</span><br><span class="line">        PersonCrossTest(p);</span><br><span class="line">        System.out.println(&quot;方法执行后的name：&quot;+p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传入的person的name：我是马化腾</span><br><span class="line">方法内重新赋值后的name：我是张小龙</span><br><span class="line">方法执行后的name：我是张小龙</span><br></pre></td></tr></table></figure>

<p>可以看出，person经过personCrossTest()方法的执行之后，内容发生了改变，这印证了上面所说的<strong>“引用传递”</strong>，对形参的操作，改变了实际对象的内容。</p>
<p>那么，到这里就结题了吗？<br>不是的，没那么简单，<br>能看得到想要的效果<br>是因为刚好选对了例子而已！！！</p>
<p>下面我们对上面的例子稍作修改，加上一行代码，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void PersonCrossTest(Person person)&#123;</span><br><span class="line">    System.out.println(&quot;传入的person的name：&quot;+person.getName());</span><br><span class="line">    person&#x3D;new Person();&#x2F;&#x2F;加多此行代码</span><br><span class="line">    person.setName(&quot;我是张小龙&quot;);</span><br><span class="line">    System.out.println(&quot;方法内重新赋值后的name：&quot;+person.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传入的person的name：我是马化腾</span><br><span class="line">方法内重新赋值后的name：我是张小龙</span><br><span class="line">方法执行后的name：我是马化腾</span><br></pre></td></tr></table></figure>

<p>为什么这次的输出和上次的不一样了呢？<br>看出什么问题了吗？</p>
<p>按照上面讲到JVM内存模型可以知道，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到main（）方法中的下列代码时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p&#x3D;new Person();</span><br><span class="line">p.setName(&quot;我是马化腾&quot;);</span><br><span class="line">p.setAge(45);</span><br><span class="line">PersonCrossTest(p);</span><br></pre></td></tr></table></figure>

<p>JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：</p>
<p><img src="/images/36/36_8.png" alt="36_8"></p>
<p>当执行到PersonCrossTest()方法时，因为方法内有这么一行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person&#x3D;new Person();</span><br></pre></td></tr></table></figure>

<p>JVM需要在堆内另外开辟一块内存来存储new Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：<strong>引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变</strong>。</p>
<p>可以推出：实参也应该指向了新创建的person对象的地址，所以在执行PersonCrossTest()结束之后，最终输出的应该是后面创建的对象内容。</p>
<p>然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。</p>
<p>由此可见：<strong>引用传递，在Java中并不存在。</strong></p>
<p>但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？</p>
<p>这是因为：<strong>无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。</strong></p>
<p><img src="/images/36/36_9.png" alt="36_9"></p>
<p>有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：</p>
<p><strong>p和person都是指向同一个对象</strong>。</p>
<p>因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。而在第二个例子中，当执行到new Person()之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：</p>
<p><strong>p依旧是指向旧的对象，person指向新对象的地址。</strong></p>
<p>所以此时<strong>对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系</strong>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>因此可见：在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。<br>只是在传递过程中：</p>
<p><strong>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</strong></p>
<p><strong>如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</strong></p>
<p>以上为小编关于“值传递和引用传递”问题的思考和论证，对于这个问题，历来都是多有争论，在此希望和读者一起探讨和学习，有不同意见或者建议请假小编微信：sisi-ceo。理性评论，不喜勿喷。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集简述</title>
    <url>/2020/02/10/34.%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> par[MAX_N];</span><br><span class="line"><span class="keyword">int</span> rank[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化n个元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		par[i] = i;</span><br><span class="line">		rank[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询树的根 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(par[x] == x)&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并x和y所属的集合 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	x = <span class="built_in">find</span>(x);</span><br><span class="line">	y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(rank[x] &lt; rank[y])&#123;</span><br><span class="line">		par[x] = y;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		par[y] = x;</span><br><span class="line">		<span class="keyword">if</span>(rank[x] == rank[y]) rank[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断x和y是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Eratosthenes 素数筛选</title>
    <url>/2020/02/10/33.Eratosthenes%20%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89/</url>
    <content><![CDATA[<h3 id="Eratosthenes-素数筛选"><a href="#Eratosthenes-素数筛选" class="headerlink" title="Eratosthenes 素数筛选"></a>Eratosthenes 素数筛选</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j +=i) &#123;</span><br><span class="line">             is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后时间复杂度比O(NloglogN)还要低</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>linux上的maven安装</title>
    <url>/2020/02/09/32.linux%E4%B8%8A%E7%9A%84maven%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>官网下载链接：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p>
<p>下载后我放置在服务器用户根目录的software文件夹下，现在我们解压到app下面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -zxvf apache-maven-3.6.3-bin.tar.gz -C ~&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure>

<p>在app文件夹下，开始操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入maven文件夹</span><br><span class="line"># cd apache-maven-3.6.3&#x2F;</span><br><span class="line">pwd获取当前的路径</span><br><span class="line"># vi ~&#x2F;.bash_profile</span><br><span class="line">export MAVEN_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;apache-maven-3.6.3</span><br><span class="line">export PATH&#x3D;$MAVEN_HOME&#x2F;bin:$PATH</span><br><span class="line"># source ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line">可以通过mvn -v检查是否生效</span><br></pre></td></tr></table></figure>



<p>完成后，conf内有些数据建议更改一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd conf</span><br><span class="line"># vi settings.xml</span><br><span class="line">  &lt;!-- localRepository</span><br><span class="line">   | The path to the local repository maven will use to store artifacts.</span><br><span class="line">   |</span><br><span class="line">   | Default: $&#123;user.home&#125;&#x2F;.m2&#x2F;repository</span><br><span class="line">  &lt;localRepository&gt;&#x2F;path&#x2F;to&#x2F;local&#x2F;repo&lt;&#x2F;localRepository&gt;</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;localRepository&gt;&#x2F;home&#x2F;pearfl&#x2F;maven_repos&#x2F;&lt;&#x2F;localRepository&gt;</span><br></pre></td></tr></table></figure>

<p>/root/maven_repos/ 位置存放你下载的包，这个根据个人需求修改</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>ETL简述</title>
    <url>/2020/02/09/31.ETL%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<p><img src="/images/31/31_1.png" alt="31_1"></p>
<h2 id="为什么要进行ETL"><a href="#为什么要进行ETL" class="headerlink" title="为什么要进行ETL"></a>为什么要进行ETL</h2><p>我们使用Flume采集数据到HDFS，从系统架构图来看现在要进行数据的ETL操作，ETL进程对数据进行规范化、验证、清洗，并最终装载进入数据仓库</p>
<h2 id="什么是ETL"><a href="#什么是ETL" class="headerlink" title="什么是ETL"></a>什么是ETL</h2><p>ETL 即 Extract Transform Load的首字母 ==&gt; 抽取、转换、加载</p>
<h2 id="ETL该怎么做"><a href="#ETL该怎么做" class="headerlink" title="ETL该怎么做"></a>ETL该怎么做</h2><p>数据采集到HDFS上指定的目录下，通过MR写入数据，进行ETL操作，并写出到指定的目录下，ETL操作包括定义数据字段的序列化类，把时间解析出年月日，把URL解析为http、domain和path、对异常值进行处理(try/catch)，使用计数器。</p>
<h2 id="ETL在服务器上运行需要解决的问题"><a href="#ETL在服务器上运行需要解决的问题" class="headerlink" title="ETL在服务器上运行需要解决的问题"></a>ETL在服务器上运行需要解决的问题</h2><p>在本地测试好代码后，上传Jar包到服务器上，跑HDFS上的数据</p>
<p>首先创建三个文件夹lib、data、script放ETL相关的文件，运行脚本的shell文件就在script目录下</p>
<p>由于我们把ETL打的瘦包，所以很多数据需要的依赖Jar包得不到，还有解析库的数据库也需要上传到本地文件下</p>
<p>思路是:</p>
<ol>
<li>把解析库放到项目的resources目录下</li>
<li>把需要的依赖上传到lib目录下</li>
<li>在<code>~/.bash_profile</code>文件下导入LIBJARS路径用来指向lib目录下的依赖</li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>ETL</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-962（单调栈）</title>
    <url>/2020/02/09/30.leetcode-962%EF%BC%88%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 A，坡是元组 (i, j)，其中  i &lt; j 且 A[i] &lt;&#x3D; A[j]。这样的坡的宽度为 j - i。</span><br><span class="line"></span><br><span class="line">找出 A 中的坡的最大宽度，如果不存在，返回 0 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;maximum-width-ramp</span><br><span class="line"></span><br><span class="line">实例1：</span><br><span class="line">输入：[6,0,8,2,1,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">最大宽度的坡为 (i, j) &#x3D; (1, 5): A[1] &#x3D; 0 且 A[5] &#x3D; 5.</span><br><span class="line"></span><br><span class="line">实例2：</span><br><span class="line">输入：[9,8,1,0,1,9,4,0,4,1]</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">最大宽度的坡为 (i, j) &#x3D; (2, 9): A[2] &#x3D; 1 且 A[9] &#x3D; 1.</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1.	2 &lt;&#x3D; A.length &lt;&#x3D; 50000</span><br><span class="line">2.	0 &lt;&#x3D; A[i] &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>



<p>思路：找到当前元素左边第一个比它小的元素，很明显采用单调栈的方法</p>
<p>单调栈应用范围：<br>求解数组中元素右边第一个比它小的元素的下标，从前往后，构造单调递增栈；<br>求解数组中元素右边第一个比它大的元素的下标，从前往后，构造单调递减栈；<br>求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递减栈；<br>求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递增栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stacks = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stacks.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> length = A.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt;= A[stacks.peek()]) &#123;</span><br><span class="line">                stacks.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stacks.isEmpty() &amp;&amp; A[i] &gt;= A[stacks.peek()]) &#123;</span><br><span class="line">                max = Math.max(max, i - stacks.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>mapreduce解析json数据</title>
    <url>/2020/02/09/29.mapreduce%E8%A7%A3%E6%9E%90json%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入数据</span><br><span class="line">&#123;&quot;status&quot;:&quot;0&quot;,&quot;message&quot;:&quot;成功&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;mxh&quot; , &quot;age&quot;:22 , &quot;cars&quot;:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Porsche&quot;&#125;,&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;BMW&quot;&#125;]&#125;&#125;</span><br><span class="line">&#123;&quot;status&quot;:&quot;0&quot;,&quot;message&quot;:&quot;成功&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;mxh&quot; , &quot;age&quot;:22 , &quot;cars&quot;:[ &quot;Porsche&quot;, &quot;BMW&quot;, &quot;Volvo&quot; ]&#125;&#125;</span><br><span class="line">&#123;&quot;status&quot;:&quot;0&quot;,&quot;message&quot;:&quot;成功&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;mxh&quot; , &quot;age&quot;:22 , &quot;male&quot;:true&#125;&#125;</span><br><span class="line"></span><br><span class="line">输出数据</span><br><span class="line">0	成功	mxh	22	1	Porsche	2	BMW	</span><br><span class="line">0	成功	mxh	22	Porsche	BMW	Volvo	</span><br><span class="line">0	成功	mxh	22	true</span><br></pre></td></tr></table></figure>

<p>解析采用jackson</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String input = <span class="string">"data/json/data.txt"</span>;</span><br><span class="line">        String output = <span class="string">"out"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1:获取job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除已存在目录</span></span><br><span class="line">        FileUtils.deleteOutput(configuration,output);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2：本job对应执行的主类</span></span><br><span class="line">        job.setJarByClass(JsonDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3）设置Mapper</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4）设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5）设置输入和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6）提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">NullWritable</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key,Text values,Context context)</span> <span class="keyword">throws</span> IOException,InterruptedException</span>&#123;</span><br><span class="line">            String str = values.toString();</span><br><span class="line">            String out = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            JsonNode root = mapper.readTree(str);</span><br><span class="line"></span><br><span class="line">            Iterator&lt;JsonNode&gt; elements = root.elements();</span><br><span class="line">            out = dfs(elements, out);</span><br><span class="line">            out = out.replace(<span class="string">"\""</span>,<span class="string">""</span>);</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(out),NullWritable.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dfs</span><span class="params">(Iterator&lt;JsonNode&gt; elements, String out)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(elements.hasNext())&#123;</span><br><span class="line">            JsonNode node = elements.next();</span><br><span class="line">            <span class="keyword">if</span>(node.isObject())&#123;</span><br><span class="line">                Iterator&lt;JsonNode&gt; e = node.elements();</span><br><span class="line">                out = dfs(e, out);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.isArray())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;node.size();i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(node.get(i).isObject())&#123;</span><br><span class="line">                        Iterator&lt;JsonNode&gt; e2 = node.elements();</span><br><span class="line">                        out = dfs(e2, out);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        out = out + node.get(i) + <span class="string">'\t'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                out = out + node.toString() + <span class="string">'\t'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>mapreduce</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈jackson</title>
    <url>/2020/02/08/28.%E6%B5%85%E8%B0%88jackson/</url>
    <content><![CDATA[<p>官方文档：<a href="https://github.com/FasterXML/jackson-docs" target="_blank" rel="noopener">https://github.com/FasterXML/jackson-docs</a></p>
<p>Jackson是当前用的比较广泛的，用来序列化和反序列化json的Java开源框架。Jackson社区相对比较活跃，更新速度也比较快， 从Github中的统计来看，Jackson是最流行的json解析器之一，Spring MVC的默认json解析器便是Jackson。</p>
<p>Jackson优点很多：</p>
<ol>
<li><p>Jackson 所依赖的jar包较少，简单易用。</p>
</li>
<li><p>与其他 Java 的 json 的框架 Gson 等相比，Jackson 解析大的 json 文件速度比较快。</p>
</li>
<li><p>Jackson 运行时占用内存比较低，性能比较好</p>
</li>
<li><p>Jackson 有灵活的 API，可以很容易进行扩展和定制。</p>
</li>
</ol>
<p>Jackson 的核心模块由三部分组成：</p>
<ol>
<li>jackson-core 核心包，提供基于”流模式”解析的相关 API，它包括 JsonPaser 和 JsonGenerator。Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json。</li>
<li>jackson-annotations 注解包，提供标准注解功能；</li>
<li>jackson-databind 数据绑定包，提供基于”对象绑定” 解析的相关 API（ ObjectMapper ）和”树模型” 解析的相关 API（JsonNode）；基于”对象绑定” 解析的 API 和”树模型”解析的 API 依赖基于”流模式”解析的 API。</li>
</ol>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊正则表达式</title>
    <url>/2020/02/07/27.%E8%81%8A%E8%81%8A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则学习文章推荐（本篇博文为转载）：<a href="https://github.com/cdoco/learn-regex-zh" target="_blank" rel="noopener">https://github.com/cdoco/learn-regex-zh</a></p>
<p>正则表达式测试工具：<a href="https://c.runoob.com/front-end/854" target="_blank" rel="noopener">https://c.runoob.com/front-end/854</a></p>
<h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h2><p>正则表达式只是我们用于在文本中检索字母和数字的模式。例如正则表达式 <code>cat</code>，表示: 字母 <code>c</code> 后面跟着一个字母 <code>a</code>，再后面跟着一个字母 <code>t</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;cat&quot; &#x3D;&gt; The cat sat on the mat</span><br></pre></td></tr></table></figure>

<p>正则表达式 <code>123</code> 会匹配字符串 “123”。通过将正则表达式中的每个字符逐个与要匹配的字符串中的每个字符进行比较，来完成正则匹配。 正则表达式通常区分大小写，因此正则表达式 <code>Cat</code> 与字符串 “cat” 不匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Cat&quot; &#x3D;&gt; The cat sat on the Cat</span><br></pre></td></tr></table></figure>

<h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><p>元字符是正则表达式的基本组成元素。元字符在这里跟它通常表达的意思不一样，而是以某种特殊的含义去解释。有些元字符写在方括号内的时候有特殊含义。 元字符如下:</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的任意字符。</td>
</tr>
<tr>
<td>[ ]</td>
<td>字符类，匹配方括号中包含的任意字符。</td>
</tr>
<tr>
<td>[^ ]</td>
<td>否定字符类。匹配方括号中不包含的任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>花括号，匹配前面字符至少 n 次，但是不超过 m 次。</td>
</tr>
<tr>
<td>(xyz)</td>
<td>字符组，按照确切的顺序匹配字符xyz。</td>
</tr>
<tr>
<td>|</td>
<td>分支结构，匹配符号之前的字符或后面的字符。</td>
</tr>
<tr>
<td>\</td>
<td>转义符，它可以还原元字符原来的含义，允许你匹配保留字符 `[ ] ( ) { } . * + ? ^ $ \</td>
</tr>
<tr>
<td>^</td>
<td>匹配行的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配行的结束</td>
</tr>
</tbody></table>
<h2 id="2-1-英文句号"><a href="#2-1-英文句号" class="headerlink" title="2.1 英文句号"></a>2.1 英文句号</h2><p>英文句号 <code>.</code> 是元字符的最简单的例子。元字符 <code>.</code> 可以匹配任意单个字符。它不会匹配换行符和新行的字符。例如正则表达式 <code>.ar</code>，表示: 任意字符后面跟着一个字母 <code>a</code>， 再后面跟着一个字母 <code>r</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;.ar&quot; &#x3D;&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>

<h2 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h2><p>字符集也称为字符类。方括号被用于指定字符集。使用字符集内的连字符来指定字符范围。方括号内的字符范围的顺序并不重要。 例如正则表达式 <code>[Tt]he</code>，表示: 大写 <code>T</code> 或小写 <code>t</code> ，后跟字母 <code>h</code>，再后跟字母 <code>e</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[Tt]he&quot; &#x3D;&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>

<p>然而，字符集中的英文句号表示它字面的含义。正则表达式 <code>ar[.]</code>，表示小写字母 <code>a</code>，后面跟着一个字母 <code>r</code>，再后面跟着一个英文句号 <code>.</code> 字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;ar[.]&quot; &#x3D;&gt; A garage is a good place to park a car.</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h3><p>一般来说插入字符 <code>^</code> 表示一个字符串的开始，但是当它在方括号内出现时，它会取消字符集。例如正则表达式 <code>[^c]ar</code>，表示: 除了字母 <code>c</code> 以外的任意字符，后面跟着字符 <code>a</code>， 再后面跟着一个字母 <code>r</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[^c]ar&quot; &#x3D;&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>

<h2 id="2-3-重复"><a href="#2-3-重复" class="headerlink" title="2.3 重复"></a>2.3 重复</h2><p>以下元字符 <code>+</code>，<code>*</code> 或 <code>?</code> 用于指定子模式可以出现多少次。这些元字符在不同情况下的作用不同。</p>
<h3 id="2-3-1-星号"><a href="#2-3-1-星号" class="headerlink" title="2.3.1 星号"></a>2.3.1 星号</h3><p>该符号 <code>*</code> 表示匹配上一个匹配规则的零次或多次。正则表达式 <code>a*</code> 表示小写字母 <code>a</code> 可以重复零次或者多次。但是它如果出现在字符集或者字符类之后，它表示整个字符集的重复。 例如正则表达式 <code>[a-z]*</code>，表示: 一行中可以包含任意数量的小写字母。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[a-z]*&quot; &#x3D;&gt; The car parked in the garage #21.</span><br></pre></td></tr></table></figure>

<p>该 <code>*</code> 符号可以与元符号 <code>.</code> 用在一起，用来匹配任意字符串 <code>.*</code>。该 <code>*</code> 符号可以与空格符 <code>\s</code> 一起使用，用来匹配一串空格字符。 例如正则表达式 <code>\s*cat\s*</code>，表示: 零个或多个空格，后面跟小写字母 <code>c</code>，再后面跟小写字母 <code>a</code>，再再后面跟小写字母 <code>t</code>，后面再跟零个或多个空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;\s*cat\s*&quot; &#x3D;&gt; The fat cat sat on the cat.</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-加号"><a href="#2-3-2-加号" class="headerlink" title="2.3.2 加号"></a>2.3.2 加号</h3><p>该符号 <code>+</code> 匹配上一个字符的一次或多次。例如正则表达式 <code>c.+t</code>，表示: 一个小写字母 <code>c</code>，后跟任意数量的字符，后跟小写字母 <code>t</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;c.+t&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-问号"><a href="#2-3-3-问号" class="headerlink" title="2.3.3 问号"></a>2.3.3 问号</h3><p>在正则表达式中，元字符 <code>?</code> 用来表示前一个字符是可选的。该符号匹配前一个字符的零次或一次。 例如正则表达式 <code>[T]?he</code>，表示: 可选的大写字母 <code>T</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[T]he&quot; &#x3D;&gt; The car is parked in the garage.</span><br><span class="line">&quot;[T]?he&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h2 id="2-4-花括号"><a href="#2-4-花括号" class="headerlink" title="2.4 花括号"></a>2.4 花括号</h2><p>在正则表达式中花括号(也被称为量词 ?)用于指定字符或一组字符可以重复的次数。例如正则表达式 <code>[0-9]{2,3}</code>，表示: 匹配至少2位数字但不超过3位(0到9范围内的字符)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,3&#125;&quot; &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>

<p>我们可以省略第二个数字。例如正则表达式 <code>[0-9]{2,}</code>，表示: 匹配2个或更多个数字。如果我们也删除逗号，则正则表达式 <code>[0-9]{2}</code>，表示: 匹配正好为2位数的数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,&#125;&quot; &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br><span class="line">&quot;[0-9]&#123;2&#125;&quot; &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>

<h2 id="2-5-字符组"><a href="#2-5-字符组" class="headerlink" title="2.5 字符组"></a>2.5 字符组</h2><p>字符组是一组写在圆括号内的子模式 <code>(...)</code>。正如我们在正则表达式中讨论的那样，如果我们把一个量词放在一个字符之后，它会重复前一个字符。 但是，如果我们把量词放在一个字符组之后，它会重复整个字符组。 例如正则表达式 <code>(ab)*</code> 表示匹配零个或多个的字符串 “ab”。我们还可以在字符组中使用元字符 <code>|</code>。例如正则表达式 <code>(c|g|p)ar</code>，表示: 小写字母 <code>c</code>、<code>g</code> 或 <code>p</code> 后面跟字母 <code>a</code>，后跟字母 <code>r</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(c|g|p)ar&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h2 id="2-6-分支结构"><a href="#2-6-分支结构" class="headerlink" title="2.6 分支结构"></a>2.6 分支结构</h2><p>在正则表达式中垂直条 <code>|</code> 用来定义分支结构，分支结构就像多个表达式之间的条件。现在你可能认为这个字符集和分支机构的工作方式一样。 但是字符集和分支结构巨大的区别是字符集只在字符级别上有作用，然而分支结构在表达式级别上依然可以使用。 例如正则表达式 <code>(T|t)he|car</code>，表示: 大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code> 或小写字母 <code>c</code>，后跟小写字母 <code>a</code>，后跟小写字母 <code>r</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he|car&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h2 id="2-7-转义特殊字符"><a href="#2-7-转义特殊字符" class="headerlink" title="2.7 转义特殊字符"></a>2.7 转义特殊字符</h2><p>正则表达式中使用反斜杠 <code>\</code> 来转义下一个字符。这将允许你使用保留字符来作为匹配字符 <code>{ } [ ] / \ + * . $ ^ | ?</code>。在特殊字符前面加 <code>\</code>，就可以使用它来做匹配字符。 例如正则表达式 <code>.</code> 是用来匹配除了换行符以外的任意字符。现在要在输入字符串中匹配 <code>.</code> 字符，正则表达式 <code>(f|c|m)at\.?</code>，表示: 小写字母 <code>f</code>、<code>c</code> 或者 <code>m</code> 后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟可选的 <code>.</code> 字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(f|c|m)at\.?&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h2 id="2-8-定位符"><a href="#2-8-定位符" class="headerlink" title="2.8 定位符"></a>2.8 定位符</h2><p>在正则表达式中，为了检查匹配符号是否是起始符号或结尾符号，我们使用定位符。 定位符有两种类型: 第一种类型是 <code>^</code> 检查匹配字符是否是起始字符，第二种类型是 <code>$</code>，它检查匹配字符是否是输入字符串的最后一个字符。</p>
<h3 id="2-8-1-插入符号"><a href="#2-8-1-插入符号" class="headerlink" title="2.8.1 插入符号"></a>2.8.1 插入符号</h3><p>插入符号 <code>^</code> 符号用于检查匹配字符是否是输入字符串的第一个字符。如果我们使用正则表达式 <code>^a</code> (如果a是起始符号)匹配字符串 <code>abc</code>，它会匹配到 <code>a</code>。 但是如果我们使用正则表达式 <code>^b</code>，它是匹配不到任何东西的，因为在字符串 <code>abc</code> 中 “b” 不是起始字符。 让我们来看看另一个正则表达式 <code>^(T|t)he</code>，这表示: 大写字母 <code>T</code> 或小写字母 <code>t</code> 是输入字符串的起始符号，后面跟着小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he&quot; &#x3D;&gt; The car is parked in the garage.</span><br><span class="line">&quot;^(T|t)he&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>

<h3 id="2-8-2-美元符号"><a href="#2-8-2-美元符号" class="headerlink" title="2.8.2 美元符号"></a>2.8.2 美元符号</h3><p>美元 <code>$</code> 符号用于检查匹配字符是否是输入字符串的最后一个字符。例如正则表达式 <code>(at\.)$</code>，表示: 小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟一个 <code>.</code> 字符，且这个匹配器必须是字符串的结尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(at\.)&quot; &#x3D;&gt; The fat cat. sat. on the mat.</span><br><span class="line">&quot;(at\.)$&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式为常用的字符集和常用的正则表达式提供了简写。简写字符集如下:</p>
<table>
<thead>
<tr>
<th>简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配所有字母和数字的字符: <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母和数字的字符: <code>[^\w]</code></td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字: <code>[0-9]</code></td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字: <code>[^\d]</code></td>
</tr>
<tr>
<td>\s</td>
<td>匹配空格符: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空格符: <code>[^\s]</code></td>
</tr>
</tbody></table>
<h2 id="4-断言"><a href="#4-断言" class="headerlink" title="4. 断言"></a>4. 断言</h2><p>后行断言和先行断言有时候被称为断言，它们是特殊类型的 <strong><em>非捕获组</em></strong> (用于匹配模式，但不包括在匹配列表中)。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。 例如我们想获取输入字符串 <code>$4.44 and $10.88</code> 中带有前缀 <code>$</code> 的所有数字。我们可以使用这个正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>，表示: 获取包含 <code>.</code> 字符且前缀为 <code>$</code> 的所有数字。 以下是正则表达式中使用的断言:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>?=</td>
<td>正向先行断言</td>
</tr>
<tr>
<td>?!</td>
<td>负向先行断言</td>
</tr>
<tr>
<td>?&lt;=</td>
<td>正向后行断言</td>
</tr>
<tr>
<td>?&lt;!</td>
<td>负向后行断言</td>
</tr>
</tbody></table>
<h3 id="4-1-正向先行断言"><a href="#4-1-正向先行断言" class="headerlink" title="4.1 正向先行断言"></a>4.1 正向先行断言</h3><p>正向先行断言认为第一部分的表达式必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。 要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 <code>(?=...)</code>。先行断言表达式写在括号中的等号后面。 例如正则表达式 <code>(T|t)he(?=\sfat)</code>，表示: 匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟字母 <code>h</code>，后跟字母 <code>e</code>。 在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配 <code>The</code> 或 <code>the</code> 后面跟着 <code>fat</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he(?&#x3D;\sfat)&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="4-2-负向先行断言"><a href="#4-2-负向先行断言" class="headerlink" title="4.2 负向先行断言"></a>4.2 负向先行断言</h3><p>当我们需要从输入字符串中获取不匹配表达式的内容时，使用负向先行断言。负向先行断言的定义跟我们定义的正向先行断言一样， 唯一的区别是不是等号 <code>=</code>，我们使用否定符号 <code>!</code>，例如 <code>(?!...)</code>。 我们来看看下面的正则表达式 <code>(T|t)he(?!\sfat)</code>，表示: 从输入字符串中获取全部 <code>The</code> 或者 <code>the</code> 且不匹配 <code>fat</code> 前面加上一个空格字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he(?!\sfat)&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="4-3-正向后行断言"><a href="#4-3-正向后行断言" class="headerlink" title="4.3 正向后行断言"></a>4.3 正向后行断言</h3><p>正向后行断言是用于获取在特定模式之前的所有匹配内容。正向后行断言表示为 <code>(?&lt;=...)</code>。例如正则表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code>，表示: 从输入字符串中获取在单词 <code>The</code> 或 <code>the</code> 之后的所有 <code>fat</code> 和 <code>mat</code> 单词。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(?&lt;&#x3D;(T|t)he\s)(fat|mat)&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="4-4-负向后行断言"><a href="#4-4-负向后行断言" class="headerlink" title="4.4 负向后行断言"></a>4.4 负向后行断言</h3><p>负向后行断言是用于获取不在特定模式之前的所有匹配的内容。负向后行断言表示为 <code>(?。例如正则表达式</code>(?，表示: 在输入字符中获取所有不在 <code>The</code> 或 <code>the</code> 之后的所有单词 <code>cat</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;(?&lt;!(T|t)he\s)(cat)&quot; &#x3D;&gt; The cat sat on cat.</span><br></pre></td></tr></table></figure>

<h2 id="5-标记"><a href="#5-标记" class="headerlink" title="5. 标记"></a>5. 标记</h2><p>标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>不区分大小写: 将匹配设置为不区分大小写。</td>
</tr>
<tr>
<td>g</td>
<td>全局搜索: 搜索整个输入字符串中的所有匹配。</td>
</tr>
<tr>
<td>m</td>
<td>多行匹配: 会匹配输入字符串每一行。</td>
</tr>
</tbody></table>
<h3 id="5-1-不区分大小写"><a href="#5-1-不区分大小写" class="headerlink" title="5.1 不区分大小写"></a>5.1 不区分大小写</h3><p><code>i</code> 修饰符用于执行不区分大小写匹配。例如正则表达式 <code>/The/gi</code>，表示: 大写字母 <code>T</code>，后跟小写字母 <code>h</code>，后跟字母 <code>e</code>。 但是在正则匹配结束时 <code>i</code> 标记会告诉正则表达式引擎忽略这种情况。正如你所看到的，我们还使用了 <code>g</code> 标记，因为我们要在整个输入字符串中搜索匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;The&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br><span class="line">&quot;&#x2F;The&#x2F;gi&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="5-2-全局搜索"><a href="#5-2-全局搜索" class="headerlink" title="5.2 全局搜索"></a>5.2 全局搜索</h3><p><code>g</code> 修饰符用于执行全局匹配 (会查找所有匹配，不会在查找到第一个匹配时就停止)。 例如正则表达式 <code>/.(at)/g</code>，表示: 除换行符之外的任意字符，后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>。 因为我们在正则表达式的末尾使用了 <code>g</code> 标记，它会从整个输入字符串中找到每个匹配项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;.(at)&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br><span class="line">&quot;&#x2F;.(at)&#x2F;g&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>

<h3 id="5-3-多行匹配"><a href="#5-3-多行匹配" class="headerlink" title="5.3 多行匹配"></a>5.3 多行匹配</h3><p><code>m</code> 修饰符被用来执行多行的匹配。正如我们前面讨论过的 <code>(^, $)</code>，使用定位符来检查匹配字符是输入字符串开始或者结束。但是我们希望每一行都使用定位符，所以我们就使用 <code>m</code> 修饰符。 例如正则表达式 <code>/at(.)?$/gm</code>，表示: 小写字母 <code>a</code>，后跟小写字母 <code>t</code>，匹配除了换行符以外任意字符零次或一次。而且因为 <code>m</code> 标记，现在正则表达式引擎匹配字符串中每一行的末尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&#x2F;.at(.)?$&#x2F;&quot; &#x3D;&gt; The fat</span><br><span class="line">                cat sat</span><br><span class="line">                on the mat.</span><br><span class="line">&quot;&#x2F;.at(.)?$&#x2F;gm&quot; &#x3D;&gt; The fat</span><br><span class="line">                  cat sat</span><br><span class="line">                  on the mat.</span><br></pre></td></tr></table></figure>

<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><ul>
<li><strong>正整数</strong>: <code>^\d+$</code></li>
<li><strong>负整数</strong>: <code>^-\d+$</code></li>
<li><strong>电话号码</strong>: <code>^+?[\d\s]{3,}$</code></li>
<li><strong>电话代码</strong>: <code>^+?[\d\s]+(?[\d\s]{10,}$</code></li>
<li><strong>整数</strong>: <code>^-?\d+$</code></li>
<li><strong>用户名</strong>: <code>^[\w\d_.]{4,16}$</code></li>
<li><strong>字母数字字符</strong>: <code>^[a-zA-Z0-9]*$</code></li>
<li><strong>带空格的字母数字字符</strong>: <code>^[a-zA-Z0-9 ]*$</code></li>
<li><strong>密码</strong>: <code>^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$</code></li>
<li><strong>电子邮件</strong>: <code>^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4})*$</code></li>
<li><strong>IPv4 地址</strong>: <code>^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</code></li>
<li><strong>小写字母</strong>: <code>^([a-z])*$</code></li>
<li><strong>大写字母</strong>: <code>^([A-Z])*$</code></li>
<li><strong>网址</strong>: <code>^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\/+=%&amp;_\.~?\-]*))*$</code></li>
<li><strong>VISA 信用卡号码</strong>: <code>^(4[0-9]{12}(?:[0-9]{3})?)*$</code></li>
<li><strong>日期 (MM/DD/YYYY)</strong>: <code>^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$</code></li>
<li><strong>日期 (YYYY/MM/DD)</strong>: <code>^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$</code></li>
<li><strong>万事达信用卡号码</strong>: <code>^(5[1-5][0-9]{14})*$</code></li>
</ul>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-java基础技巧</title>
    <url>/2020/02/06/%EF%BC%8126.leetcode-java%E5%9F%BA%E7%A1%80%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>之前打算法竞赛一直是用C+STL，包括牛客网上写题练习也是用这个方式来解决的，长期习惯了以后，开始对java刷题甚至产生了排斥……但鉴于java以后肯定是要常用的，因此必须矫正这个问题</p>
<p>本篇博文讲述刷leetcode过程中采用java语言遇到的坑，明明一眼就知道该怎么写但不能用其他语言写出来就是不行啊！</p>
<p>根据自己经验，有竞赛基础的建议直接从周赛题开始摸坑=3=（倒着刷）</p>
<p>（本文长期更新）</p>
<h2 id="1-String转int、long"><a href="#1-String转int、long" class="headerlink" title="1.String转int、long"></a>1.String转int、long</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">int</span> n1 = Integer.parseInt(s);</span><br><span class="line"><span class="keyword">long</span> n2 = Long.parseLong(s);</span><br></pre></td></tr></table></figure>



<h2 id="2-StringBuffer"><a href="#2-StringBuffer" class="headerlink" title="2.StringBuffer"></a>2.StringBuffer</h2><p>StringBuffer类和String一样，也用来代表字符串，只是由于StringBuffer的内部实现方式和String不同，所以StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些.</p>
<p>StringBuffer与String有一个显著的区别：<strong>StringBuffer对象的每次修改都会改变对象自身</strong></p>
<p>StringBuffer是线程安全的，所以在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些</p>
<p>1.String转StringBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<p>2.append方法，将内容追加到StringBuffer末尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">s.append(<span class="string">"efg"</span>);</span><br><span class="line">System.out.println(s.toString());</span><br></pre></td></tr></table></figure>

<p>3.delete方法</p>
<p>deleteCharAt(int index)<br>该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。第一位为0<br>s.delete(int start,int end)<br>该方法的作用是删除指定区间以内的所有字符，包含start，不包含end索引值的区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">s.append(<span class="string">"efg"</span>);</span><br><span class="line">s.deleteCharAt(<span class="number">2</span>);</span><br><span class="line">s.delete(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(s.toString());</span><br></pre></td></tr></table></figure>

<p>4.insert方法</p>
<p>StringBuffer insert(int offset, String str)<br>该方法的作用是在StringBuffer对象中插入内容，然后形成新的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"TestString"</span>);</span><br><span class="line">sb.insert(<span class="number">4</span>,<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>

<p>5.reverse方法</p>
<p>StringBuffer reverse()<br>该方法的作用是将StringBuffer对象中的内容反转，然后形成新的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"TestString"</span>);</span><br><span class="line">sb.reverse();</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>

<p>6.setCharAt方法</p>
<p>setCharAt(int index, char ch)<br>该方法的作用是修改对象中索引值为index位置的字符为新的字符ch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"bc"</span>);</span><br><span class="line">sb.setCharAt(<span class="number">1</span>,<span class="string">'D'</span>);</span><br></pre></td></tr></table></figure>



<h2 id="3-数组排序"><a href="#3-数组排序" class="headerlink" title="3.数组排序"></a>3.数组排序</h2><p>Arrays.Sort() 快排</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arys[])</span><br><span class="line">Arrays.sort(arys[],int from,int to) &#x2F;&#x2F; 排序范围:from--&gt;to-1</span><br><span class="line">Arrays.sort(arys[],new MyComparator())</span><br><span class="line">Arrays.sort(arys[],int from,int to,new MyComparator())</span><br></pre></td></tr></table></figure>

<p>Arrays.sort()方法可对任何实现compareble接口的对象数组排序, 像Integer,String这两种引用类型都实现了compareble接口，所以这两种类型的数组都可直接使用Arrays.sort()进行排序。</p>
<p>1.数字排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, -<span class="number">23</span> &#125;;</span><br><span class="line">Arrays.sort(intArray);</span><br><span class="line"></span><br><span class="line">输出： [-<span class="number">23</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<p>2.字符串排序，先大写后小写 String[] strArray = new String[] { “z”, “a”, “C” };</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strArray = <span class="keyword">new</span> String[] &#123; <span class="string">"z"</span>, <span class="string">"a"</span>, <span class="string">"C"</span> &#125;;</span><br><span class="line">Arrays.sort(strArray);</span><br><span class="line"></span><br><span class="line">输出： [C, a, z]</span><br></pre></td></tr></table></figure>



<p>3.严格按字母表顺序排序，也就是忽略大小写排序 Case-insensitive sort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line"></span><br><span class="line">输出： [a, C, z]</span><br></pre></td></tr></table></figure>



<p>4.反向排序,Reverse-order sort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(strArray, Collections.reverseOrder());</span><br><span class="line"></span><br><span class="line">输出：[z, a, C]</span><br></pre></td></tr></table></figure>



<p>5.忽略大小写反向排序 Case-insensitive reverse-order sort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">Collections.reverse(Arrays.asList(strArray));</span><br><span class="line"></span><br><span class="line">输出： [z, C, a]</span><br></pre></td></tr></table></figure>



<p>Collections.sort模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">　　　　　　* 升序排的话就是第一个参数.compareTo(第二个参数);</span></span><br><span class="line"><span class="comment">　　　　　　* 降序排的话就是第二个参数.compareTo(第一个参数);</span></span><br><span class="line"><span class="comment">　　　　　　*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按首字母升序排</span></span><br><span class="line">        <span class="comment">// return str1.compareTo(str2);</span></span><br><span class="line">        <span class="comment">// 按第二个字母升序排</span></span><br><span class="line">        <span class="keyword">char</span> c1 = str1.charAt(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">char</span> c2 = str2.charAt(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> c1 - c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop之jps详解</title>
    <url>/2020/02/06/25.hadoop%E4%B9%8Bjps%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>jps最主要的功能使查看java接口的进程号</strong></p>
<p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有 java 进程 pid 的命令，简单实用，非常适合在 linux/unix 平台上简单察看当前java进程的一些简单情况。</p>
<p>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令</p>
<h2 id="jps常用参数"><a href="#jps常用参数" class="headerlink" title="jps常用参数"></a>jps常用参数</h2><p>1.命令jps类似于Linux下的ps，但它只用于列出Java的进程。直接运行jps不加任何参数，可以列出Java程序的进程ID以及Main函数等名称。</p>
<p>其中一个输出jps就是jps命令本身，这更加证明此命令的本质也是一个Java程序</p>
<p>2.参数-q 指定jps只输出进程ID，而不输出类的短名称</p>
<p>3.参数-m 用于输出传递给Java进程（主函数）的参数</p>
<p>4.参数-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</p>
<p>5.参数-v 可以显示传递给JVM的参数</p>
<h2 id="问题：process-information-unavailable"><a href="#问题：process-information-unavailable" class="headerlink" title="问题：process information unavailable"></a>问题：process information unavailable</h2><p>1.找到进程号jps</p>
<p>2.ps -ef|grep pid是否存在（这步很关键要做判断查看进程是否存在）</p>
<p>3.假如进程不存在，我们可以去该/tmp/hsperfdata_xxx去删除</p>
<p>4.如果存在千万别删，自己查看是不可以的，其他用户查看是可用的。</p>
<p>5不存在举例：我不知道是这个进程是属于哪个用户的我们怎么操作呢？ps -ef|grep pid查看进程号属于哪个目录删除就可了</p>
<p>6.如果存在ps -ef |grep pid 看到了用户名，su 切换过去jps一下就好了</p>
<h2 id="关于jps的一些总结"><a href="#关于jps的一些总结" class="headerlink" title="关于jps的一些总结"></a>关于jps的一些总结</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop用户启动的 .&#x2F;start-dfs.sh  jps后可以看到进程,</span><br><span class="line">root用户看到的就是5235 -- process information unavailable,</span><br><span class="line">ps -ef| grep 5235 看的到是hadoop用户的这个进程还在,</span><br><span class="line">那这个状态就是假死,因为进程还在,所以说root用户是看不到hadoop启动的jps进程,</span><br><span class="line">只有root用户启动hdfs才能看到jps下的三个进程,</span><br><span class="line"></span><br><span class="line">root 使用jps只有两种情况：</span><br><span class="line"></span><br><span class="line">第一种: 查看正常信息</span><br><span class="line">第二种: - process information unavailable</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS最常用命令及快捷键整理</title>
    <url>/2020/02/06/24.Centos%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd &#x2F;home					进入 &#39;&#x2F;home&#39; 目录</span><br><span class="line"># cd ..						返回上一级目录</span><br><span class="line"># cd ..&#x2F;..					返回上两级目录</span><br><span class="line"># cd -						返回上次所在目录</span><br><span class="line"># cp file1 file2			将file1复制为file2</span><br><span class="line"># cp -a dir1 dir2			复制一个目录</span><br><span class="line"># cp -a &#x2F;tmp&#x2F;dir1 .			复制一个目录到当前工作目录（.代表当前目录）</span><br><span class="line"># ls						查看目录中的文件</span><br><span class="line"># ls -a						显示隐藏文件</span><br><span class="line"># ls -l						显示详细信息</span><br><span class="line"># ls -lrt					按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序）</span><br><span class="line"># pwd						显示工作路径</span><br><span class="line"># mkdir dir1				创建 &#39;dir1&#39; 目录</span><br><span class="line"># mkdir dir1 dir2			同时创建两个目录</span><br><span class="line"># mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2	创建一个目录树</span><br><span class="line"># mv dir1 dir2				移动&#x2F;重命名一个目录</span><br><span class="line"># rm -f file1				删除 &#39;file1&#39;</span><br><span class="line"># rm -rf dir1				删除 &#39;dir1&#39; 目录及其子目录内容</span><br></pre></td></tr></table></figure>



<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat file1					从第一个字节开始正向查看文件的内容</span><br><span class="line"># head -2 file1				查看一个文件的前两行</span><br><span class="line"># more file1				查看一个长文件的内容</span><br><span class="line"># tac file1					从最后一行开始反向查看一个文件的内容</span><br><span class="line"># tail -3 file1				查看一个文件的最后三行</span><br></pre></td></tr></table></figure>



<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep str &#x2F;tmp&#x2F;test		在文件 &#39;&#x2F;tmp&#x2F;test&#39; 中查找 &quot;str&quot;</span><br><span class="line"># grep ^str &#x2F;tmp&#x2F;test		在文件 &#39;&#x2F;tmp&#x2F;test&#39; 中查找以 &quot;str&quot; 开始的行</span><br><span class="line"># grep [0-9] &#x2F;tmp&#x2F;test		查找 &#39;&#x2F;tmp&#x2F;test&#39; 文件中所有包含数字的行</span><br><span class="line"># grep str -r &#x2F;tmp&#x2F;*		在目录 &#39;&#x2F;tmp&#39; 及其子目录中查找 &quot;str&quot;</span><br><span class="line"># diff file1 file2			找出两个文件的不同处</span><br><span class="line"># sdiff file1 file2			以对比的方式显示两个文件的不同</span><br></pre></td></tr></table></figure>



<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find &#x2F; -name file1				从 &#39;&#x2F;&#39; 开始进入根文件系统查找文件和目录</span><br><span class="line"># find &#x2F; -user user1				查找属于用户 &#39;user1&#39; 的文件和目录</span><br><span class="line"># find &#x2F;home&#x2F;user1 -name \*.bin		在目录 &#39;&#x2F; home&#x2F;user1&#39; 中查找以 &#39;.bin&#39; 结尾的文件</span><br><span class="line"># find &#x2F;usr&#x2F;bin -type f -atime +100	查找在过去100天内未被使用过的执行文件</span><br><span class="line"># find &#x2F;usr&#x2F;bin -type f -mtime -10	查找在10天内被创建或者修改过的文件</span><br><span class="line"># locate \*.ps						寻找以 &#39;.ps&#39; 结尾的文件，先运行 &#39;updatedb&#39; 命令</span><br><span class="line"># find -name &#39;*.[ch]&#39; | xargs grep -E &#39;expr&#39;	在当前目录及其子目录所有.c和.h文件中查找 &#39;expr&#39;</span><br><span class="line"># find -type f -print0 | xargs -r0 grep -F &#39;expr&#39;	在当前目录及其子目录的常规文件中查找 &#39;expr&#39;</span><br><span class="line"># find -maxdepth 1 -type f | xargs grep -F &#39;expr&#39;	在当前目录中查找 &#39;expr&#39;</span><br></pre></td></tr></table></figure>



<h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bzip2 file1							压缩 file1</span><br><span class="line"># bunzip2 file1.bz2						解压 file1.bz2</span><br><span class="line"># gzip file1							压缩 file1</span><br><span class="line"># gzip -9 file1							最大程度压缩 file1</span><br><span class="line"># gunzip file1.gz						解压 file1.gz</span><br><span class="line"># tar -cvf archive.tar file1			把file1打包成 archive.tar</span><br><span class="line">（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数）</span><br><span class="line"># tar -cvf archive.tar file1 dir1		把 file1，dir1 打包成 archive.tar</span><br><span class="line"># tar -tf archive.tar					显示一个包中的内容</span><br><span class="line"># tar -xvf archive.tar					释放一个包</span><br><span class="line"># tar -xvf archive.tar -C &#x2F;tmp			把压缩包释放到 &#x2F;tmp目录下</span><br><span class="line"># zip file1.zip file1					创建一个zip格式的压缩包</span><br><span class="line"># zip -r file1.zip file1 dir1			把文件和目录压缩成一个zip格式的压缩包</span><br><span class="line"># unzip file1.zip						解压一个zip格式的压缩包到当前目录</span><br><span class="line"># unzip test.zip -d &#x2F;tmp&#x2F;				解压一个zip格式的压缩包到 &#x2F;tmp 目录</span><br></pre></td></tr></table></figure>



<h2 id="yum工具"><a href="#yum工具" class="headerlink" title="yum工具"></a>yum工具</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum -y install [package]				下载并安装一个rpm包</span><br><span class="line"># yum localinstall [package.rpm]		安装一个rpm包，使用你自己的软件仓库解决所有依赖关系</span><br><span class="line"># yum -y update							更新当前系统中安装的所有rpm包</span><br><span class="line"># yum update [package]					更新一个rpm包</span><br><span class="line"># yum remove [package]					删除一个rpm包</span><br><span class="line"># yum list								列出当前系统中安装的所有包</span><br><span class="line"># yum search [package]					在rpm仓库中搜寻软件包</span><br><span class="line"># yum clean [package]					清除缓存目录（&#x2F;var&#x2F;cache&#x2F;yum）下的软件包</span><br><span class="line"># yum clean headers						删除所有头文件</span><br><span class="line"># yum clean all							删除所有缓存的包和头文件</span><br></pre></td></tr></table></figure>



<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ifconfig eth0										显示一个以太网卡的配置</span><br><span class="line"># ifconfig eth0 192.168.1.1 netmask 255.255.255.0	配置网卡的IP地址</span><br><span class="line"># ifdown eth0										禁用 &#39;eth0&#39; 网络设备</span><br><span class="line"># ifup eth0											启用 &#39;eth0&#39; 网络设备</span><br><span class="line"># iwconfig eth1										显示一个无线网卡的配置</span><br><span class="line"># iwlist scan										显示无线网络</span><br><span class="line"># ip addr show										显示网卡的IP地址</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># su -						切换到root权限（与su有区别）</span><br><span class="line"># shutdown -h now			关机</span><br><span class="line"># shutdown -r now			重启</span><br><span class="line"># top						罗列使用CPU资源最多的linux任务 （输入q退出）</span><br><span class="line"># pstree					以树状图显示程序</span><br><span class="line"># man ping					查看参考手册（例如ping 命令）</span><br><span class="line"># passwd					修改密码</span><br><span class="line"># df -h						显示磁盘的使用情况</span><br><span class="line"># cal -3					显示前一个月，当前月以及下一个月的月历</span><br><span class="line"># cal 10 1988				显示指定月，年的月历</span><br><span class="line"># date --date &#39;1970-01-01 UTC 1427888888 seconds&#39;	把一相对于1970-01-01 00:00的秒数转换成时间</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive之UDF函数</title>
    <url>/2020/02/05/23.Hive%E4%B9%8BUDF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>官方文档：<a href="https://cwiki.apache.org/confluence/display/Hive/HivePlugins" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/HivePlugins</a></p>
<p>中文整理稍等~</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>数据倾斜解决方案</title>
    <url>/2020/02/04/22.%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h2><p>1.数据倾斜怎么造成的</p>
<p>mapreduce计算是将map相同的key丢到reduce，在reduce中进行聚合操作,在map和reduce中间有个shuffle操作，shuffle会将map阶段相同的key划分到reduce阶段中的一个reduce中去，数据倾斜就是数据的key 的分化严重不均，造成一部分数据很多，一部分数据很少的局面。</p>
<p>2.数据倾斜产生的问题</p>
<ul>
<li>有一个或多个reduce卡住</li>
<li>各种container报错OOM</li>
<li>读写的数据量极大，至少远远超过其它正常的reduce</li>
<li>伴随着数据倾斜，会出现任务被kill等各种诡异的表现。</li>
</ul>
<p>3.原因和解决方法</p>
<p>原因：</p>
<ul>
<li>单个值有大量记录(1.内存的限制存在，2.可能会对集群其他任务的运行产生不稳定的影响)</li>
<li>唯一值较多(单个唯一值的记录数占用内存不会超过分配给reduce的内存)</li>
</ul>
<p>解决办法:</p>
<ul>
<li><p>增加reduce个数</p>
</li>
<li><p>使用自定义partitioner</p>
</li>
<li><p>增加reduce 的jvm内存（效果不好）</p>
</li>
<li><p>map 阶段将造成倾斜的key 先分成多组加随机数并且在reduce阶段去除随机数</p>
</li>
<li><p>从业务和数据上解决数据倾斜</p>
<p>我们通过设计的角度尝试解决它</p>
<ul>
<li>数据预处理，过滤掉异常值</li>
<li>将数据打散让它的并行度变大，再汇集</li>
</ul>
</li>
</ul>
<p>平台的优化方法</p>
<ul>
<li>join 操作中，使用 map join 在 map 端就先进行 join ，免得到reduce 时卡住</li>
<li>能先进行 group 操作的时候先进行 group 操作，把 key 先进行一次 reduce,之后再进行 count 或者 distinct count 操作</li>
<li>设置map端输出、中间结果压缩</li>
</ul>
<h2 id="MRchain解决数据倾斜"><a href="#MRchain解决数据倾斜" class="headerlink" title="MRchain解决数据倾斜"></a>MRchain解决数据倾斜</h2><p>核心思想: 第一个mapredue把具有数据倾斜特性的数据加盐(随机数)，进行聚合；第二个mapreduce把第一个mapreduce的加盐结果进行去盐，再聚合，问题是两个MR IO高。</p>
<p>mr</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainFirstDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String input = <span class="string">"data/chain/data.txt"</span>;</span><br><span class="line">        String output = <span class="string">"data/chain/first"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1:获取job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除已存在目录</span></span><br><span class="line">        FileUtils.deleteOutput(configuration,output);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2：本job对应执行的主类</span></span><br><span class="line">        job.setJarByClass(ChainFirstDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3）设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(MyReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        job.setNumReduceTasks(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4）设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5）设置Reducer阶段输出数据的类型</span></span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6）设置输入和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7）提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key,Text values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String[] splits = values.toString().split(<span class="string">"\t"</span>);</span><br><span class="line">            <span class="keyword">int</span> r = random.nextInt(<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(splits[<span class="number">0</span>].trim() + <span class="string">"_"</span> + r), <span class="keyword">new</span> IntWritable(Integer.parseInt(splits[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key,Iterable&lt;IntWritable&gt;values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(IntWritable value:values)&#123;</span><br><span class="line">                sum+=value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,<span class="keyword">new</span> IntWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第二个mr</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainSecondDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        String input = <span class="string">"data/chain/first"</span>;</span><br><span class="line">        String output = <span class="string">"data/chain/second"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1:获取job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除已存在目录</span></span><br><span class="line">        FileUtils.deleteOutput(configuration,output);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2：本job对应执行的主类</span></span><br><span class="line">        job.setJarByClass(ChainFirstDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3）设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(MyReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4）设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5）设置Reducer阶段输出数据的类型</span></span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6）设置输入和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7）提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key,Text values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String[] splits = values.toString().split(<span class="string">"\t"</span>);</span><br><span class="line">            <span class="keyword">int</span> index = splits[<span class="number">0</span>].lastIndexOf(<span class="string">"_"</span>);</span><br><span class="line">            String result = splits[<span class="number">0</span>].substring(<span class="number">0</span>, index);</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(result),<span class="keyword">new</span> IntWritable(Integer.parseInt(splits[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">IntWritable</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key,Iterable&lt;IntWritable&gt; values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(IntWritable value:values)&#123;</span><br><span class="line">                sum+=value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,<span class="keyword">new</span> IntWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>FileUtils补充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteOutput</span><span class="params">(Configuration configuration, String output)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileSystem fileSystem = FileSystem.get(configuration);</span><br><span class="line">        Path path = <span class="keyword">new</span> Path(output);</span><br><span class="line">        <span class="keyword">if</span>(fileSystem.exists(path))&#123;</span><br><span class="line">            fileSystem.delete(path, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive之Join详解</title>
    <url>/2020/02/03/21.Hive%E4%B9%8BJoin%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reduce&#x2F;Shuffle&#x2F;Common Join</span><br><span class="line">	join操作是在reduce端完成的</span><br><span class="line">Map Join</span><br><span class="line">	join操作是在map端完成的</span><br></pre></td></tr></table></figure>

<p>Map Join</p>
<p>join操作是在map端完成的，无Shuffle和Reduce</p>
<p>思路：小表加载到内存中，读取大表时，读一条和内存中的数据匹配一下</p>
<p>缺点：没办法处理大数据量的表，适合打表join小表</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的字典、集合</title>
    <url>/2020/02/02/20.Python%E7%9A%84%E5%AD%97%E5%85%B8%E3%80%81%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是一种用来存放若干键值对的数据类型。</p>
<p>什么是键值对呢？<strong>键值对</strong>就是两个对象，其中一个是用来做定位的数据，叫做<strong>键</strong>（Key），另一个是要存放的数据，叫做<strong>值</strong>（Value）。在字典中，键值对作为一个整体被存放，我们可以通过键来快速获取到对应的值。</p>
<p>在 Python 中字典用花括号（<code>{}</code>）来表示，键值对以 <code>键:值</code> 的方式写入花括号中，有多个键值对时用逗号分隔。</p>
<p>如 <code>{&#39;010&#39;: &#39;beijing&#39;, &#39;021&#39;: &#39;shanghai&#39;}</code> 便是一个字典，其中包含两个键值对。</p>
<p>使用时，我们可以通过 <code>&#39;010&#39;</code> 快速查询到其对应的值是 <code>&#39;beijing&#39;</code>。这就好比现实中的一本字典一样，通过拼音或偏旁来映射一个具体的字词，以此来实现字词的快速查找，而这个拼音或偏旁就相当于 Python 字典的键，而字词就相当于 Python 字典的值，它们在字典中是映射关系。</p>
<p>Python 字典中的键是有要求的，需要是不可变的类型，如元组、字符串、数字。而字典中的值可以是任意类型。字典本身是可变的，我们可以向其中添加、删除、修改键值对。</p>
<p>因为字典不是序列，更不是有序的，所有它没有列表那样的索引，也不能保证每个键值对的存放次序。</p>
<h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h3><p>1.创建空的字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字典 &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; empty_dict &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; empty_dict</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>2.创建包含键值对的字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典 = &#123;键<span class="number">1</span>:值<span class="number">1</span>, 键<span class="number">2</span>:值<span class="number">2</span>, ..., 键N:值N&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字典键值对的添加"><a href="#字典键值对的添加" class="headerlink" title="字典键值对的添加"></a>字典键值对的添加</h3><p>1.向字典中增加键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典[键] = 值</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes[‘tianjin’] = <span class="string">'022’</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; codes</span></span><br><span class="line"><span class="string">&#123;‘beijing’: ‘010’, ‘shanghai’: ‘021’, ‘tianjin’: ‘022’&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用这种方式时，若字典中没有这个键，则会创建这个键值对；若字典中原本已有这个键，则是修改键所对应的值。</p>
<h3 id="键值对的获取"><a href="#键值对的获取" class="headerlink" title="键值对的获取"></a>键值对的获取</h3><p>1.通过键获取值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值 = 字典[键]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes[‘beijing’]</span><br><span class="line">‘<span class="number">010</span>’</span><br></pre></td></tr></table></figure>

<p>注意若键不存在则将抛出 <code>KeyError</code> 异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes[‘a’]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">     File “”, line <span class="number">1</span>, <span class="keyword">in</span></span><br><span class="line">KeyError: ‘a’</span><br></pre></td></tr></table></figure>



<p>2.通过键获取值（ <code>get</code> 方法）</p>
<p>如果通过键获取值时不希望 <code>KeyError</code> 异常抛出，可以使用 <code>get</code> 方法，若键不存在，则直接返回 <code>None</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值 = 字典.get(键)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.get(‘a’)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>返回的 <code>None</code> 代表什么都没有，所以没有任何值显示</p>
<p>也可以给 <code>get</code> 方法传递第二个参数作为默认值，使得键不存在时直接返回默认值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值 = 字典.get(键, 默认值)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.get(‘a’, ‘<span class="number">000</span>’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘<span class="number">000</span>’</span><br></pre></td></tr></table></figure>



<p>3.判断字典中是否包含某个键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 键 <span class="keyword">in</span> 字典</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘beijing’ <span class="keyword">in</span> codes</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘guangzhou’ <span class="keyword">in</span> codes</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>4.获取所有键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">键的列表 = 字典.keys()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.keys()</span><br><span class="line">dict_keys([‘beijing’, ‘shanghai’])</span><br></pre></td></tr></table></figure>

<p>获取到的所有键是以迭代器的形式存在,在这里我们可以用 <code>list()</code> 函数将迭代器转换为列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(codes.keys())</span><br><span class="line">[‘beijing’, ‘shanghai’]</span><br></pre></td></tr></table></figure>



<p>5.获取所有值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值的列表 = 字典.values()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.values()</span><br><span class="line">dict_values([‘<span class="number">010</span>’, ‘<span class="number">021</span>’])</span><br></pre></td></tr></table></figure>

<p>获取到的所有值是以迭代器的形式存在，我们用 <code>list()</code> 函数将迭代器转换为列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(codes.values())</span><br><span class="line">[‘<span class="number">010</span>’, ‘<span class="number">021</span>’]</span><br></pre></td></tr></table></figure>



<p>6.获取所有键值对的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值的列表 = 字典.items()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.items()</span><br><span class="line">dict_items([(‘beijing’, ‘<span class="number">010</span>’), (‘shanghai’, ‘<span class="number">021</span>’)])</span><br></pre></td></tr></table></figure>

<p>获取到的所有键值对是以迭代器的形式存在，我们用 <code>list()</code> 函数将迭代器转换为列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(codes.items())</span><br><span class="line">[(‘beijing’, ‘<span class="number">010</span>’), (‘shanghai’, ‘<span class="number">021</span>’)]</span><br></pre></td></tr></table></figure>

<p>列表中的每一个元素是都是二元组（即包含两个元素的元组），每个二元组的第一个元素是键，第二个元素是值</p>
<h3 id="字典键值对的删除"><a href="#字典键值对的删除" class="headerlink" title="字典键值对的删除"></a>字典键值对的删除</h3><p>1.通过键删除键值对</p>
<p>可以使用 <code>pop</code> 方法删除一个键值对，并将值返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值 = 字典.pop(键)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.pop(‘beijing’)</span><br><span class="line">’<span class="number">010</span>’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>pop</code> 一个不存在的键，则会抛出 <code>KeyError</code> 异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.pop(‘a’)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">     File “”, line <span class="number">1</span>, <span class="keyword">in</span></span><br><span class="line">KeyError: ‘a’</span><br></pre></td></tr></table></figure>

<p>如果你不希望异常抛出，可以传递 <code>pop</code> 方法的第二个参数作为默认值。默认值仅在键不存在时生效，此时方法将直接返回这个默认值，且跳过删除操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">值 = 字典.pop(键, 默认值)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.pop(‘guangzhou’, ‘<span class="number">000</span>’)</span><br><span class="line">’<span class="number">000</span>’</span><br></pre></td></tr></table></figure>



<p>2.通过键删除键值对（<code>del</code> 方法）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> 字典[键]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> codes[‘beijing’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br></pre></td></tr></table></figure>



<p>3.随机删除一个键值对</p>
<p>使用 <code>popitem</code> 随机删除一个键值对，并返回这个键值对的二元组，二元组的第一个元素是键，第二个元素是值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">键值二元组 = 字典.popitem()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.popitem()</span><br><span class="line">(‘shanghai’, ‘<span class="number">021</span>’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;‘beijing’: ‘<span class="number">010</span>’&#125;</span><br></pre></td></tr></table></figure>



<p>4.清空所有键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">键值二元组 = 字典.clear()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字典中键值对修改"><a href="#字典中键值对修改" class="headerlink" title="字典中键值对修改"></a>字典中键值对修改</h3><p>1.修改键对应的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典[键] = 值</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes[‘beijing’] = <span class="string">'021’</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; codes</span></span><br><span class="line"><span class="string">&#123;‘beijing’: ‘021’&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果键不存在，则创建键值对</p>
<p>2.用字典批量更新键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典.update(另一字典)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = &#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">021</span>’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes.update(&#123;‘guangzhou’: ‘<span class="number">020</span>’, ‘shanghai’: ‘<span class="number">000</span>’&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">&#123;‘beijing’: ‘<span class="number">010</span>’, ‘shanghai’: ‘<span class="number">000</span>’, ‘guangzhou’: ‘<span class="number">020</span>’&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到字典中新增了 <code>&#39;guangzhou&#39;: &#39;020&#39;</code> 这个键值对，同时将 <code>&#39;shanghai&#39;: &#39;021&#39;</code> 修改为 <code>&#39;shanghai&#39;: &#39;000&#39;</code></p>
<h3 id="什么时候用字典"><a href="#什么时候用字典" class="headerlink" title="什么时候用字典"></a>什么时候用字典</h3><p>字典的显著优势是可以通过键快速地查询数据。字典中的元素以键值对的形式存在，使用时通过键来获取和修改值，由于字典内部的特殊实现，字典通过键获取值的效率非常高。</p>
<p>如果我们希望将批量的数据存放起来，并且在需要时能以很高的执行效率来获取其中某个指定的数据，这时就可以使用字典。除此之外，如果我们想在程序中暂时维护一个映射关系，也可以使用字典，因为字典本质上就是一个映射关系。</p>
<p>如，我们可以将城市名和对应的区号保存在字典中，这样就可以通过城市名快速地查询到其区号，而不需要进行遍历。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是一个用于存放批量元素的数据类型，它不是有序的，其中的元素<strong>没有顺序</strong>关系。集合中的元素<strong>没有重复</strong>，重复的元素将被自动剔除最终只留下一个。</p>
<p>集合也是用花括号（<code>{}</code>）来表示，不同于字典的是，花括号中放的是一个个数据，而不是键值对。</p>
<p>集合是可变的，我们可以向其中添加、删除、修改元素。</p>
<h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>1.创建包含元素的集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合 = &#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素N&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>



<p>2.创建空集合</p>
<p>注意创建空集合不能直接使用 <code>{}</code>，那样是表示空字典，而是使用 <code>set()</code>，这才表示空集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合 = set()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>empty_set = set()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>empty_set</span><br><span class="line">set()</span><br></pre></td></tr></table></figure>



<h3 id="集合元素的添加"><a href="#集合元素的添加" class="headerlink" title="集合元素的添加"></a>集合元素的添加</h3><p>1.向集合中添加一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.add(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.add(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>向集合中添加重复元素时，会被去重处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.add(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>



<p>2.从另一集合中批量添加元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.update(另一集合)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.update(numbers_2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，集合<code>numbers_2</code> 中的所有元素被添加到了集合 <code>numbers_1</code> 中，并且其中重复的元素被剔除仅保留一份</p>
<h3 id="集合元素的获取"><a href="#集合元素的获取" class="headerlink" title="集合元素的获取"></a>集合元素的获取</h3><p>集合不能像列表那样通过索引来获取元素，也不能像字典那样通过键来获取值，集合没法直接获取到某个指定的元素。想要获取元素，只能通过遍历的方式。</p>
<p>虽然集合不能直接获取到元素，但是我们依然可以用 <code>in</code> 关键字来判断元素是否存在于集合中。</p>
<p>1.查看元素是否存在于集合中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 元素 <span class="keyword">in</span> 集合</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = &#123;‘a’, ‘b’, ‘c’&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘a’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘z’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h3 id="集合元素的删除"><a href="#集合元素的删除" class="headerlink" title="集合元素的删除"></a>集合元素的删除</h3><p>1.随机删除一个元素，并返回这个元素</p>
<p>使用 <code>pop</code> 方法随机删除一个元素的时候，这个元素会被返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元素 = 集合.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.pop()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.pop()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>



<p>2.删除一个指定的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.remove(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.remove(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果要删除的元素不存在，则抛出 <code>KeyError</code> 异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.remove(<span class="number">4</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">     File “”, line <span class="number">1</span>, <span class="keyword">in</span></span><br><span class="line">KeyError: <span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>3.删除一个指定的元素，且不抛出 <code>KeyError</code> 异常</p>
<p>使用 <code>remove</code> 方法删除一个不存在的元素时，会抛出 <code>KeyError</code> 异常，如果我们不想让异常抛出，可以使用 <code>discard</code> 方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.discard(元素)</span><br><span class="line">           </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.discard(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>



<p>4.清空所有元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.clear()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">set()</span><br></pre></td></tr></table></figure>

<p>为什么元组没有这个方法？因为元组是不可变的！我们不能删除元组的元素，也不能添加和修改元素。</p>
<h3 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h3><p>Python 中的集合和数学中的集合颇为相似，首先集合的所有元素都是唯一的，不存在重复；此外集合有子集、超集的概念，也可以进行交集、并集、差集的运算</p>
<p>1.求交集</p>
<p>可以通过 <code>intersection</code> 方法求多个集合的交集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1.</span>intersection(集合<span class="number">2</span>, 集合<span class="number">3</span>, 集合N)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_3 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.intersection(numbers_2, numbers_3)</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接使用<strong>与运算符</strong> <code>&amp;</code> 来代替，完全等效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1</span> &amp; 集合<span class="number">2</span> &amp; 集合N</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 &amp; numbers_2 &amp; numbers_3</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>



<p>2.求并集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1.</span>union(集合<span class="number">2</span>, 集合<span class="number">3</span>, 集合N)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_3 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.union(numbers_2, numbers_3)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接使用<strong>或运算符</strong> <code>|</code> 来代替，完全等效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1</span> | 集合<span class="number">2</span> | 集合N</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 | numbers_2 | numbers_3</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>



<p>3.求差集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1.</span>difference(集合<span class="number">2</span>, 集合<span class="number">3</span>, 集合N)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_3 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.difference(numbers_2, numbers_3)</span><br><span class="line">&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接使用运算符 <code>-</code> 来代替，完全等效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">交集 = 集合<span class="number">1</span> - 集合<span class="number">2</span> - 集合N</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 - numbers_2 - numbers_3</span><br><span class="line">&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>



<p>4.判断是否为子集</p>
<p>判断 <code>集合1</code> 是否为 <code>集合2</code> 的子集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 集合<span class="number">1.</span>issubset(集合<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.issubset(numbers_2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_3 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.issubset(numbers_3)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>5.判断是否为超集</p>
<p>判断 <code>集合1</code> 是否为 <code>集合2</code> 的超集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 集合<span class="number">1.</span>issuperset(集合<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_2 = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.issuperset(numbers_2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_3 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers_1.issuperset(numbers_3)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h3 id="什么时候用集合"><a href="#什么时候用集合" class="headerlink" title="什么时候用集合"></a>什么时候用集合</h3><p>集合非常重要的一个特性是元素无重复，每个元素都是唯一的，重复的元素将被自动剔除（去重）。</p>
<p>所以如果我们需要存放一系列的数据，并且不希望其中出现重复，那么就可以使用集合。</p>
<p>另外如果想计算两个数据集的交集、并集、差集，使用集合来承载数据再合适不过了，集合自带的集合运算能轻松解决这些问题。</p>
<h3 id="获取字典和集合中的元素数量"><a href="#获取字典和集合中的元素数量" class="headerlink" title="获取字典和集合中的元素数量"></a>获取字典和集合中的元素数量</h3><p>我们可以通过 <code>len()</code> 函数来获取字典中的键值对数量和集合中的元素数量</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>字典是一种用来存放若干键值对的数据类型，可通过键来快速查找值。</p>
<p>字典的键需要是不可变的类型，如数字，字符串和元组。字典的值可以是任意类型。字典本身是可变的，所以可向其中添加、修改、删除键值对。</p>
<p>集合是一个用于存放批量元素的序列。它不是有序的，且元素<strong>不会有重复</strong>。集合也是可变的，我们可以向其中添加、删除、修改元素。</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的列表、元组、字符串</title>
    <url>/2020/02/02/19.Python%E7%9A%84%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%A5%96%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表是用于存放若干元素的<strong>有序序列</strong>。列表使用方括号（<code>[]</code>）来表示，其中的元素写入方括号中，多个元素时用逗号分隔，如 <code>[1, &#39;go&#39;, [0.1, 0.2]]</code>。它的元素可以是任意数据类型，甚至也可以是个列表。</p>
<p>元素之间有顺序关系，每个元素都有自己的位置，每个位置从 0 开始依次标号，这个表示位置的数字叫作<strong>索引</strong>。</p>
<p>列表被创建之后，我们可以对它做很多操作，包括添加元素，删除元素，修改元素，查找元素等。</p>
<h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><p>1.创建空的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表 = []</span><br><span class="line"></span><br><span class="line">items = []</span><br></pre></td></tr></table></figure>



<p>2.创建包含元素的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表 = [元素<span class="number">1</span>, 元素<span class="number">2</span>, ..., 元素N]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>



<h3 id="列表元素的获取"><a href="#列表元素的获取" class="headerlink" title="列表元素的获取"></a>列表元素的获取</h3><p>1.通过索引获取元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元素 = 列表[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>]</span><br><span class="line">’c’</span><br></pre></td></tr></table></figure>



<p>2.通过元素获取索引</p>
<p>这种方式和上面相反，首先在列表中寻找元素，然后返回元素对应的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">索引 = 列表.index(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.index(‘c’)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>3.查看元素是否存在于列表中</p>
<p>要想查看元素是否存在于列表中，需要借助 Python 的关键字 <code>in</code>，使用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 元素 <span class="keyword">in</span> 列表</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘a’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘z’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>4.统计元素在列表中的个数</p>
<p>统计元素在列表中的个数，或者说是元素在列表中出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">个数 = 列表.count(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.count(<span class="number">5</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<h3 id="列表元素的添加"><a href="#列表元素的添加" class="headerlink" title="列表元素的添加"></a>列表元素的添加</h3><p>我们可以很灵活地向列表添加元素，如以追加的形式向列表末尾添加一个元素；以插入的形式向列表的任意位置插入元素；或者将一个列表中的所有元素批量的添加到另一个列表中。</p>
<p>1.向列表末尾追加元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.append(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.append(‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘b’, ‘c’]</span><br></pre></td></tr></table></figure>



<p>2.向列表的任意位置插入元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.insert(索引, 元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.insert(<span class="number">0</span>, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘c’, ‘a’, ‘b’]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.insert(<span class="number">2</span>, ‘d’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘c’, ‘a’, ‘d’, ‘b’]</span><br></pre></td></tr></table></figure>



<p>3.列表末尾追加另一个列表的所有元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.extend(另一列表)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.extend([‘c’, ‘d’, ‘e’])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘b’, ‘c’, ‘d’, ‘e’]</span><br></pre></td></tr></table></figure>



<h3 id="列表元素的删除"><a href="#列表元素的删除" class="headerlink" title="列表元素的删除"></a>列表元素的删除</h3><p>1.按索引删除元素</p>
<p><strong>pop(索引)</strong> 会将索引对应的元素从列表中删除，同时返回这个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元素 = 列表.pop(索引)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.pop(<span class="number">0</span>)</span><br><span class="line">’a’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘b’, ‘c’]</span><br></pre></td></tr></table></figure>

<p>也可以不传递索引，这样的话默认删除并返回最后一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.pop()</span><br><span class="line">’c’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘b’]</span><br></pre></td></tr></table></figure>



<p>2.按索引删除元素（<code>del</code> 方法)</p>
<p>删除一个列表元素也可以使用 Python 中的 <code>del</code> 关键字，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> 列表[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> letters[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘b’, ‘c’]</span><br></pre></td></tr></table></figure>



<p>3.直接删除元素</p>
<p>直接删除元素时，Python 会先在列表中遍历该元素，然后将匹配到的第一个元素删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.remove(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.remove(‘b’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘c’]</span><br></pre></td></tr></table></figure>



<p>4.清空所有元素</p>
<p>清空所有元素即是把列表元素全部删除，最后仅为列表仅为 <code>[]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.clear()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>



<h3 id="列表元素的修改"><a href="#列表元素的修改" class="headerlink" title="列表元素的修改"></a>列表元素的修改</h3><p>1.通过赋值修改列表元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表[索引] = 新元素</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>] = <span class="string">'d’</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; letters</span></span><br><span class="line"><span class="string">[‘a’, ‘b’, ‘d’]</span></span><br></pre></td></tr></table></figure>



<p>2.反转整个列表</p>
<p>反转整个列表会将所有的元素倒序排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.reverse()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘c’, ‘b’, ‘a’]</span><br></pre></td></tr></table></figure>



<p>3.列表元素排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.sort()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>也可以通过指定 <code>sort</code> 方法的 <code>reverse</code> 参数来倒序排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组和列表非常相似，也是用于存放元素的有序序列。它用的圆括号（<code>()</code>）表示，元素写入圆括号中，多个元素时用逗号分隔，如 <code>(1, 2, 3)</code>。</p>
<p>元组同样具有索引，索引使用方式与列表一致。其元素同样可以是任意类型。</p>
<p>看起来元组就是披着圆括号外衣的列表嘛！有什么区别？</p>
<p>元组创建完成后，便不能向其中添加元素，也不能修改和删除其中的任何一个元素。所以它与列表相比，只能查找元素，也就是说只具备读的功能，不具备写的功能。元组的这一特性叫作<strong>不可变（性）</strong>（Immutable），而列表是<strong>可变的</strong>（Mutable）。</p>
<h3 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h3><p>1.创建空的元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元组 = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line">()</span><br></pre></td></tr></table></figure>



<p>2.创建包含多个元素的元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元组 = (元素<span class="number">1</span>, 元素<span class="number">2</span>, ..., 元素N)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>



<p>3.创建只包含一个元素的元组</p>
<p>只包含一个元素的情况需要单独说明一下，因为它的形式与直觉不相符。</p>
<p>创建只包含一个元素的元组，需要在唯一的那个元素后面<strong>加上逗号</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元组 = (元素,)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure>

<p>这是因为，如果括号中只有一个元素，那么 Python 会将这个括号当作优先级符号进行处理（像数学中的那样），而不是当作元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = (<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(items)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> ‘<span class="title">int</span>’&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="元组元素的获取"><a href="#元组元素的获取" class="headerlink" title="元组元素的获取"></a>元组元素的获取</h3><p>1.通过索引获取元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元素 = 元组[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>]</span><br><span class="line">’c’</span><br></pre></td></tr></table></figure>



<p>2.通过元素获取索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">索引 = 元组.index(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.index(‘c’)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>3.查看元素是否存在于元组中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 元素 <span class="keyword">in</span> 元组</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘a’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘z’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>4.统计元素在元组中出现的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">个数 = 元组.count(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.count(<span class="number">5</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<h2 id="元组和列表的差别"><a href="#元组和列表的差别" class="headerlink" title="元组和列表的差别"></a>元组和列表的差别</h2><p>我们可以看到，元组所具有的操作在使用方式上与和列表非常相似，甚至在一定程度上可以将元组看作是列表的精简版，但它们之间也有明显的差别。</p>
<ul>
<li>元组是不可变的（Immutable），列表是可变的（Mutable），元组在被创建之后，就不能添加、删除和修改元素，而列表可以</li>
<li>一般情况下元组的性能在略高于列表</li>
</ul>
<p>我们在什么时候用列表，什么时候用元组？</p>
<p>列表还是元组，通常性能不是从它们中做选择的主要考虑因素，因为它们之间的性能差异不是很大。我们的选择通常围绕着可变和不可变的特性进行，当我们需要添加元素或修改元素时，使用列表；当我们希望所有元素在创建之后便不再改变，可使用元组。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是 Python 中用来存放字符序列的数据类型，其中的元素只能是字符。字符串使用单引号或双引号来表示，如 <code>&#39;pick&#39;</code>，<code>&quot;cherry&quot;</code>，通常我们首先使用单引号。</p>
<p>字符串是有序序列，可以使用索引来获取其中某个位置的元素。它是不可变的，被创建之后其中的元素（也就是字符）不能被修改和删除。</p>
<h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><p>1.创建空字符串（即不包含字符的字符串）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串 = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string</span><br><span class="line">’’</span><br></pre></td></tr></table></figure>



<p>2.创建包含元素的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串 = <span class="string">'若干字符'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="string">'happy’</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; string</span></span><br><span class="line"><span class="string">’happy’</span></span><br></pre></td></tr></table></figure>



<h3 id="字符的获取"><a href="#字符的获取" class="headerlink" title="字符的获取"></a>字符的获取</h3><ol>
<li>通过索引获取字符<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符 = 字符串[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string[<span class="number">2</span>]</span><br><span class="line">’p’</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>2.通过子串获取索引</p>
<p>所谓子串就是从字符串中截取下来的一部分，可以是一个字符，一部分字符、全部字符、或空字符串，如 <code>&#39;a&#39;</code>、<code>&#39;ppy&#39;</code>、<code>&#39;happy&#39;</code>、<code>&#39;&#39;</code> 都是 ‘happy’ 的子串。查找子串时，返回的是子串的第一个字符的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">索引 = 字符串.index(字符)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.index(‘p’)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.index(‘app’)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>当字符或子串不存在时，<code>index</code> 方法将抛出 <code>ValueError</code> 错误。</p>
<p>也可采用字符串的 <code>find</code> 方法来查找子串，使用方式与 <code>index</code> 一致，不同点在于 <code>find</code> 方法未找到子串时返回数字 <code>-1</code>，而不抛异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.find(‘app’)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.find(‘z’)</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>



<p>3.查看字符是否存在于字符串中</p>
<p>查看字符是否存在于字符串中，需要借助 Python 的关键字 <code>in</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 字符 <span class="keyword">in</span> 字符串</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘a’ <span class="keyword">in</span> string</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘z’ <span class="keyword">in</span> string</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>4.统计字符在字符串中的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">个数 = 字符串.count(字符)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.count(‘p’)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串的处理"><a href="#字符串的处理" class="headerlink" title="字符串的处理"></a>字符串的处理</h3><p>字符串自带的方法非常多，除了上面介绍的几个之外还有四十多个，这是因为字符处理是编程时的一项高频工作。Python 将这些字符处理相关的功能以方法的形式集成在字符串里。这里列举几个常见的方法</p>
<p>1.startswith：判断字符串是否以某个子串开头，返回布尔值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.startswith(‘ha’)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>



<p>2.endswith：判断字符串是否以某个子串结尾，返回布尔值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.endswith(‘y’)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>



<p>3.replace：将字符串的子串用一个另一个字符串替换，返回一个新的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.replace(‘y’, ‘iness’)</span><br><span class="line">’happiness’</span><br></pre></td></tr></table></figure>



<p>4.strip：去除字符串前后的空白符号，如空格、换行符、制表符，返回一个新的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ’ \t happy \n’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.strip()</span><br><span class="line">’happy’</span><br></pre></td></tr></table></figure>



<p>5.split：将字符串用某个子串分隔开，分隔后的各个部分放入列表中，并返回这个列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘I am happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.split(’ <span class="string">')</span></span><br><span class="line"><span class="string">[‘I’, ‘am’, ‘happy’]</span></span><br></pre></td></tr></table></figure>



<p>6.join：将一个序列中的元素用某个字符（串）拼接，组成一个大的字符串，并返回这个字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = [‘I’, ‘am’, ‘happy’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>’ <span class="string">'.join(words)</span></span><br><span class="line"><span class="string">’I am happy’</span></span><br></pre></td></tr></table></figure>



<p>7.upper：将字符串转化为大写字母形式，返回一个新的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.upper()</span><br><span class="line">’HAPPY’</span><br></pre></td></tr></table></figure>



<p>8.lower：将字符串转化为小写字母形式，返回一个新的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘HAPPY’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.lower()</span><br><span class="line">’happy’</span><br></pre></td></tr></table></figure>

<p>注意上面的这些字符处理功能，对字符串作处理后都是返回一个新的字符串，而不会直接修改原有的字符串。为什么呢？<strong>字符串不可变呀！</strong></p>
<h2 id="列表、元组、字符串的通用操作"><a href="#列表、元组、字符串的通用操作" class="headerlink" title="列表、元组、字符串的通用操作"></a>列表、元组、字符串的通用操作</h2><p>我们把列表、元组、字符串统称为<strong>序列</strong></p>
<p>1.使用 <code>len()</code> 函数获取序列长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(letters)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = ‘abcd’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(letters)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>2.获取序列中的一个子序列</p>
<p>获取序列中的子序列可以使用<strong>切片</strong>，以 <code>[起始索引:结束索引]</code> 表示。切片其实代表一个索引区间，这个区间是一个<strong>左开右闭区间</strong>，该区间内的所有元素作为子序列被返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = ‘abcd’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">’bcd’</span><br></pre></td></tr></table></figure>



<p>3.使用 <code>+</code> 符号来拼接两个序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_1 = (‘a’, ‘b’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_2 = (‘c’, ‘d’, ‘e’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_1 + letters_2</span><br><span class="line">(‘a’, ‘b’, ‘c’, ‘d’, ‘e’)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_1 = ‘ab’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_2 = ‘cde’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters_1 + letters_2</span><br><span class="line">’abcde’</span><br></pre></td></tr></table></figure>



<p>4.使用 <code>*</code> 符号来重复序列中的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters * <span class="number">3</span></span><br><span class="line">(‘a’, ‘b’, ‘a’, ‘b’, ‘a’, ‘b’)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = ‘abcd’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters * <span class="number">2</span></span><br><span class="line">’abcdabcd’</span><br></pre></td></tr></table></figure>

<p>注意上面的操作结果都是返回一个新的序列，不会对修改序列的内部元素</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>列表、元组、字符串都是有序序列，都可以使用索引。</p>
<p>列表和元组中可以存放任意数据类型的元素，而字符串中只能存放字符。</p>
<p>列表是可变的，而元组和字符串是不可变的。</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo d部署后需要在github上重新保存域名的问题</title>
    <url>/2020/02/01/18.hexo%20d%E9%83%A8%E7%BD%B2%E5%90%8E%E9%9C%80%E8%A6%81%E5%9C%A8github%E4%B8%8A%E9%87%8D%E6%96%B0%E4%BF%9D%E5%AD%98%E5%9F%9F%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>1.在根目录的source文件夹下新建一个CNAME文件（无后缀），内容就写自己的域名</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.maxinhong.com</span><br></pre></td></tr></table></figure>

<p>2.hexo g重新生成一下静态文件</p>
<p>3.hexo d部署</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive DDL之数据库操作</title>
    <url>/2020/01/30/17.Hive%20DDL%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>官方文档</strong>：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL</a></p>
<p>详情请看官方文档，本文只记录部分关键字便于回忆查询</p>
<p>DDL：Hive Data Definition Language</p>
<p>&emsp;&emsp;create、delete、alter…</p>
<p>Hive数据抽象/结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">database     HDFS一个目录</span><br><span class="line">	table    HDFS一个目录</span><br><span class="line">		data  文件 </span><br><span class="line">		partition 分区表  HDFS一个目录</span><br><span class="line">			data  文件 </span><br><span class="line">			bucket  分桶   HDFS一个文件</span><br></pre></td></tr></table></figure>



<p>创建数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (DATABASE|SCHEMA) [IF NOT EXISTS] database_name</span><br><span class="line">  [COMMENT database_comment]</span><br><span class="line">  [LOCATION hdfs_path]</span><br><span class="line">  [WITH DBPROPERTIES (property_name&#x3D;property_value, ...)];</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">CREATE DATABASE IF NOT EXISTS hive;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS hive2 LOCATION &#39;&#x2F;test&#x2F;location&#39;;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS hive3 WITH DBPROPERTIES(&#39;creator&#39;&#x3D;&#39;pearfl&#39;);</span><br></pre></td></tr></table></figure>

<p>/usr/hive/warehouse是Hive默认的存储在HDFS上的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD DATA LOCAL INPATH &#39;&#x2F;home&#x2F;hadoop&#x2F;data&#x2F;emp.txt&#39; OVERWRITE INTO TABLE emp;</span><br><span class="line"></span><br><span class="line">LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)]</span><br><span class="line"></span><br><span class="line">LOCAL：本地系统，如果没有local那么就是指的HDFS的路径</span><br><span class="line">OVERWRITE：是否数据覆盖，如果没有那么就是数据追加</span><br><span class="line"></span><br><span class="line">LOAD DATA LOCAL INPATH &#39;&#x2F;home&#x2F;hadoop&#x2F;data&#x2F;emp.txt&#39; OVERWRITE INTO TABLE emp;</span><br><span class="line"></span><br><span class="line">LOAD DATA INPATH &#39;hdfs:&#x2F;&#x2F;hadoop000:8020&#x2F;data&#x2F;emp.txt&#39; INTO TABLE emp;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT OVERWRITE LOCAL DIRECTORY &#39;&#x2F;tmp&#x2F;hive&#x2F;&#39;</span><br><span class="line">ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\t&#39;</span><br><span class="line">select empno,ename,sal,deptno from emp;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive部署</title>
    <url>/2020/01/28/16.Hive%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="Hive部署"><a href="#Hive部署" class="headerlink" title="Hive部署"></a>Hive部署</h2><p>1）下载</p>
<p>2）解压</p>
<p>3）添加HIVE_HOME到系统环境变量</p>
<p>4）修改配置 hive-env.sh</p>
<p>5）拷贝MySQL驱动包到$HIVE_HOME/lib</p>
<p>6）前提是要安装一个MySQL数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf hive-1.1.0-cdh5.16.2.tar.gz -C ~&#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line">配置.bash_profile</span><br><span class="line">export HIVE_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;apache-hive-1.1.0-cdh5.16.2-bin</span><br><span class="line">export PATH&#x3D;$HIVE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>



<p>在hive文件夹的conf文件夹内进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cp hive-env.sh.template hive-env.sh</span><br></pre></td></tr></table></figure>

<p>若hadoop没有配置进环境变量，需要再hive-env.sh内配置HADOOP_HOME</p>
<p>配置hive-site.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;xsl&quot; href&#x3D;&quot;configuration.xsl&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionURL&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;jdbc:mysql:&#x2F;&#x2F;hadoop000:3306&#x2F;hadoop_hive?createDatabaseIfNotExist&#x3D;true&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;com.mysql.jdbc.Driver&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;hadoop&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;hadoop&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hive.cli.print.current.db&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;true&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hive.cli.print.header&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;true&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p>javax.jdo.option.ConnectionUserName对应mysql中的账号</p>
<p>javax.jdo.option.ConnectionPassword对应mysql中的密码</p>
<p>拷贝mysql的架包到hive文件夹下的lib文件夹中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ~&#x2F;lib&#x2F;mysql-connector-java-5.1.47.jar &#x2F;home&#x2F;pearfl&#x2F;app&#x2F;apache-hive-1.1.0-cdh5.16.2-bin&#x2F;lib&#x2F;mysql-connector-java-5.1.47.jar</span><br></pre></td></tr></table></figure>



<h2 id="hive编译安装"><a href="#hive编译安装" class="headerlink" title="hive编译安装"></a>hive编译安装</h2><p>hive-1.1.0-cdh5.16.2-src.tar.gz已下载在~/tmp下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd &#x2F;tmp&#x2F;</span><br><span class="line"># tar -xf hive-1.1.0-cdh5.16.2-src.tar.gz</span><br><span class="line"># cd &#x2F;hive-1.1.0-cdh5.16.2</span><br><span class="line"># mvn clean package -DskipTests -Phadoop-2 -Pdist</span><br></pre></td></tr></table></figure>

<p>之后会有一个比较长时间的等待</p>
<p>编译生成的包在以下位置：</p>
<p>packaging/target/apache-hive-1.1.0-cdh5.7.1-bin.tar.gz，之后就是像之前博客一样配置环境变量</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j相关配置</title>
    <url>/2020/01/27/15.log4j%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>log4j.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootCategory&#x3D;info, console</span><br><span class="line">log4j.appender.console&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.target&#x3D;System.err</span><br><span class="line">log4j.appender.console.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern&#x3D;%p %c&#123;1&#125;: %m%n</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径算法</title>
    <url>/2020/01/26/14.%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><h3 id="1-Dijkstra-算法"><a href="#1-Dijkstra-算法" class="headerlink" title="1.$Dijkstra$算法"></a>1.$Dijkstra$算法</h3><p>解决单源最短路径问题常用 Dijkstra 算法，用于计算一个顶点到其他所有顶点的最短路径。Dijkstra 算法的主要特点是以起点为中心，逐层向外扩展（这一点类似于 bfs，但是不同的是，bfs 每次扩展一个层，但是 Dijkstra 每次只会扩展一个点），每次都会取一个最近点继续扩展，直到取完所有点为止。 </p>
<p>注意：Dijkstra 算法要求图中不能出现负权边。</p>
<h4 id="①、-Dijkstra-算法流程"><a href="#①、-Dijkstra-算法流程" class="headerlink" title="①、$Dijkstra$算法流程"></a>①、$Dijkstra$算法流程</h4><p>我们定义带权图$ G $所有顶点的集合为$ V$，接着我们再定义已确定从源点出发的最短路径的顶点集合为$ U$，初始集合 $U $为空，记从源点$ s $出发到每个顶点$ v $的距离为 $dist_v $，初始 $dist_s$=0。接着执行以下操作： </p>
<ol>
<li><p>从 $V−U $中找出一个距离源点最近的顶点$v$，将$v$加入集合$ U$。</p>
</li>
<li><p>并用 $dist_v$和顶点 $v $连出的边来更新和 $v $相邻的、不在集合 $U$中的顶点的 $dist$，这一步称为松弛操作。  </p>
</li>
<li><p>重复步骤 1 和 2，直到 $V=U$或找不出一个从$ s$ 出发有路径到达的顶点，算法结束。  </p>
</li>
</ol>
<p>如果最后 $V \neq U$，说明有顶点无法从源点到达；否则每个$ dist_i$表示从 $s$ 出发到顶点$ i $的最短距离。  </p>
<p>Dijkstra 算法的时间复杂度为$ \mathcal{O}(V^2)$，其中 $V$ 表示顶点的数量。</p>
<p>Dijkstra 是解决无负边权的图的单源最短路问题，经常使用邻接表存储。</p>
<p>不优化的时间复杂度是 $O(V^2 + E)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    edge() &#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[len] = edge(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    add(u, v, w);</span><br><span class="line">    add(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; mi) &#123;</span><br><span class="line">                mi = dis[u = j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mi == inf) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[u]; ~j; j = e[j].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[j].v;</span><br><span class="line">            <span class="keyword">int</span> w = e[j].w;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        add2(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dis[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="②、基于小根堆优化的-Dijkstra-算法"><a href="#②、基于小根堆优化的-Dijkstra-算法" class="headerlink" title="②、基于小根堆优化的$Dijkstra$算法"></a>②、基于小根堆优化的$Dijkstra$算法</h4><p>用一个set来维护点的集合，这样的时间复杂度就优化到了 $\mathcal{O}((V+E)\log V)$，对于稀疏图的优化效果非常好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125; e[MAX_M];</span><br><span class="line"><span class="keyword">int</span> p[MAX_N], eid, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mapinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    eid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权有向边</span></span><br><span class="line">    e[eid].v = v;</span><br><span class="line">    e[eid].w = w;</span><br><span class="line">    e[eid].next = p[u];</span><br><span class="line">    p[u] = eid++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权双向边</span></span><br><span class="line">    insert(u, v, w);</span><br><span class="line">    insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="built_in">set</span>&lt;PII, less&lt;PII&gt; &gt; min_heap;</span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];  <span class="comment">// 存储单源最短路的结果</span></span><br><span class="line"><span class="keyword">bool</span> vst[MAX_N];  <span class="comment">// 标记每个顶点是否在集合 U 中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 dist、小根堆和集合 U</span></span><br><span class="line">    <span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span>(vst));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    min_heap.insert(make_pair(<span class="number">0</span>, s));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min_heap.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;  <span class="comment">// 如果小根堆中没有可用顶点，说明有顶点无法从源点到达，算法结束</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取堆顶元素，并将堆顶元素从堆中删除</span></span><br><span class="line">        <span class="built_in">set</span>&lt;PII, less&lt;PII&gt; &gt;::iterator iter = min_heap.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> v = iter-&gt;second;</span><br><span class="line">        min_heap.erase(*iter);</span><br><span class="line">        vst[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 进行和普通 dijkstra 算法类似的松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = p[v]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = e[j].v;</span><br><span class="line">            <span class="keyword">if</span> (!vst[x] &amp;&amp; dist[v] + e[j].w &lt; dist[x]) &#123;</span><br><span class="line">                <span class="comment">// 先将对应的 pair 从堆中删除，再将更新后的 pair 插入堆</span></span><br><span class="line">                min_heap.erase(make_pair(dist[x], x));</span><br><span class="line">                dist[x] = dist[v] + e[j].w;</span><br><span class="line">                min_heap.insert(make_pair(dist[x], x));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 存储单源最短路的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="③、基于优先队列优化的-Dijkstra-算法"><a href="#③、基于优先队列优化的-Dijkstra-算法" class="headerlink" title="③、基于优先队列优化的$Dijkstra$算法"></a>③、基于优先队列优化的$Dijkstra$算法</h4><p>我们在 $node $节点里面记录对应的点的最短路，然后每次更新一个点的最短路后都把这个点压入到优先队列里面（不管之前有没有被压入到队列里面），这样就一定能够保证优先队列对的性质不会改变</p>
<p>这个代码的时间复杂度实际上会比用真正的堆要慢一点，因为有的点可能会入队多次，但是每一条边最多导致一次入队，所以这个算法的时间复杂度为 $\mathcal{O}(E\log E)$。其中$ E $为边的数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125; e[MAX_M];</span><br><span class="line"><span class="keyword">int</span> p[MAX_N], eid, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mapinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    eid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权有向边</span></span><br><span class="line">    e[eid].v = v;</span><br><span class="line">    e[eid].w = w;</span><br><span class="line">    e[eid].next = p[u];</span><br><span class="line">    p[u] = eid++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权双向边</span></span><br><span class="line">    insert(u, v, w);</span><br><span class="line">    insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];  <span class="comment">// 存储单源最短路的结果</span></span><br><span class="line"><span class="keyword">bool</span> vst[MAX_N];  <span class="comment">// 标记每个顶点是否在集合 U 中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">  <span class="keyword">int</span> dist;</span><br><span class="line">    node(<span class="keyword">int</span> _u, <span class="keyword">int</span> _dist) : u(_u), dist(_dist) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dist &gt; x.dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">// 记录点的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 dist、小根堆和集合 U</span></span><br><span class="line">    <span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span>(vst));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    priority_queue&lt;node&gt; min_heap;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    min_heap.push(node(s, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!min_heap.empty())</span><br><span class="line">        <span class="comment">// 获取堆顶元素，并将堆顶元素从堆中删除</span></span><br><span class="line">        <span class="keyword">int</span> v = min_heap.top().u;</span><br><span class="line">        min_heap.pop();</span><br><span class="line">        <span class="keyword">if</span> (vst[v]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vst[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 进行和普通 dijkstra 算法类似的松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = p[v]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = e[j].v;</span><br><span class="line">            <span class="keyword">if</span> (!vst[x] &amp;&amp; dist[v] + e[j].w &lt; dist[x]) &#123;</span><br><span class="line">                dist[x] = dist[v] + e[j].w;</span><br><span class="line">                min_heap.push(node(x, dist[x]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-SPFA-算法"><a href="#2-SPFA-算法" class="headerlink" title="2.$SPFA$算法"></a>2.$SPFA$算法</h3><p>SPFA（Shortest Path Faster Algorithm）算法是单源最短路径的一种算法，通常被认为是 Bellman-ford 算法的队列优化，在代码形式上接近于宽度优先搜索 BFS，是一个在实践中非常高效的单源最短路算法。</p>
<h4 id="①、-SPFA-算法流程"><a href="#①、-SPFA-算法流程" class="headerlink" title="①、$SPFA$算法流程"></a>①、$SPFA$算法流程</h4><p>在 $SPFA$ 算法中，使用 $d_i$表示从源点到顶点$i$的最短路，额外用一个队列来保存即将进行拓展的顶点列表，并用 $inq_i$来标识顶点$i$是不是在队列中。</p>
<p>1.初始队列中仅包含源点，且源点 $s$ 的 $d_s=0$。</p>
<p>2.取出队列头顶点 $u$，扫描从顶点 $u$ 出发的每条边，设每条边的另一端为 $v$，边$&lt;u,v&gt;$ 权值为 $w$，若 $d_u+w&lt;d_v$，则 </p>
<ul>
<li><p>将 $d_v$修改为 $d_u+w$</p>
</li>
<li><p>若 $v$ 不在队列中，则 </p>
</li>
<li><p>将 $v $入队 </p>
</li>
</ul>
<p>3.重复步骤 2 直到队列为空 </p>
<p>最终$ d$ 数组就是从源点出发到每个顶点的最短路距离。如果一个顶点从没有入队，则说明没有从源点到该顶点的路径。</p>
<p>$SPFA$ 的空间复杂度为$ \mathcal{O}(V)$。如果顶点的平均入队次数为 $k$，则 $SPFA $的时间复杂度为 $\mathcal{O}(kE)$O，对于较为随机的稀疏图，根据经验 $k$ 一般不超过 4。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    edge()&#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail)&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[len] = edge(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    add(u, v, w);</span><br><span class="line">    add(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = head[u];~j;j = e[j].fail)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[j].v;</span><br><span class="line">            <span class="keyword">int</span> w = e[j].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w)&#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add2(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dis[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②、-SPFA-判断负环"><a href="#②、-SPFA-判断负环" class="headerlink" title="②、$SPFA$判断负环"></a>②、$SPFA$判断负环</h4><p>$Dijkstra$不能处理有负权的图，而 $SPFA$ 可以处理任意不含负环（负环是指总边权和为负数的环）的图的最短路，并能判断图中是否存在负环</p>
<p>但是 $SPFA $可以用来判断负环，在进行 $SPFA $时，用一个数组 $cnt_i$来标记每个顶点入队次数。如果一个顶点入队次数 $cnt_i$大于顶点总数 n，则表示该图中包含负环。一般情况下，$SPFA$ 判负环都只用在有向图上，因为在无向图上，一条负边权的边就是一个负环了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span> in);</span><br><span class="line">in[u] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 修改入队部分的操作</span></span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">    q.push(v);</span><br><span class="line">    vis[v] = <span class="literal">true</span>;</span><br><span class="line">    ++in[v];</span><br><span class="line">    <span class="keyword">if</span>(in[v] &gt; n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、-floyd-多源最短路算法"><a href="#3、-floyd-多源最短路算法" class="headerlink" title="3、$floyd$多源最短路算法"></a>3、$floyd$多源最短路算法</h3><p>$∀1≤k≤n,dp [i] [j] = min（dp[i] [j]，dp[i][k]+ dp [k][j]）$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL创建用户与授权</title>
    <url>/2020/01/24/13.MySQL%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1.创建用户"></a>1.创建用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</span><br></pre></td></tr></table></figure>

<p>username：你将创建的用户名<br>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%<br>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;dog&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;192.168.1.101_&#39; IDENDIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>





<h2 id="2-授权"><a href="#2-授权" class="headerlink" title="2.授权"></a>2.授权</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;</span><br></pre></td></tr></table></figure>

<p>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL<br>databasename：数据库名<br>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</p>
<p>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:<br>GRANT privileges ON databasename.tablename TO ‘username’@’host’ WITH GRANT OPTION;</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON maindataplus.* TO &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>



<h2 id="3-设置与更改用户密码"><a href="#3-设置与更改用户密码" class="headerlink" title="3.设置与更改用户密码"></a>3.设置与更改用户密码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; &#x3D; PASSWORD(&#39;newpassword&#39;);</span><br></pre></td></tr></table></figure>

<p>如果是当前登陆用户用:<br>SET PASSWORD = PASSWORD(“newpassword”);</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR &#39;pig&#39;@&#39;%&#39; &#x3D; PASSWORD(&quot;123456&quot;);</span><br></pre></td></tr></table></figure>



<h2 id="4-撤销用户权限"><a href="#4-撤销用户权限" class="headerlink" title="4.撤销用户权限"></a>4.撤销用户权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure>

<p>privilege, databasename, tablename：同授权部分</p>
<p>假如你在给用户‘pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。</p>
<p>相反，如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。</p>
<p>具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>



<h2 id="5-删除用户"><a href="#5-删除用户" class="headerlink" title="5.删除用户"></a>5.删除用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP USER &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7使用firewalld打开关闭防火墙与端口</title>
    <url>/2020/01/23/12.CentOS7%E4%BD%BF%E7%94%A8firewalld%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="CentOS7使用firewalld打开关闭防火墙与端口"><a href="#CentOS7使用firewalld打开关闭防火墙与端口" class="headerlink" title="CentOS7使用firewalld打开关闭防火墙与端口"></a>CentOS7使用firewalld打开关闭防火墙与端口</h2><p>1、firewalld的基本使用</p>
<p>启动： systemctl start firewalld</p>
<p>关闭： systemctl stop firewalld</p>
<p>查看状态： systemctl status firewalld </p>
<p>开机禁用 ： systemctl disable firewalld</p>
<p>开机启用 ： systemctl enable firewalld</p>
<p>2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。</p>
<p>启动一个服务：systemctl start firewalld.service<br>关闭一个服务：systemctl stop firewalld.service<br>重启一个服务：systemctl restart firewalld.service<br>显示一个服务的状态：systemctl status firewalld.service<br>在开机时启用一个服务：systemctl enable firewalld.service<br>在开机时禁用一个服务：systemctl disable firewalld.service<br>查看服务是否开机启动：systemctl is-enabled firewalld.service<br>查看已启动的服务列表：systemctl list-unit-files|grep enabled<br>查看启动失败的服务列表：systemctl –failed</p>
<p>3.配置firewalld-cmd</p>
<p>查看版本： firewall-cmd –version</p>
<p>查看帮助： firewall-cmd –help</p>
<p>显示状态： firewall-cmd –state</p>
<p>查看所有打开的端口： firewall-cmd –zone=public –list-ports</p>
<p>更新防火墙规则： firewall-cmd –reload</p>
<p>查看区域信息:  firewall-cmd –get-active-zones</p>
<p>查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0</p>
<p>拒绝所有包：firewall-cmd –panic-on</p>
<p>取消拒绝状态： firewall-cmd –panic-off</p>
<p>查看是否拒绝： firewall-cmd –query-panic</p>
<p>那怎么开启一个端口呢</p>
<p>添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent   （--permanent永久生效，没有此参数重启后失效）</span><br></pre></td></tr></table></figure>

<p>重新载入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D; public --query-port&#x3D;80&#x2F;tcp</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D; public --remove-port&#x3D;80&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>firewalld</tag>
      </tags>
  </entry>
  <entry>
    <title>pip源</title>
    <url>/2020/01/22/11.pip%E6%BA%90/</url>
    <content><![CDATA[<h2 id="pip源修改"><a href="#pip源修改" class="headerlink" title="pip源修改"></a>pip源修改</h2><p>国内源：<br>新版ubuntu要求使用https源，要注意。</p>
<p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>华中理工大学：<a href="http://pypi.hustunique.com/" target="_blank" rel="noopener">http://pypi.hustunique.com/</a></p>
<p>山东理工大学：<a href="http://pypi.sdutlinux.org/" target="_blank" rel="noopener">http://pypi.sdutlinux.org/</a></p>
<p>豆瓣：<a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></p>
<p>临时使用：<br>可以在使用pip的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>例如：pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyspider，这样就会从清华这边的镜像去安装pyspider库。</p>
<p>永久修改，一劳永逸：<br>Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)</p>
<p>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<p>windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini。内容同上。</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>无法停止hadoop集群</title>
    <url>/2020/01/20/10.%E6%97%A0%E6%B3%95%E5%81%9C%E6%AD%A2hadoop%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>问题描述：</p>
<p>执行 ./bin/stop-all.sh 脚本一直提示没有可停止的namenode、datanode、secondarynode。</p>
<p>可是输入 jps 命令，发现hadoop 已经启动。</p>
<p>原因：</p>
<p>hadoop在stop的时候依据的是datanode上的mapred和dfs进程号。而默认的进程号保存在/tmp下，linux默认会每 隔一段时间（一般是一个月或者7天左右）去删除这个目录下的文件。因此删掉hadoop-hadoop-jobtracker.pid和hadoop- hadoop-namenode.pid两个文件后，namenode自然就找不到datanode上的这两个进程了。</p>
<p>解决方法：</p>
<p>jps查看所有进程的pid，手动杀死进程 kill -9 pid，多个节点都需要操作！<br>为了避免下次也出现问题，在配置文件中$HADOOP_HOME/etc/hadoop/hadoop-env.sh中添加如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HADOOP_PID_DIR&#x3D;$&#123;HADOOP_HOME&#125;&#x2F;pids</span><br></pre></td></tr></table></figure>

<p>重启Hadoop集群，即可</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>DBWritable与Writable的坑</title>
    <url>/2020/01/18/9.DBWritable%E4%B8%8EWritable%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>export HADOOP_CLASSPATH=$HADOOP_CLASSPATH:~/lib/mysql-connector-java-5.1.28-bin.jar</p>
<h2 id="本地运行，从mysql读取数据跑mapreduce"><a href="#本地运行，从mysql读取数据跑mapreduce" class="headerlink" title="本地运行，从mysql读取数据跑mapreduce"></a>本地运行，从mysql读取数据跑mapreduce</h2><p><strong>接口实现不仅仅要实现DBWritable，还应当实现Writable！！！**</strong></p>
<p>DeptWritable.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.hadoop.io.Writable;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.db.DBWritable;</span><br><span class="line"></span><br><span class="line">import java.io.DataInput;</span><br><span class="line">import java.io.DataOutput;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * author：若泽数据-PK哥</span><br><span class="line"> * 交流群：545916944</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DeptWritable implements Writable, DBWritable &#123;</span><br><span class="line">    private int deptid;</span><br><span class="line">    private int deptno;</span><br><span class="line">    private String dname;</span><br><span class="line">    private String loc;</span><br><span class="line"></span><br><span class="line">    public DeptWritable()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public DeptWritable(int deptid, int deptno,String dname,String loc)&#123;</span><br><span class="line">        this.deptid &#x3D; deptid;</span><br><span class="line">        this.deptno &#x3D; deptno;</span><br><span class="line">        this.dname &#x3D; dname;</span><br><span class="line">        this.loc &#x3D; loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getDeptid() &#123;</span><br><span class="line">        return deptid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDeptid(int deptid) &#123;</span><br><span class="line">        this.deptid &#x3D; deptid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getDeptno() &#123;</span><br><span class="line">        return deptno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDeptno(int deptno) &#123;</span><br><span class="line">        this.deptno &#x3D; deptno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDname() &#123;</span><br><span class="line">        return dname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDname(String dname) &#123;</span><br><span class="line">        this.dname &#x3D; dname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLoc() &#123;</span><br><span class="line">        return loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLoc(String loc) &#123;</span><br><span class="line">        this.loc &#x3D; loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void write(PreparedStatement statement) throws SQLException &#123;</span><br><span class="line">        statement.setInt(1,deptid);</span><br><span class="line">        statement.setInt(2,deptno);</span><br><span class="line">        statement.setString(3,dname);</span><br><span class="line">        statement.setString(4,loc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void readFields(ResultSet resultSet) throws SQLException &#123;</span><br><span class="line">        deptid &#x3D; resultSet.getInt(1);</span><br><span class="line">        deptno &#x3D; resultSet.getInt(2);</span><br><span class="line">        dname &#x3D; resultSet.getString(3);</span><br><span class="line">        loc &#x3D; resultSet.getString(4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void write(DataOutput out) throws IOException &#123;</span><br><span class="line">        out.writeInt(deptid);</span><br><span class="line">        out.writeInt(deptno);</span><br><span class="line">        out.writeUTF(dname);</span><br><span class="line">        out.writeUTF(loc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void readFields(DataInput in) throws IOException &#123;</span><br><span class="line">        this.deptid &#x3D; in.readInt();</span><br><span class="line">        this.deptno &#x3D; in.readInt();</span><br><span class="line">        this.dname &#x3D; in.readUTF();</span><br><span class="line">        this.loc &#x3D; in.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return deptid + &quot;\t&quot;</span><br><span class="line">                + &quot;\t&quot; + deptno</span><br><span class="line">                + &quot;\t&quot; + dname</span><br><span class="line">                + &quot;\t&quot; + loc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>MySQLReadDriver.java（该方案可以在本地运行，但打成瘦包后在服务器上不能运行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ruozedata.bigdata.hadoop.utils.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.db.DBConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.db.DBInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLReadDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String output = <span class="string">"out"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1）获取Job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line"><span class="comment">//        configuration.set(DBConfiguration.DRIVER_CLASS_PROPERTY, "com.mysql.jdbc.Driver");</span></span><br><span class="line">        DBConfiguration.configureDB(configuration, <span class="string">"com.mysql.jdbc.Driver"</span>, <span class="string">"jdbc:mysql://hadoop000:3306/sqoop"</span>, <span class="string">"hadoop"</span>, <span class="string">"hadoop"</span>);</span><br><span class="line"></span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line">        FileUtils.deleteOutput(configuration, output);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2）本job对应要执行的主类是哪个</span></span><br><span class="line">        job.setJarByClass(MySQLReadDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3）设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4）设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(DeptWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6）设置输入和输出路径</span></span><br><span class="line">        String[] fields = &#123;<span class="string">"id"</span>, <span class="string">"deptno"</span>, <span class="string">"dname"</span>, <span class="string">"loc"</span>&#125;;</span><br><span class="line">        DBInputFormat.setInput(job, DeptWritable.class, "dept", null, null, fields);</span><br><span class="line"></span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7）提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">DeptWritable</span>, <span class="title">NullWritable</span>, <span class="title">DeptWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, DeptWritable value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            context.write(NullWritable.get(), value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>MySQLReadDriverv2.java（该方案打成瘦包后可以在服务器上运行）</p>
<p><strong>extends Configured implements Tool</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ruozedata.bigdata.hadoop.utils.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configured;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.db.DBConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.db.DBInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.Tool;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLReadDriverV2</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="keyword">int</span> run = ToolRunner.run(configuration, <span class="keyword">new</span> MySQLReadDriverV2(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String output = <span class="string">"out"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1）获取Job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">super</span>.getConf();</span><br><span class="line"><span class="comment">//        configuration.set(DBConfiguration.DRIVER_CLASS_PROPERTY, "com.mysql.jdbc.Driver");</span></span><br><span class="line">        DBConfiguration.configureDB(configuration, <span class="string">"com.mysql.jdbc.Driver"</span>, <span class="string">"jdbc:mysql://hadoop000:3306/sqoop"</span>, <span class="string">"hadoop"</span>, <span class="string">"4WOzuishuai"</span>);</span><br><span class="line"></span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line">        FileUtils.deleteOutput(configuration, output);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2）本job对应要执行的主类是哪个</span></span><br><span class="line">        job.setJarByClass(MySQLReadDriverV2<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3）设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4）设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(DeptWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6）设置输入和输出路径</span></span><br><span class="line">        String[] fields = &#123;<span class="string">"id"</span>, <span class="string">"deptno"</span>, <span class="string">"dname"</span>, <span class="string">"loc"</span>&#125;;</span><br><span class="line">        DBInputFormat.setInput(job, DeptWritable.class, "dept", null, null, fields);</span><br><span class="line"></span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7）提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">DeptWritable</span>, <span class="title">NullWritable</span>, <span class="title">DeptWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, DeptWritable value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            context.write(NullWritable.get(), value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql5.6安装</title>
    <url>/2020/01/15/8.mysql5.6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>本次操作在centos7.2版本的服务器上成功实现，本文不涉及rpm和源码安装2种方式，本文采用二进制安装</p>
<h2 id="1-首先我们需要卸载内置的mariadb"><a href="#1-首先我们需要卸载内置的mariadb" class="headerlink" title="1.首先我们需要卸载内置的mariadb"></a>1.首先我们需要卸载内置的mariadb</h2><p>原因是以前的Linux系统中数据库大部分是mysql，不过自从被sun收购之后，就没用集成在centos这些开源Linux系统中了，那么如果想用的话就需要自己安装了，首先centos7 已经不支持mysql，因为收费了你懂得，所以内部集成了mariadb，而安装mysql的话会和mariadb的文件冲突，所以需要先卸载掉mariadb</p>
<p>操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum search mysql &#x2F;&#x2F;检查是否有mariadb.x86_64</span><br><span class="line"># yum remove mariadb-libs.x86_64</span><br></pre></td></tr></table></figure>



<h2 id="2-下载mysql"><a href="#2-下载mysql" class="headerlink" title="2.下载mysql"></a>2.下载mysql</h2><p>安装包：mysql-5.6.47-linux-glibc2.12-x86_64.tar.gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 下载</span><br><span class="line"># wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;Downloads&#x2F;MySQL-5.6&#x2F;mysql-5.6.47-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line">&#x2F;&#x2F; 解压</span><br><span class="line"># tar -zxvf mysql-5.6.47-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line">&#x2F;&#x2F; 复制解压后的mysql目录</span><br><span class="line"># cp -r mysql-5.6.47-linux-glibc2.12-x86_64 &#x2F;usr&#x2F;local&#x2F;mysql</span><br></pre></td></tr></table></figure>



<h2 id="3-添加用户组和用户"><a href="#3-添加用户组和用户" class="headerlink" title="3.添加用户组和用户"></a>3.添加用户组和用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;添加用户组</span><br><span class="line"># groupadd mysql</span><br><span class="line">&#x2F;&#x2F;添加用户mysql 到用户组mysql</span><br><span class="line"># useradd -g mysql mysql</span><br></pre></td></tr></table></figure>



<h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4.安装"></a>4.安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;</span><br><span class="line"># mkdir .&#x2F;data&#x2F;mysql</span><br><span class="line"># chown -R mysql:mysql .&#x2F;</span><br><span class="line"># .&#x2F;scripts&#x2F;mysql_install_db --user&#x3D;mysql --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql</span><br><span class="line"># cp support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br><span class="line"># chmod 755 &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br><span class="line"># cp support-files&#x2F;my-default.cnf &#x2F;etc&#x2F;my.cnf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;修改启动脚本</span><br><span class="line"># vi &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;修改项：</span><br><span class="line">basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;</span><br><span class="line">datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动服务</span><br><span class="line"># service mysqld start</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加入环境变量，编辑 &#x2F;etc&#x2F;profile，这样可以在任何地方用mysql命令了</span><br><span class="line"># export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;&#x2F;bin&lt;br&gt;source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动mysql</span><br><span class="line"># service mysqld start</span><br><span class="line">&#x2F;&#x2F;关闭mysql</span><br><span class="line"># service mysqld stop</span><br><span class="line">&#x2F;&#x2F;查看运行状态</span><br><span class="line"># service mysqld status</span><br></pre></td></tr></table></figure>



<p>可能出现的问题↓</p>
<p>问题1:：FATAL ERROR: please install the following Perl modules before executing</p>
<p>问题原因：缺少autoconf库</p>
<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install autoconf</span><br></pre></td></tr></table></figure>



<p>问题2：Installing MySQL system tables…./bin/mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory</p>
<p>问题原因：缺少libaio库文件</p>
<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install libaio*</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>手机流量统计-自定义序列化类</title>
    <url>/2020/01/14/7.%E6%89%8B%E6%9C%BA%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB/</url>
    <content><![CDATA[<p>Access.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Writable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInput;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutput;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Access</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> up;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> down;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone + <span class="string">'\t'</span> + up + <span class="string">'\t'</span> + down + <span class="string">'\t'</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Access</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Access</span><span class="params">(String phone, <span class="keyword">long</span> up, <span class="keyword">long</span> down)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        <span class="keyword">this</span>.up = up;</span><br><span class="line">        <span class="keyword">this</span>.down = down;</span><br><span class="line">        <span class="keyword">this</span>.sum = up + down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeUTF(phone);</span><br><span class="line">        dataOutput.writeLong(up);</span><br><span class="line">        dataOutput.writeLong(down);</span><br><span class="line">        dataOutput.writeLong(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = dataInput.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.up = dataInput.readLong();</span><br><span class="line">        <span class="keyword">this</span>.down = dataInput.readLong();</span><br><span class="line">        <span class="keyword">this</span>.sum = dataInput.readLong();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> up;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">(<span class="keyword">long</span> up)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.up = up;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDown</span><span class="params">(<span class="keyword">long</span> down)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.down = down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">(<span class="keyword">long</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SerDriver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ruozedata.bigdata.hadoop.utils.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 千篇一律</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 获取Job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 本job对应要执行的主类是哪个</span></span><br><span class="line">        job.setJarByClass(SerDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(MyReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(Access<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 设置Reducer阶段输出数据的类型</span></span><br><span class="line">        job.setOutputKeyClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(Access<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6) 设置输入和输出路径</span></span><br><span class="line">        String input = <span class="string">"data/access.log"</span>;</span><br><span class="line">        String output = <span class="string">"out"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FileUtils.deleteOutput(configuration, output);</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7) 提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Access</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String[] splits = value.toString().split(<span class="string">"\t"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手机号</span></span><br><span class="line">            String phone = splits[<span class="number">1</span>]; <span class="comment">//index是从0开始的</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上行流量</span></span><br><span class="line">            <span class="keyword">long</span> up = Long.parseLong(splits[splits.length - <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下行流量</span></span><br><span class="line">            <span class="keyword">long</span> down = Long.parseLong(splits[splits.length - <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写出去</span></span><br><span class="line"><span class="comment">//            Access access = new Access();</span></span><br><span class="line"><span class="comment">//            access.setPhone(phone);</span></span><br><span class="line"><span class="comment">//            access.setUp(up);</span></span><br><span class="line"><span class="comment">//            access.setDown(down);</span></span><br><span class="line"><span class="comment">//            access.setSum(up + down);</span></span><br><span class="line"></span><br><span class="line">            context.write(<span class="keyword">new</span> Text(phone), <span class="keyword">new</span> Access(phone, up, down));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">Access</span>, <span class="title">NullWritable</span>, <span class="title">Access</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text phone, Iterable&lt;Access&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> ups = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> downs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            Iterator&lt;Access&gt; iterator = values.iterator();</span></span><br><span class="line"><span class="comment">//            while(iterator.hasNext())&#123;</span></span><br><span class="line"><span class="comment">//                Access next = iterator.next();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(Access access : values)&#123;</span><br><span class="line">                ups += access.getUp();</span><br><span class="line">                downs += access.getDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            context.write(NullWritable.get(), <span class="keyword">new</span> Access(phone.toString(), ups, downs));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>hdfs简单API编程</title>
    <url>/2020/01/07/6.hdfs%E7%AE%80%E5%8D%95API%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.permission.FsPermission;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HDFSAPITest2</span> </span>&#123;</span><br><span class="line">    FileSystem fileSystem;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        URI uri = <span class="keyword">new</span> URI(<span class="string">"hdfs://hadoop:8020"</span>);</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line"></span><br><span class="line">        configuration.set(<span class="string">"dfs.client.use.datanode.hostname"</span>, <span class="string">"true"</span>);</span><br><span class="line">        configuration.set(<span class="string">"dfs.replication"</span>, <span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">// 1) 获取HDFS客户端</span></span><br><span class="line">        fileSystem = FileSystem.get(uri, configuration, <span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 3) 关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(fileSystem != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fileSystem.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mkdir</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        fileSystem.mkdirs(<span class="keyword">new</span> Path(<span class="string">"hdfs://hadoop:8020/hdfstest0"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFromLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Path src = <span class="keyword">new</span> Path(<span class="string">"data/ruozedata.txt"</span>);</span><br><span class="line">        Path dst = <span class="keyword">new</span> Path(<span class="string">"/hdfstest"</span>);</span><br><span class="line">        fileSystem.copyFromLocalFile(src, dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyToLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Path src = <span class="keyword">new</span> Path(<span class="string">"/20201011/146.txt"</span>);</span><br><span class="line">        Path dst = <span class="keyword">new</span> Path(<span class="string">"output/146.txt"</span>);</span><br><span class="line">        fileSystem.copyToLocalFile(src, dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rename</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Path src = <span class="keyword">new</span> Path(<span class="string">"/20201011/20201011-0.txt"</span>);</span><br><span class="line">        Path dst = <span class="keyword">new</span> Path(<span class="string">"/20201011/146.txt"</span>);</span><br><span class="line">        fileSystem.rename(src, dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RemoteIterator&lt;LocatedFileStatus&gt; files = fileSystem.listFiles(<span class="keyword">new</span> Path(<span class="string">"/20201011"</span>), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(files.hasNext())&#123;</span><br><span class="line">            LocatedFileStatus fileStatus = files.next();</span><br><span class="line">            String path = fileStatus.getPath().toString();</span><br><span class="line">            <span class="keyword">long</span> len = fileStatus.getLen();</span><br><span class="line">            <span class="keyword">short</span> replication = fileStatus.getReplication();</span><br><span class="line">            FsPermission permission = fileStatus.getPermission();</span><br><span class="line">            String isDir = fileStatus.isDirectory()? <span class="string">"文件夹"</span> : <span class="string">"文件"</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(path + <span class="string">"\t"</span> + len + <span class="string">"\t"</span> + replication + <span class="string">"\t"</span> + permission + <span class="string">"\t"</span> + isDir);</span><br><span class="line"></span><br><span class="line">            BlockLocation[] blockLocations = fileStatus.getBlockLocations();</span><br><span class="line">            <span class="keyword">for</span>(BlockLocation location : blockLocations)&#123;</span><br><span class="line">                String[] hosts = location.getHosts();</span><br><span class="line">                <span class="keyword">for</span>(String host : hosts)&#123;</span><br><span class="line">                    System.out.println(host + <span class="string">"........"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        fileSystem.delete(<span class="keyword">new</span> Path(<span class="string">"/hdfstest"</span>), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop单结点集群搭建</title>
    <url>/2020/01/06/5.hadoop%E5%8D%95%E7%BB%93%E7%82%B9%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>官网描述:<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="noopener">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html</a></p>
<p>本文在官网描述的基础上做翻译和细节补充</p>
<h2 id="hadoop部署"><a href="#hadoop部署" class="headerlink" title="hadoop部署"></a>hadoop部署</h2><p>类似于前一篇章的jdk部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf hadoop-2.6.0-cdh5.16.2.tar.gz -C ~&#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line">hadoop软件包常见目录说明</span><br><span class="line">	bin: hadoop客户端命令</span><br><span class="line">	etc: hadoop相关的配置文件存放目录</span><br><span class="line">	sbin:启动hadoop相关进程的脚本</span><br><span class="line">	share:常用例子</span><br><span class="line"></span><br><span class="line">配置.bash_profile</span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;hadoop-2.6.0-cdh5.16.2</span><br><span class="line">export PATH&#x3D;$HADOOP_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>



<p>修改相关的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop-env.sh内需要配置JAVA_HOME</span><br><span class="line">localhost:8020中的localhost需要修改</span><br><span class="line"></span><br><span class="line">core-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hdfs:&#x2F;&#x2F;hadoop000:8020&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">hdfs-site.xml</span><br><span class="line">其中hadoop.tmp.dir修改是因为机器每次重启时候会清空tmp目录</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">slaves</span><br><span class="line">	mxh(设置成你喜欢的就行了，注意需要与hostname一致)</span><br></pre></td></tr></table></figure>



<p>启动HDFS：第一次执行的时候一定要格式化文件系统，不要重复执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>


<p>启动集群</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$HADOOP_HOME&#x2F;sbin&#x2F;start-dfs.sh</span><br><span class="line">验证:</span><br><span class="line">#jps</span><br><span class="line">8148 NameNode</span><br><span class="line">8245 DataNode</span><br><span class="line">8540 SecondaryNameNode</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop学习前置部署</title>
    <url>/2020/01/04/4.hadoop%E5%AD%A6%E4%B9%A0%E5%89%8D%E6%9C%9F%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="jdk部署"><a href="#jdk部署" class="headerlink" title="jdk部署"></a>jdk部署</h2><p><strong>Hadoop安装前置要求Java版本在1.8+</strong></p>
<p>安装过程（本过程在root用户下进行，非root用户目录有轻微变动）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拷贝本地软件包到服务器（wget等方法均可）</span><br><span class="line"></span><br><span class="line">解压jdk:</span><br><span class="line"># tar -zvxf jdk-8u231-linux-x64.tar.gz -C ~&#x2F;app&#x2F;</span><br><span class="line"># 解压的包放置在app文件夹内，根据个人需要选择</span><br><span class="line"></span><br><span class="line">把jdk配置在系统环境变量中: ~&#x2F;.bash_profile</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;jdk1.8.0_231</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">之后source一下使其生效:source .bash_profile</span><br><span class="line">可以通过echo $JAVA_HOME检查是否生效</span><br><span class="line">提示：此处&#x3D;左右不可有空格</span><br></pre></td></tr></table></figure>



<h2 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ssh-keygen -t rsa  #一路回车</span><br><span class="line">此时.ssh文件夹下有3个新文件</span><br><span class="line">id_rsa          # 私钥</span><br><span class="line">id_rsa.pub      # 公钥</span><br><span class="line">known_hosts     # </span><br><span class="line"></span><br><span class="line"># cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line"># chmod 600 authorized_keys</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>linux用户管理</title>
    <url>/2019/12/30/3.linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="简易命令"><a href="#简易命令" class="headerlink" title="简易命令"></a>简易命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd testuser  创建用户testuser</span><br><span class="line">passwd testuser  给已创建的用户testuser设置密码</span><br><span class="line">说明：新创建的用户会在&#x2F;home下创建一个用户目录testuser</span><br><span class="line">usermod --help  修改用户这个命令的相关参数</span><br><span class="line">userdel testuser  删除用户testuser</span><br><span class="line">rm -rf testuser  删除用户testuser所在目录</span><br></pre></td></tr></table></figure>



<h2 id="给用户添加root权限"><a href="#给用户添加root权限" class="headerlink" title="给用户添加root权限"></a>给用户添加root权限</h2><p>使用Linux系统时，经常会被要求使用超级权限，但是root的权限太过大了，一般慎用！！！因此可以通过给普通用户添加sudo权限，平常用普通用户进行操作，当需要root权限的时候进行sudo操作。以下为解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 进入超级用户模式，也就是输入”su root”，系统会让你输入超级用户密码，输入密码后就进入了超级用户模式。（当然，你也可以直接用root进入修改）</span><br><span class="line">2. 添加文件的写权限，也就是输入命令”chmod u+w &#x2F;etc&#x2F;sudoers”。</span><br><span class="line">3. 编辑&#x2F;etc&#x2F;sudoers文件，也就是输入命令”vim &#x2F;etc&#x2F;sudoers”，进入编辑模式，找到这一 行：”root ALL&#x3D;(ALL) ALL”（会用vim编辑器的可以使用“&#x2F;root ALL&#x3D;(ALL)ALL”定位）在其下面添加”xxx ALL&#x3D;(ALL) ALL”(这里的xxx是你的用户名)，然后保存退出。</span><br><span class="line">4. 撤销文件的写权限，也就是输入命令”chmod u-w &#x2F;etc&#x2F;sudoers”。</span><br></pre></td></tr></table></figure>



<h2 id="修改hostname"><a href="#修改hostname" class="headerlink" title="修改hostname"></a>修改hostname</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hostnamectl set-hostname &lt;newhostname&gt;</span><br></pre></td></tr></table></figure>





<h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><p>用户：使用操作系统的人</p>
<p>用户组：具有相同系统权限的一组用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;group 存储当前系统中所有用户组信息</span><br><span class="line">- Group:     x    : 123 : abc,def,xyz</span><br><span class="line">- 组名称:组密码占位符:组编号:组中用户列表名</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;gshadow 存储当前系统中用户组的密码信息</span><br><span class="line">- Group:  *  :       :abc,def,xyz</span><br><span class="line">- 组名称:组密码:组管理者:组中用户列表名</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;passwd 存储当前系统中所有用户的信息</span><br><span class="line">- user :    x   :   123 :   456   : xxxxxxx : &#x2F;home&#x2F;user : &#x2F;bin&#x2F;bash</span><br><span class="line">- 用户名:密码占位符:用户编号:用户组编号:用户注释信息: 用户主目录  : shell类型</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;shadow 存储当前系统中所有用户的密码信息</span><br><span class="line">- user : xxx :::::</span><br><span class="line">- 用户名: 密码 ::::</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一套样例</span><br><span class="line"></span><br><span class="line"># groupadd sexy 创建sexy用户组</span><br><span class="line"># groupadd -n market sexy 用sexy组名改为market</span><br><span class="line"># groupmod -g 668 market 修改market用户组编号</span><br><span class="line"># groupadd -g 888 boss 创建boss用户组，编号为888</span><br><span class="line"># groupdel market 删除market用户组</span><br><span class="line"># useradd -g sexy sdf 添加用户</span><br><span class="line"># useradd -g sexy jzmb</span><br><span class="line"># useradd -d &#x2F;home&#x2F;xxx imooc 添加用户并指定用户文件夹所在位置</span><br><span class="line"># usermod -c dgdzmx sdf 修改sdf注释</span><br><span class="line"># usermod -l cls sdf 用户名sdf更改为cls</span><br><span class="line"># usermod -d &#x2F;home&#x2F;cls cls 修改cls文件夹路径</span><br><span class="line"># usermod -g sexy imooc imooc切换进sexy用户组</span><br><span class="line"># userdel jzmb 删除jzmb账号</span><br><span class="line"># userdel -r jzmb 删除jzmb用户文件夹</span><br><span class="line"></span><br><span class="line">touch &#x2F;etc&#x2F;nologin 禁止root以外的其他账户登录</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd -l cls 锁定cls</span><br><span class="line"># passwd -u cls 解锁cls</span><br><span class="line"># passwd -d cls cls账户无密码登录</span><br></pre></td></tr></table></figure>



<h2 id="主要组和附属组"><a href="#主要组和附属组" class="headerlink" title="主要组和附属组"></a>主要组和附属组</h2><p>用户可以同时属于多个组</p>
<ul>
<li>一个主要组</li>
<li>多个附属组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一套样例</span><br><span class="line"></span><br><span class="line"># gpasswd -a cls boss boss组变为cls的附属组,用逗号可以添加多个附属组</span><br><span class="line"># newgrp boss （cls自己执行，切换到boss组）</span><br><span class="line"># gpasswd -a cls boss cls不在是boss组的附属组</span><br></pre></td></tr></table></figure>







<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>权限</tag>
        <tag>用户</tag>
      </tags>
  </entry>
  <entry>
    <title>frp实现内网穿透</title>
    <url>/2019/12/29/%EF%BC%812.frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;对于没有公网ip的内网用户来说，远程管理或在外网访问内网机器上的服务是一个比较麻烦的问题，为了解决这个问题，我介绍一款相当好用的内网穿透工具frp。<br>&emsp;&emsp;frp 是一个使用 Go 语言开发的高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务。FRP 支持 TCP、UDP、HTTP、HTTPS等协议类型，并且支持 Web 服务根据域名进行路由转发。<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frp项目地址: https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp</span><br></pre></td></tr></table></figure>



<h1 id="frp的作用"><a href="#frp的作用" class="headerlink" title="frp的作用"></a>frp的作用</h1><p>1.利用处于内网或防火墙后的机器，对外网环境提供 HTTP 或 HTTPS 服务。</p>
<p>2.对于 HTTP, HTTPS 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个 80 端口。</p>
<p>3.利用处于内网或防火墙后的机器，对外网环境提供 TCP 和 UDP 服务，例如在家里通过 SSH 访问处于公司内网环境内的主机。</p>
<h1 id="frp安装"><a href="#frp安装" class="headerlink" title="frp安装"></a>frp安装</h1><p>FRP 采用 Go 语言开发，支持 Windows、Linux、MacOS、ARM等多平台部署。FRP 安装非常容易，只需下载对应系统平台的软件包，并解压就可用。</p>
<p>这里以 Linux 为例，为了方便管理我们把解压后的目录重命名为 frp ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.30.0&#x2F;frp_0.30.0_linux_amd64.tar.gz</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>新篇章，新世界</title>
    <url>/2019/12/23/1.hello-world/</url>
    <content><![CDATA[<p>&emsp;&emsp;我在之前的hexo博客中写了50+篇文章，但质量都不太让我满意，解决问题的效率甚至比不上百度，恰巧之前的文档因操作失误丢失了，于是我就重置了整个博客内容从零开始</p>
<p>&emsp;&emsp;今后的每一篇文章我都会尽心尽力而为，不灌水，如果对文章有问题或者想要交流的小伙伴，可以加我的qq或给我发送邮件进行联系。</p>
<p>&emsp;&emsp;那么，加油！</p>
<p>hexo搭建及相关教程可参考这→ <a href="https://io-oi.me/tech/hexo-next-optimization/" target="_blank" rel="noopener">https://io-oi.me/tech/hexo-next-optimization/</a></p>
<p>在线工具合集→<a href="https://tool.lu/" target="_blank" rel="noopener">https://tool.lu/</a></p>
<p>个人大数据配置留存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATH&#x3D;$PATH:$HOME&#x2F;.local&#x2F;bin:$HOME&#x2F;bin</span><br><span class="line"></span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">export HADOOP_CLASSPATH&#x3D;$&#123;HADOOP_CLASSPATH&#125;:&#x2F;home&#x2F;pearfl&#x2F;lib&#x2F;*</span><br><span class="line"></span><br><span class="line">export MYSQL_HOME&#x3D;$PATH:&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;mysql-5.6.47</span><br><span class="line">export PATH&#x3D;$MYSQL_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;jdk1.8.0_231</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;hadoop-2.6.0-cdh5.16.2</span><br><span class="line">export PATH&#x3D;$HADOOP_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">export HIVE_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;apache-hive-1.1.0-cdh5.16.2-bin</span><br><span class="line">export PATH&#x3D;$HIVE_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">export MAVEN_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;apache-maven-3.6.3</span><br><span class="line">export PATH&#x3D;$MAVEN_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">export ZOOKEEPER_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;zookeeper-3.4.5-cdh5.16.2</span><br><span class="line">export PATH&#x3D;$ZOOKEEPER_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">export HUE_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;hue-3.9.0-cdh5.16.2</span><br><span class="line">export PATH&#x3D;$HUE_HOME&#x2F;build&#x2F;env&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">export FLUME_HOME&#x3D;&#x2F;home&#x2F;pearfl&#x2F;app&#x2F;apache-flume-1.6.0-cdh5.16.2-bin</span><br><span class="line">export PATH&#x3D;$FLUME_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>个人感想</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
