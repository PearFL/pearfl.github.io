<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode-java基础技巧</title>
    <url>/2020/02/06/%EF%BC%8126.leetcode-java%E5%9F%BA%E7%A1%80%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>之前打算法竞赛一直是用C+STL，包括牛客网上写题练习也是用这个方式来解决的，长期习惯了以后，开始对java刷题甚至产生了排斥……但鉴于java以后肯定是要常用的，因此必须矫正这个问题</p>
<p>本篇博文讲述刷leetcode过程中采用java语言遇到的坑，明明一眼就知道该怎么写但不能用其他语言写出来就是不行啊！</p>
<p>根据自己经验，有竞赛基础的建议直接从周赛题开始摸坑=3=（倒着刷）</p>
<p>（本文长期更新）</p>
<h2 id="1-String转int、long"><a href="#1-String转int、long" class="headerlink" title="1.String转int、long"></a>1.String转int、long</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">int</span> n1 = Integer.parseInt(s);</span><br><span class="line"><span class="keyword">long</span> n2 = Long.parseLong(s);</span><br></pre></td></tr></table></figure>



<h2 id="2-StringBuffer"><a href="#2-StringBuffer" class="headerlink" title="2.StringBuffer"></a>2.StringBuffer</h2><p>StringBuffer类和String一样，也用来代表字符串，只是由于StringBuffer的内部实现方式和String不同，所以StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些.</p>
<p>StringBuffer与String有一个显著的区别：<strong>StringBuffer对象的每次修改都会改变对象自身</strong></p>
<p>StringBuffer是线程安全的，所以在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些</p>
<p>1.String转StringBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<p>2.append方法，将内容追加到StringBuffer末尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">s.append(<span class="string">"efg"</span>);</span><br><span class="line">System.out.println(s.toString());</span><br></pre></td></tr></table></figure>

<p>3.delete方法</p>
<p>deleteCharAt(int index)<br>该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。第一位为0<br>s.delete(int start,int end)<br>该方法的作用是删除指定区间以内的所有字符，包含start，不包含end索引值的区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">s.append(<span class="string">"efg"</span>);</span><br><span class="line">s.deleteCharAt(<span class="number">2</span>);</span><br><span class="line">s.delete(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(s.toString());</span><br></pre></td></tr></table></figure>

<p>4.insert方法</p>
<p>StringBuffer insert(int offset, String str)<br>该方法的作用是在StringBuffer对象中插入内容，然后形成新的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"TestString"</span>);</span><br><span class="line">sb.insert(<span class="number">4</span>,<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>

<p>5.reverse方法</p>
<p>StringBuffer reverse()<br>该方法的作用是将StringBuffer对象中的内容反转，然后形成新的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"TestString"</span>);</span><br><span class="line">sb.reverse();</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>

<p>6.setCharAt方法</p>
<p>setCharAt(int index, char ch)<br>该方法的作用是修改对象中索引值为index位置的字符为新的字符ch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"bc"</span>);</span><br><span class="line">sb.setCharAt(<span class="number">1</span>,<span class="string">'D'</span>);</span><br></pre></td></tr></table></figure>



<h2 id="3-数组排序"><a href="#3-数组排序" class="headerlink" title="3.数组排序"></a>3.数组排序</h2><p>Arrays.Sort() 快排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arrayToSort = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">48</span>, <span class="number">5</span>, <span class="number">89</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">16</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    System.out.println(<span class="string">"排序前"</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayToSort.length; i++) System.out.println(arrayToSort[i]); <span class="comment">// 调用数组的静态排序方法sort </span></span><br><span class="line">    Arrays.sort(arrayToSort); </span><br><span class="line">    System.out.println(<span class="string">"排序后"</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayToSort.length; i++) System.out.println(arrayToSort[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Collections.sort(，new comparator&lt;&gt;(){重写compare方法})</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Collections.sort(intervals,<span class="keyword">new</span> Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval i1,Interval i2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i1.start-i2.start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//按某一关键字 从小到大排序</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop之jps详解</title>
    <url>/2020/02/06/25.hadoop%E4%B9%8Bjps%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>jps最主要的功能使查看java接口的进程号</strong></p>
<p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有 java 进程 pid 的命令，简单实用，非常适合在 linux/unix 平台上简单察看当前java进程的一些简单情况。</p>
<p>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令</p>
<h2 id="jps常用参数"><a href="#jps常用参数" class="headerlink" title="jps常用参数"></a>jps常用参数</h2><p>1.命令jps类似于Linux下的ps，但它只用于列出Java的进程。直接运行jps不加任何参数，可以列出Java程序的进程ID以及Main函数等名称。</p>
<p>其中一个输出jps就是jps命令本身，这更加证明此命令的本质也是一个Java程序</p>
<p>2.参数-q 指定jps只输出进程ID，而不输出类的短名称</p>
<p>3.参数-m 用于输出传递给Java进程（主函数）的参数</p>
<p>4.参数-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</p>
<p>5.参数-v 可以显示传递给JVM的参数</p>
<h2 id="问题：process-information-unavailable"><a href="#问题：process-information-unavailable" class="headerlink" title="问题：process information unavailable"></a>问题：process information unavailable</h2><p>1.找到进程号jps</p>
<p>2.ps -ef|grep pid是否存在（这步很关键要做判断查看进程是否存在）</p>
<p>3.假如进程不存在，我们可以去该/tmp/hsperfdata_xxx去删除</p>
<p>4.如果存在千万别删，自己查看是不可以的，其他用户查看是可用的。</p>
<p>5不存在举例：我不知道是这个进程是属于哪个用户的我们怎么操作呢？ps -ef|grep pid查看进程号属于哪个目录删除就可了</p>
<p>6.如果存在ps -ef |grep pid 看到了用户名，su 切换过去jps一下就好了</p>
<h2 id="关于jps的一些总结"><a href="#关于jps的一些总结" class="headerlink" title="关于jps的一些总结"></a>关于jps的一些总结</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop用户启动的 .&#x2F;start-dfs.sh  jps后可以看到进程,</span><br><span class="line">root用户看到的就是5235 -- process information unavailable,</span><br><span class="line">ps -ef| grep 5235 看的到是hadoop用户的这个进程还在,</span><br><span class="line">那这个状态就是假死,因为进程还在,所以说root用户是看不到hadoop启动的jps进程,</span><br><span class="line">只有root用户启动hdfs才能看到jps下的三个进程,</span><br><span class="line"></span><br><span class="line">root 使用jps只有两种情况：</span><br><span class="line"></span><br><span class="line">第一种: 查看正常信息</span><br><span class="line">第二种: - process information unavailable</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS最常用命令及快捷键整理</title>
    <url>/2020/02/06/24.Centos%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd &#x2F;home					进入 &#39;&#x2F;home&#39; 目录</span><br><span class="line"># cd ..						返回上一级目录</span><br><span class="line"># cd ..&#x2F;..					返回上两级目录</span><br><span class="line"># cd -						返回上次所在目录</span><br><span class="line"># cp file1 file2			将file1复制为file2</span><br><span class="line"># cp -a dir1 dir2			复制一个目录</span><br><span class="line"># cp -a &#x2F;tmp&#x2F;dir1 .			复制一个目录到当前工作目录（.代表当前目录）</span><br><span class="line"># ls						查看目录中的文件</span><br><span class="line"># ls -a						显示隐藏文件</span><br><span class="line"># ls -l						显示详细信息</span><br><span class="line"># ls -lrt					按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序）</span><br><span class="line"># pwd						显示工作路径</span><br><span class="line"># mkdir dir1				创建 &#39;dir1&#39; 目录</span><br><span class="line"># mkdir dir1 dir2			同时创建两个目录</span><br><span class="line"># mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2	创建一个目录树</span><br><span class="line"># mv dir1 dir2				移动&#x2F;重命名一个目录</span><br><span class="line"># rm -f file1				删除 &#39;file1&#39;</span><br><span class="line"># rm -rf dir1				删除 &#39;dir1&#39; 目录及其子目录内容</span><br></pre></td></tr></table></figure>



<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat file1					从第一个字节开始正向查看文件的内容</span><br><span class="line"># head -2 file1				查看一个文件的前两行</span><br><span class="line"># more file1				查看一个长文件的内容</span><br><span class="line"># tac file1					从最后一行开始反向查看一个文件的内容</span><br><span class="line"># tail -3 file1				查看一个文件的最后三行</span><br></pre></td></tr></table></figure>



<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep str &#x2F;tmp&#x2F;test		在文件 &#39;&#x2F;tmp&#x2F;test&#39; 中查找 &quot;str&quot;</span><br><span class="line"># grep ^str &#x2F;tmp&#x2F;test		在文件 &#39;&#x2F;tmp&#x2F;test&#39; 中查找以 &quot;str&quot; 开始的行</span><br><span class="line"># grep [0-9] &#x2F;tmp&#x2F;test		查找 &#39;&#x2F;tmp&#x2F;test&#39; 文件中所有包含数字的行</span><br><span class="line"># grep str -r &#x2F;tmp&#x2F;*		在目录 &#39;&#x2F;tmp&#39; 及其子目录中查找 &quot;str&quot;</span><br><span class="line"># diff file1 file2			找出两个文件的不同处</span><br><span class="line"># sdiff file1 file2			以对比的方式显示两个文件的不同</span><br></pre></td></tr></table></figure>



<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find &#x2F; -name file1				从 &#39;&#x2F;&#39; 开始进入根文件系统查找文件和目录</span><br><span class="line"># find &#x2F; -user user1				查找属于用户 &#39;user1&#39; 的文件和目录</span><br><span class="line"># find &#x2F;home&#x2F;user1 -name \*.bin		在目录 &#39;&#x2F; home&#x2F;user1&#39; 中查找以 &#39;.bin&#39; 结尾的文件</span><br><span class="line"># find &#x2F;usr&#x2F;bin -type f -atime +100	查找在过去100天内未被使用过的执行文件</span><br><span class="line"># find &#x2F;usr&#x2F;bin -type f -mtime -10	查找在10天内被创建或者修改过的文件</span><br><span class="line"># locate \*.ps						寻找以 &#39;.ps&#39; 结尾的文件，先运行 &#39;updatedb&#39; 命令</span><br><span class="line"># find -name &#39;*.[ch]&#39; | xargs grep -E &#39;expr&#39;	在当前目录及其子目录所有.c和.h文件中查找 &#39;expr&#39;</span><br><span class="line"># find -type f -print0 | xargs -r0 grep -F &#39;expr&#39;	在当前目录及其子目录的常规文件中查找 &#39;expr&#39;</span><br><span class="line"># find -maxdepth 1 -type f | xargs grep -F &#39;expr&#39;	在当前目录中查找 &#39;expr&#39;</span><br></pre></td></tr></table></figure>



<h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bzip2 file1							压缩 file1</span><br><span class="line"># bunzip2 file1.bz2						解压 file1.bz2</span><br><span class="line"># gzip file1							压缩 file1</span><br><span class="line"># gzip -9 file1							最大程度压缩 file1</span><br><span class="line"># gunzip file1.gz						解压 file1.gz</span><br><span class="line"># tar -cvf archive.tar file1			把file1打包成 archive.tar</span><br><span class="line">（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数）</span><br><span class="line"># tar -cvf archive.tar file1 dir1		把 file1，dir1 打包成 archive.tar</span><br><span class="line"># tar -tf archive.tar					显示一个包中的内容</span><br><span class="line"># tar -xvf archive.tar					释放一个包</span><br><span class="line"># tar -xvf archive.tar -C &#x2F;tmp			把压缩包释放到 &#x2F;tmp目录下</span><br><span class="line"># zip file1.zip file1					创建一个zip格式的压缩包</span><br><span class="line"># zip -r file1.zip file1 dir1			把文件和目录压缩成一个zip格式的压缩包</span><br><span class="line"># unzip file1.zip						解压一个zip格式的压缩包到当前目录</span><br><span class="line"># unzip test.zip -d &#x2F;tmp&#x2F;				解压一个zip格式的压缩包到 &#x2F;tmp 目录</span><br></pre></td></tr></table></figure>



<h2 id="yum工具"><a href="#yum工具" class="headerlink" title="yum工具"></a>yum工具</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum -y install [package]				下载并安装一个rpm包</span><br><span class="line"># yum localinstall [package.rpm]		安装一个rpm包，使用你自己的软件仓库解决所有依赖关系</span><br><span class="line"># yum -y update							更新当前系统中安装的所有rpm包</span><br><span class="line"># yum update [package]					更新一个rpm包</span><br><span class="line"># yum remove [package]					删除一个rpm包</span><br><span class="line"># yum list								列出当前系统中安装的所有包</span><br><span class="line"># yum search [package]					在rpm仓库中搜寻软件包</span><br><span class="line"># yum clean [package]					清除缓存目录（&#x2F;var&#x2F;cache&#x2F;yum）下的软件包</span><br><span class="line"># yum clean headers						删除所有头文件</span><br><span class="line"># yum clean all							删除所有缓存的包和头文件</span><br></pre></td></tr></table></figure>



<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ifconfig eth0										显示一个以太网卡的配置</span><br><span class="line"># ifconfig eth0 192.168.1.1 netmask 255.255.255.0	配置网卡的IP地址</span><br><span class="line"># ifdown eth0										禁用 &#39;eth0&#39; 网络设备</span><br><span class="line"># ifup eth0											启用 &#39;eth0&#39; 网络设备</span><br><span class="line"># iwconfig eth1										显示一个无线网卡的配置</span><br><span class="line"># iwlist scan										显示无线网络</span><br><span class="line"># ip addr show										显示网卡的IP地址</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># su -						切换到root权限（与su有区别）</span><br><span class="line"># shutdown -h now			关机</span><br><span class="line"># shutdown -r now			重启</span><br><span class="line"># top						罗列使用CPU资源最多的linux任务 （输入q退出）</span><br><span class="line"># pstree					以树状图显示程序</span><br><span class="line"># man ping					查看参考手册（例如ping 命令）</span><br><span class="line"># passwd					修改密码</span><br><span class="line"># df -h						显示磁盘的使用情况</span><br><span class="line"># cal -3					显示前一个月，当前月以及下一个月的月历</span><br><span class="line"># cal 10 1988				显示指定月，年的月历</span><br><span class="line"># date --date &#39;1970-01-01 UTC 1427888888 seconds&#39;	把一相对于1970-01-01 00:00的秒数转换成时间</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive之UDF函数</title>
    <url>/2020/02/05/23.Hive%E4%B9%8BUDF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>官方文档：<a href="https://cwiki.apache.org/confluence/display/Hive/HivePlugins" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/HivePlugins</a></p>
<p>中文整理稍等~</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>数据倾斜解决方案</title>
    <url>/2020/02/04/22.%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>同key分发到同一个reduce去执行==&gt;skew</p>
<p>数据倾斜解决方案：打散再处理</p>
<p>假设原task要处理9000w的数据量，我们通过随机数打散为100份</p>
<p>==&gt; 原来都在一个reducetask中取处理的数据，被我们打散后变为9000w / 100</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chain:</span><br><span class="line">	第一个mr：key加随机数打散</span><br><span class="line">	data_8 100</span><br><span class="line">	data_1 200</span><br><span class="line">	data_2 300</span><br><span class="line">	data_4 200</span><br><span class="line">	第二个mr：第一个mr加的随机数去掉</span><br><span class="line">	data 100</span><br><span class="line">	data 200</span><br><span class="line">	data 300</span><br><span class="line">	data 200</span><br><span class="line">	</span><br><span class="line">	在第二个mr中的reduce来做最终的聚合操作</span><br><span class="line">	ruoze 800</span><br></pre></td></tr></table></figure>

<p>Hadoop不怕数据量大，就怕数据倾斜hhhhhhhhhhhhh（跑不动）</p>
<p>以统计某人的数字之和为例</p>
<p>数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mxh 	102</span><br><span class="line">mxh 	1042</span><br><span class="line">pearfl 	102222</span><br><span class="line">pearfl 	1000</span><br></pre></td></tr></table></figure>



<p>第一个mr</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainFirstDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String input = <span class="string">"data/chain/data.txt"</span>;</span><br><span class="line">        String output = <span class="string">"data/chain/first"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1:获取job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除已存在目录</span></span><br><span class="line">        FileUtils.deleteOutput(configuration,output);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2：本job对应执行的主类</span></span><br><span class="line">        job.setJarByClass(ChainFirstDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3）设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(MyReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        job.setNumReduceTasks(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4）设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5）设置Reducer阶段输出数据的类型</span></span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6）设置输入和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7）提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key,Text values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String[] splits = values.toString().split(<span class="string">"\t"</span>);</span><br><span class="line">            <span class="keyword">int</span> r = random.nextInt(<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(splits[<span class="number">0</span>].trim() + <span class="string">"_"</span> + r), <span class="keyword">new</span> IntWritable(Integer.parseInt(splits[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key,Iterable&lt;IntWritable&gt;values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(IntWritable value:values)&#123;</span><br><span class="line">                sum+=value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,<span class="keyword">new</span> IntWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第二个mr</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainSecondDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        String input = <span class="string">"data/chain/first"</span>;</span><br><span class="line">        String output = <span class="string">"data/chain/second"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1:获取job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除已存在目录</span></span><br><span class="line">        FileUtils.deleteOutput(configuration,output);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2：本job对应执行的主类</span></span><br><span class="line">        job.setJarByClass(ChainFirstDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3）设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(MyReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4）设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5）设置Reducer阶段输出数据的类型</span></span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6）设置输入和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7）提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key,Text values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String[] splits = values.toString().split(<span class="string">"\t"</span>);</span><br><span class="line">            <span class="keyword">int</span> index = splits[<span class="number">0</span>].lastIndexOf(<span class="string">"_"</span>);</span><br><span class="line">            String result = splits[<span class="number">0</span>].substring(<span class="number">0</span>, index);</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(result),<span class="keyword">new</span> IntWritable(Integer.parseInt(splits[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">IntWritable</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key,Iterable&lt;IntWritable&gt; values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(IntWritable value:values)&#123;</span><br><span class="line">                sum+=value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,<span class="keyword">new</span> IntWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>FileUtils补充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteOutput</span><span class="params">(Configuration configuration, String output)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileSystem fileSystem = FileSystem.get(configuration);</span><br><span class="line">        Path path = <span class="keyword">new</span> Path(output);</span><br><span class="line">        <span class="keyword">if</span>(fileSystem.exists(path))&#123;</span><br><span class="line">            fileSystem.delete(path, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive之Join详解</title>
    <url>/2020/02/03/21.Hive%E4%B9%8BJoin%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reduce&#x2F;Shuffle&#x2F;Common Join</span><br><span class="line">	join操作是在reduce端完成的</span><br><span class="line">Map Join</span><br><span class="line">	join操作是在map端完成的</span><br></pre></td></tr></table></figure>

<p>Map Join</p>
<p>join操作是在map端完成的，无Shuffle和Reduce</p>
<p>思路：小表加载到内存中，读取大表时，读一条和内存中的数据匹配一下</p>
<p>缺点：没办法处理大数据量的表，适合打表join小表</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的字典、集合</title>
    <url>/2020/02/02/%EF%BC%8120.Python%E7%9A%84%E5%AD%97%E5%85%B8%E3%80%81%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的列表、元组、字符串</title>
    <url>/2020/02/02/%EF%BC%8119.Python%E7%9A%84%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%A5%96%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表是用于存放若干元素的<strong>有序序列</strong>。列表使用方括号（<code>[]</code>）来表示，其中的元素写入方括号中，多个元素时用逗号分隔，如 <code>[1, &#39;go&#39;, [0.1, 0.2]]</code>。它的元素可以是任意数据类型，甚至也可以是个列表。</p>
<p>元素之间有顺序关系，每个元素都有自己的位置，每个位置从 0 开始依次标号，这个表示位置的数字叫作<strong>索引</strong>。</p>
<p>列表被创建之后，我们可以对它做很多操作，包括添加元素，删除元素，修改元素，查找元素等。</p>
<h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><p>1.创建空的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表 = []</span><br><span class="line"></span><br><span class="line">items = []</span><br></pre></td></tr></table></figure>



<p>2.创建包含元素的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表 = [元素<span class="number">1</span>, 元素<span class="number">2</span>, ..., 元素N]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>



<h3 id="列表元素的获取"><a href="#列表元素的获取" class="headerlink" title="列表元素的获取"></a>列表元素的获取</h3><p>1.通过索引获取元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元素 = 列表[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>]</span><br><span class="line">’c’</span><br></pre></td></tr></table></figure>



<p>2.通过元素获取索引</p>
<p>这种方式和上面相反，首先在列表中寻找元素，然后返回元素对应的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">索引 = 列表.index(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.index(‘c’)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>3.查看元素是否存在于列表中</p>
<p>要想查看元素是否存在于列表中，需要借助 Python 的关键字 <code>in</code>，使用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 元素 <span class="keyword">in</span> 列表</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘a’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘z’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>4.统计元素在列表中的个数</p>
<p>统计元素在列表中的个数，或者说是元素在列表中出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">个数 = 列表.count(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.count(<span class="number">5</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<h3 id="列表元素的添加"><a href="#列表元素的添加" class="headerlink" title="列表元素的添加"></a>列表元素的添加</h3><p>我们可以很灵活地向列表添加元素，如以追加的形式向列表末尾添加一个元素；以插入的形式向列表的任意位置插入元素；或者将一个列表中的所有元素批量的添加到另一个列表中。</p>
<p>1.向列表末尾追加元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.append(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.append(‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘b’, ‘c’]</span><br></pre></td></tr></table></figure>



<p>2.向列表的任意位置插入元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.insert(索引, 元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.insert(<span class="number">0</span>, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘c’, ‘a’, ‘b’]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.insert(<span class="number">2</span>, ‘d’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘c’, ‘a’, ‘d’, ‘b’]</span><br></pre></td></tr></table></figure>



<p>3.列表末尾追加另一个列表的所有元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.extend(另一列表)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.extend([‘c’, ‘d’, ‘e’])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘b’, ‘c’, ‘d’, ‘e’]</span><br></pre></td></tr></table></figure>



<h3 id="列表元素的删除"><a href="#列表元素的删除" class="headerlink" title="列表元素的删除"></a>列表元素的删除</h3><p>1.按索引删除元素</p>
<p><strong>pop(索引)</strong> 会将索引对应的元素从列表中删除，同时返回这个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元素 = 列表.pop(索引)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.pop(<span class="number">0</span>)</span><br><span class="line">’a’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘b’, ‘c’]</span><br></pre></td></tr></table></figure>

<p>也可以不传递索引，这样的话默认删除并返回最后一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.pop()</span><br><span class="line">’c’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘b’]</span><br></pre></td></tr></table></figure>



<p>2.按索引删除元素（<code>del</code> 方法)</p>
<p>删除一个列表元素也可以使用 Python 中的 <code>del</code> 关键字，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> 列表[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> letters[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘b’, ‘c’]</span><br></pre></td></tr></table></figure>



<p>3.直接删除元素</p>
<p>直接删除元素时，Python 会先在列表中遍历该元素，然后将匹配到的第一个元素删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.remove(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.remove(‘b’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘a’, ‘c’]</span><br></pre></td></tr></table></figure>



<p>4.清空所有元素</p>
<p>清空所有元素即是把列表元素全部删除，最后仅为列表仅为 <code>[]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.clear()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>



<h3 id="列表元素的修改"><a href="#列表元素的修改" class="headerlink" title="列表元素的修改"></a>列表元素的修改</h3><p>1.通过赋值修改列表元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表[索引] = 新元素</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>] = <span class="string">'d’</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; letters</span></span><br><span class="line"><span class="string">[‘a’, ‘b’, ‘d’]</span></span><br></pre></td></tr></table></figure>



<p>2.反转整个列表</p>
<p>反转整个列表会将所有的元素倒序排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.reverse()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [‘a’, ‘b’, ‘c’]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[‘c’, ‘b’, ‘a’]</span><br></pre></td></tr></table></figure>



<p>3.列表元素排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.sort()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>也可以通过指定 <code>sort</code> 方法的 <code>reverse</code> 参数来倒序排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组和列表非常相似，也是用于存放元素的有序序列。它用的圆括号（<code>()</code>）表示，元素写入圆括号中，多个元素时用逗号分隔，如 <code>(1, 2, 3)</code>。</p>
<p>元组同样具有索引，索引使用方式与列表一致。其元素同样可以是任意类型。</p>
<p>看起来元组就是披着圆括号外衣的列表嘛！有什么区别？</p>
<p>元组创建完成后，便不能向其中添加元素，也不能修改和删除其中的任何一个元素。所以它与列表相比，只能查找元素，也就是说只具备读的功能，不具备写的功能。元组的这一特性叫作<strong>不可变（性）</strong>（Immutable），而列表是<strong>可变的</strong>（Mutable）。</p>
<h3 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h3><p>1.创建空的元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元组 = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line">()</span><br></pre></td></tr></table></figure>



<p>2.创建包含多个元素的元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元组 = (元素<span class="number">1</span>, 元素<span class="number">2</span>, ..., 元素N)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>



<p>3.创建只包含一个元素的元组</p>
<p>只包含一个元素的情况需要单独说明一下，因为它的形式与直觉不相符。</p>
<p>创建只包含一个元素的元组，需要在唯一的那个元素后面<strong>加上逗号</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元组 = (元素,)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure>

<p>这是因为，如果括号中只有一个元素，那么 Python 会将这个括号当作优先级符号进行处理（像数学中的那样），而不是当作元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = (<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(items)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> ‘<span class="title">int</span>’&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="元组元素的获取"><a href="#元组元素的获取" class="headerlink" title="元组元素的获取"></a>元组元素的获取</h3><p>1.通过索引获取元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元素 = 元组[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>]</span><br><span class="line">’c’</span><br></pre></td></tr></table></figure>



<p>2.通过元素获取索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">索引 = 元组.index(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.index(‘c’)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>3.查看元素是否存在于元组中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">布尔值 = 元素 <span class="keyword">in</span> 元组</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = (‘a’, ‘b’, ‘c’)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘a’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>‘z’ <span class="keyword">in</span> letters</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p>4.统计元素在元组中出现的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">个数 = 元组.count(元素)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.count(<span class="number">5</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<h2 id="元组和列表的差别"><a href="#元组和列表的差别" class="headerlink" title="元组和列表的差别"></a>元组和列表的差别</h2><p>我们可以看到，元组所具有的操作在使用方式上与和列表非常相似，甚至在一定程度上可以将元组看作是列表的精简版，但它们之间也有明显的差别。</p>
<ul>
<li>元组是不可变的（Immutable），列表是可变的（Mutable），元组在被创建之后，就不能添加、删除和修改元素，而列表可以</li>
<li>一般情况下元组的性能在略高于列表</li>
</ul>
<p>我们在什么时候用列表，什么时候用元组？</p>
<p>列表还是元组，通常性能不是从它们中做选择的主要考虑因素，因为它们之间的性能差异不是很大。我们的选择通常围绕着可变和不可变的特性进行，当我们需要添加元素或修改元素时，使用列表；当我们希望所有元素在创建之后便不再改变，可使用元组。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是 Python 中用来存放字符序列的数据类型，其中的元素只能是字符。字符串使用单引号或双引号来表示，如 <code>&#39;pick&#39;</code>，<code>&quot;cherry&quot;</code>，通常我们首先使用单引号。</p>
<p>字符串是有序序列，可以使用索引来获取其中某个位置的元素。它是不可变的，被创建之后其中的元素（也就是字符）不能被修改和删除。</p>
<h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><p>1.创建空字符串（即不包含字符的字符串）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串 = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string</span><br><span class="line">’’</span><br></pre></td></tr></table></figure>



<p>2.创建包含元素的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串 = <span class="string">'若干字符'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="string">'happy’</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; string</span></span><br><span class="line"><span class="string">’happy’</span></span><br></pre></td></tr></table></figure>



<h3 id="字符的获取"><a href="#字符的获取" class="headerlink" title="字符的获取"></a>字符的获取</h3><ol>
<li>通过索引获取字符<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符 = 字符串[索引]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string[<span class="number">2</span>]</span><br><span class="line">’p’</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>2.通过子串获取索引</p>
<p>所谓子串就是从字符串中截取下来的一部分，可以是一个字符，一部分字符、全部字符、或空字符串，如 <code>&#39;a&#39;</code>、<code>&#39;ppy&#39;</code>、<code>&#39;happy&#39;</code>、<code>&#39;&#39;</code> 都是 ‘happy’ 的子串。查找子串时，返回的是子串的第一个字符的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">索引 = 字符串.index(字符)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.index(‘p’)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = ‘happy’</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.index(‘app’)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>当字符或子串不存在时，<code>index</code> 方法将抛出 <code>ValueError</code> 错误。</p>
<p>也可采用字符串的 <code>find</code> 方法来查找子串，使用方式与 <code>index</code> 一致，不同点在于 <code>find</code> 方法未找到子串时返回数字 <code>-1</code>，而不抛异常。</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo d部署后需要在github上重新保存域名的问题</title>
    <url>/2020/02/01/18.hexo%20d%E9%83%A8%E7%BD%B2%E5%90%8E%E9%9C%80%E8%A6%81%E5%9C%A8github%E4%B8%8A%E9%87%8D%E6%96%B0%E4%BF%9D%E5%AD%98%E5%9F%9F%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>1.在根目录的source文件夹下新建一个CNAME文件（无后缀），内容就写自己的域名</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.maxinhong.com</span><br></pre></td></tr></table></figure>

<p>2.hexo g重新生成一下静态文件</p>
<p>3.hexo d部署</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive DDL之数据库操作</title>
    <url>/2020/01/30/17.Hive%20DDL%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>官方文档</strong>：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL</a></p>
<p>详情请看官方文档，本文只记录部分关键字便于回忆查询</p>
<p>DDL：Hive Data Definition Language</p>
<p>&emsp;&emsp;create、delete、alter…</p>
<p>Hive数据抽象/结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">database     HDFS一个目录</span><br><span class="line">	table    HDFS一个目录</span><br><span class="line">		data  文件 </span><br><span class="line">		partition 分区表  HDFS一个目录</span><br><span class="line">			data  文件 </span><br><span class="line">			bucket  分桶   HDFS一个文件</span><br></pre></td></tr></table></figure>



<p>创建数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (DATABASE|SCHEMA) [IF NOT EXISTS] database_name</span><br><span class="line">  [COMMENT database_comment]</span><br><span class="line">  [LOCATION hdfs_path]</span><br><span class="line">  [WITH DBPROPERTIES (property_name&#x3D;property_value, ...)];</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">CREATE DATABASE IF NOT EXISTS hive;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS hive2 LOCATION &#39;&#x2F;test&#x2F;location&#39;;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS hive3 WITH DBPROPERTIES(&#39;creator&#39;&#x3D;&#39;pearfl&#39;);</span><br></pre></td></tr></table></figure>

<p>/usr/hive/warehouse是Hive默认的存储在HDFS上的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD DATA LOCAL INPATH &#39;&#x2F;home&#x2F;hadoop&#x2F;data&#x2F;emp.txt&#39; OVERWRITE INTO TABLE emp;</span><br><span class="line"></span><br><span class="line">LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)]</span><br><span class="line"></span><br><span class="line">LOCAL：本地系统，如果没有local那么就是指的HDFS的路径</span><br><span class="line">OVERWRITE：是否数据覆盖，如果没有那么就是数据追加</span><br><span class="line"></span><br><span class="line">LOAD DATA LOCAL INPATH &#39;&#x2F;home&#x2F;hadoop&#x2F;data&#x2F;emp.txt&#39; OVERWRITE INTO TABLE emp;</span><br><span class="line"></span><br><span class="line">LOAD DATA INPATH &#39;hdfs:&#x2F;&#x2F;hadoop000:8020&#x2F;data&#x2F;emp.txt&#39; INTO TABLE emp;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT OVERWRITE LOCAL DIRECTORY &#39;&#x2F;tmp&#x2F;hive&#x2F;&#39;</span><br><span class="line">ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\t&#39;</span><br><span class="line">select empno,ename,sal,deptno from emp;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive部署</title>
    <url>/2020/01/28/16.Hive%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="Hive部署"><a href="#Hive部署" class="headerlink" title="Hive部署"></a>Hive部署</h2><p>1）下载</p>
<p>2）解压</p>
<p>3）添加HIVE_HOME到系统环境变量</p>
<p>4）修改配置 hive-env.sh</p>
<p>5）拷贝MySQL驱动包到$HIVE_HOME/lib</p>
<p>6）前提是要安装一个MySQL数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf hive-1.1.0-cdh5.16.2.tar.gz -C ~&#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line">配置.bash_profile</span><br><span class="line">export HIVE_HOME&#x3D;&#x2F;root&#x2F;app&#x2F;hive-1.1.0-cdh5.16.2</span><br><span class="line">export PATH&#x3D;$HIVE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>



<p>在hive文件夹的conf文件夹内进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cp hive-env.sh.template hive-env.sh</span><br></pre></td></tr></table></figure>

<p>若hadoop没有配置进环境变量，需要再hive-env.sh内配置HADOOP_HOME</p>
<p>配置hive-site.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;xsl&quot; href&#x3D;&quot;configuration.xsl&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionURL&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;jdbc:mysql:&#x2F;&#x2F;hadoop000:3306&#x2F;hadoop_hive?createDatabaseIfNotExist&#x3D;true&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;com.mysql.jdbc.Driver&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;root&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;root&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p>javax.jdo.option.ConnectionUserName对应mysql中的账号</p>
<p>javax.jdo.option.ConnectionPassword对应mysql中的密码</p>
<p>拷贝mysql的架包到hive文件夹下的lib文件夹中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp mysql-connector-java-5.1.28.jar &#x2F;root&#x2F;app&#x2F;hive-1.1.0-cdh5.16.2&#x2F;lib&#x2F;mysql-connector-java-5.1.28.jar</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j相关配置</title>
    <url>/2020/01/27/15.log4j%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>log4j.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootCategory&#x3D;info, console</span><br><span class="line">log4j.appender.console&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.target&#x3D;System.err</span><br><span class="line">log4j.appender.console.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern&#x3D;%p %c&#123;1&#125;: %m%n</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径算法</title>
    <url>/2020/01/26/14.%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><h3 id="1-Dijkstra-算法"><a href="#1-Dijkstra-算法" class="headerlink" title="1.$Dijkstra$算法"></a>1.$Dijkstra$算法</h3><p>解决单源最短路径问题常用 Dijkstra 算法，用于计算一个顶点到其他所有顶点的最短路径。Dijkstra 算法的主要特点是以起点为中心，逐层向外扩展（这一点类似于 bfs，但是不同的是，bfs 每次扩展一个层，但是 Dijkstra 每次只会扩展一个点），每次都会取一个最近点继续扩展，直到取完所有点为止。 </p>
<p>注意：Dijkstra 算法要求图中不能出现负权边。</p>
<h4 id="①、-Dijkstra-算法流程"><a href="#①、-Dijkstra-算法流程" class="headerlink" title="①、$Dijkstra$算法流程"></a>①、$Dijkstra$算法流程</h4><p>我们定义带权图$ G $所有顶点的集合为$ V$，接着我们再定义已确定从源点出发的最短路径的顶点集合为$ U$，初始集合 $U $为空，记从源点$ s $出发到每个顶点$ v $的距离为 $dist_v $，初始 $dist_s$=0。接着执行以下操作： </p>
<ol>
<li><p>从 $V−U $中找出一个距离源点最近的顶点$v$，将$v$加入集合$ U$。</p>
</li>
<li><p>并用 $dist_v$和顶点 $v $连出的边来更新和 $v $相邻的、不在集合 $U$中的顶点的 $dist$，这一步称为松弛操作。  </p>
</li>
<li><p>重复步骤 1 和 2，直到 $V=U$或找不出一个从$ s$ 出发有路径到达的顶点，算法结束。  </p>
</li>
</ol>
<p>如果最后 $V \neq U$，说明有顶点无法从源点到达；否则每个$ dist_i$表示从 $s$ 出发到顶点$ i $的最短距离。  </p>
<p>Dijkstra 算法的时间复杂度为$ \mathcal{O}(V^2)$，其中 $V$ 表示顶点的数量。</p>
<p>Dijkstra 是解决无负边权的图的单源最短路问题，经常使用邻接表存储。</p>
<p>不优化的时间复杂度是 $O(V^2 + E)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    edge() &#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[len] = edge(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    add(u, v, w);</span><br><span class="line">    add(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; mi) &#123;</span><br><span class="line">                mi = dis[u = j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mi == inf) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[u]; ~j; j = e[j].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[j].v;</span><br><span class="line">            <span class="keyword">int</span> w = e[j].w;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        add2(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dis[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="②、基于小根堆优化的-Dijkstra-算法"><a href="#②、基于小根堆优化的-Dijkstra-算法" class="headerlink" title="②、基于小根堆优化的$Dijkstra$算法"></a>②、基于小根堆优化的$Dijkstra$算法</h4><p>用一个set来维护点的集合，这样的时间复杂度就优化到了 $\mathcal{O}((V+E)\log V)$，对于稀疏图的优化效果非常好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125; e[MAX_M];</span><br><span class="line"><span class="keyword">int</span> p[MAX_N], eid, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mapinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    eid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权有向边</span></span><br><span class="line">    e[eid].v = v;</span><br><span class="line">    e[eid].w = w;</span><br><span class="line">    e[eid].next = p[u];</span><br><span class="line">    p[u] = eid++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权双向边</span></span><br><span class="line">    insert(u, v, w);</span><br><span class="line">    insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="built_in">set</span>&lt;PII, less&lt;PII&gt; &gt; min_heap;</span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];  <span class="comment">// 存储单源最短路的结果</span></span><br><span class="line"><span class="keyword">bool</span> vst[MAX_N];  <span class="comment">// 标记每个顶点是否在集合 U 中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 dist、小根堆和集合 U</span></span><br><span class="line">    <span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span>(vst));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    min_heap.insert(make_pair(<span class="number">0</span>, s));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min_heap.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;  <span class="comment">// 如果小根堆中没有可用顶点，说明有顶点无法从源点到达，算法结束</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取堆顶元素，并将堆顶元素从堆中删除</span></span><br><span class="line">        <span class="built_in">set</span>&lt;PII, less&lt;PII&gt; &gt;::iterator iter = min_heap.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> v = iter-&gt;second;</span><br><span class="line">        min_heap.erase(*iter);</span><br><span class="line">        vst[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 进行和普通 dijkstra 算法类似的松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = p[v]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = e[j].v;</span><br><span class="line">            <span class="keyword">if</span> (!vst[x] &amp;&amp; dist[v] + e[j].w &lt; dist[x]) &#123;</span><br><span class="line">                <span class="comment">// 先将对应的 pair 从堆中删除，再将更新后的 pair 插入堆</span></span><br><span class="line">                min_heap.erase(make_pair(dist[x], x));</span><br><span class="line">                dist[x] = dist[v] + e[j].w;</span><br><span class="line">                min_heap.insert(make_pair(dist[x], x));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 存储单源最短路的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="③、基于优先队列优化的-Dijkstra-算法"><a href="#③、基于优先队列优化的-Dijkstra-算法" class="headerlink" title="③、基于优先队列优化的$Dijkstra$算法"></a>③、基于优先队列优化的$Dijkstra$算法</h4><p>我们在 $node $节点里面记录对应的点的最短路，然后每次更新一个点的最短路后都把这个点压入到优先队列里面（不管之前有没有被压入到队列里面），这样就一定能够保证优先队列对的性质不会改变</p>
<p>这个代码的时间复杂度实际上会比用真正的堆要慢一点，因为有的点可能会入队多次，但是每一条边最多导致一次入队，所以这个算法的时间复杂度为 $\mathcal{O}(E\log E)$。其中$ E $为边的数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125; e[MAX_M];</span><br><span class="line"><span class="keyword">int</span> p[MAX_N], eid, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mapinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    eid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权有向边</span></span><br><span class="line">    e[eid].v = v;</span><br><span class="line">    e[eid].w = w;</span><br><span class="line">    e[eid].next = p[u];</span><br><span class="line">    p[u] = eid++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;  <span class="comment">// 插入带权双向边</span></span><br><span class="line">    insert(u, v, w);</span><br><span class="line">    insert(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];  <span class="comment">// 存储单源最短路的结果</span></span><br><span class="line"><span class="keyword">bool</span> vst[MAX_N];  <span class="comment">// 标记每个顶点是否在集合 U 中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">  <span class="keyword">int</span> dist;</span><br><span class="line">    node(<span class="keyword">int</span> _u, <span class="keyword">int</span> _dist) : u(_u), dist(_dist) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dist &gt; x.dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">// 记录点的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 dist、小根堆和集合 U</span></span><br><span class="line">    <span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span>(vst));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    priority_queue&lt;node&gt; min_heap;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    min_heap.push(node(s, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!min_heap.empty())</span><br><span class="line">        <span class="comment">// 获取堆顶元素，并将堆顶元素从堆中删除</span></span><br><span class="line">        <span class="keyword">int</span> v = min_heap.top().u;</span><br><span class="line">        min_heap.pop();</span><br><span class="line">        <span class="keyword">if</span> (vst[v]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vst[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 进行和普通 dijkstra 算法类似的松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = p[v]; j != <span class="number">-1</span>; j = e[j].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = e[j].v;</span><br><span class="line">            <span class="keyword">if</span> (!vst[x] &amp;&amp; dist[v] + e[j].w &lt; dist[x]) &#123;</span><br><span class="line">                dist[x] = dist[v] + e[j].w;</span><br><span class="line">                min_heap.push(node(x, dist[x]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-SPFA-算法"><a href="#2-SPFA-算法" class="headerlink" title="2.$SPFA$算法"></a>2.$SPFA$算法</h3><p>SPFA（Shortest Path Faster Algorithm）算法是单源最短路径的一种算法，通常被认为是 Bellman-ford 算法的队列优化，在代码形式上接近于宽度优先搜索 BFS，是一个在实践中非常高效的单源最短路算法。</p>
<h4 id="①、-SPFA-算法流程"><a href="#①、-SPFA-算法流程" class="headerlink" title="①、$SPFA$算法流程"></a>①、$SPFA$算法流程</h4><p>在 $SPFA$ 算法中，使用 $d_i$表示从源点到顶点$i$的最短路，额外用一个队列来保存即将进行拓展的顶点列表，并用 $inq_i$来标识顶点$i$是不是在队列中。</p>
<p>1.初始队列中仅包含源点，且源点 $s$ 的 $d_s=0$。</p>
<p>2.取出队列头顶点 $u$，扫描从顶点 $u$ 出发的每条边，设每条边的另一端为 $v$，边$&lt;u,v&gt;$ 权值为 $w$，若 $d_u+w&lt;d_v$，则 </p>
<ul>
<li><p>将 $d_v$修改为 $d_u+w$</p>
</li>
<li><p>若 $v$ 不在队列中，则 </p>
</li>
<li><p>将 $v $入队 </p>
</li>
</ul>
<p>3.重复步骤 2 直到队列为空 </p>
<p>最终$ d$ 数组就是从源点出发到每个顶点的最短路距离。如果一个顶点从没有入队，则说明没有从源点到该顶点的路径。</p>
<p>$SPFA$ 的空间复杂度为$ \mathcal{O}(V)$。如果顶点的平均入队次数为 $k$，则 $SPFA $的时间复杂度为 $\mathcal{O}(kE)$O，对于较为随机的稀疏图，根据经验 $k$ 一般不超过 4。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    edge()&#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail)&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[len] = edge(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    add(u, v, w);</span><br><span class="line">    add(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = head[u];~j;j = e[j].fail)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[j].v;</span><br><span class="line">            <span class="keyword">int</span> w = e[j].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w)&#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add2(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dis[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②、-SPFA-判断负环"><a href="#②、-SPFA-判断负环" class="headerlink" title="②、$SPFA$判断负环"></a>②、$SPFA$判断负环</h4><p>$Dijkstra$不能处理有负权的图，而 $SPFA$ 可以处理任意不含负环（负环是指总边权和为负数的环）的图的最短路，并能判断图中是否存在负环</p>
<p>但是 $SPFA $可以用来判断负环，在进行 $SPFA $时，用一个数组 $cnt_i$来标记每个顶点入队次数。如果一个顶点入队次数 $cnt_i$大于顶点总数 n，则表示该图中包含负环。一般情况下，$SPFA$ 判负环都只用在有向图上，因为在无向图上，一条负边权的边就是一个负环了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span> in);</span><br><span class="line">in[u] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 修改入队部分的操作</span></span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">    q.push(v);</span><br><span class="line">    vis[v] = <span class="literal">true</span>;</span><br><span class="line">    ++in[v];</span><br><span class="line">    <span class="keyword">if</span>(in[v] &gt; n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、-floyd-多源最短路算法"><a href="#3、-floyd-多源最短路算法" class="headerlink" title="3、$floyd$多源最短路算法"></a>3、$floyd$多源最短路算法</h3><p>$∀1≤k≤n,dp [i] [j] = min（dp[i] [j]，dp[i][k]+ dp [k][j]）$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL创建用户与授权</title>
    <url>/2020/01/24/13.MySQL%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1.创建用户"></a>1.创建用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</span><br></pre></td></tr></table></figure>

<p>username：你将创建的用户名<br>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%<br>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;dog&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;192.168.1.101_&#39; IDENDIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>





<h2 id="2-授权"><a href="#2-授权" class="headerlink" title="2.授权"></a>2.授权</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;</span><br></pre></td></tr></table></figure>

<p>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL<br>databasename：数据库名<br>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</p>
<p>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:<br>GRANT privileges ON databasename.tablename TO ‘username’@’host’ WITH GRANT OPTION;</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON maindataplus.* TO &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>



<h2 id="3-设置与更改用户密码"><a href="#3-设置与更改用户密码" class="headerlink" title="3.设置与更改用户密码"></a>3.设置与更改用户密码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; &#x3D; PASSWORD(&#39;newpassword&#39;);</span><br></pre></td></tr></table></figure>

<p>如果是当前登陆用户用:<br>SET PASSWORD = PASSWORD(“newpassword”);</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR &#39;pig&#39;@&#39;%&#39; &#x3D; PASSWORD(&quot;123456&quot;);</span><br></pre></td></tr></table></figure>



<h2 id="4-撤销用户权限"><a href="#4-撤销用户权限" class="headerlink" title="4.撤销用户权限"></a>4.撤销用户权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure>

<p>privilege, databasename, tablename：同授权部分</p>
<p>假如你在给用户‘pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。</p>
<p>相反，如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。</p>
<p>具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>



<h2 id="5-删除用户"><a href="#5-删除用户" class="headerlink" title="5.删除用户"></a>5.删除用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP USER &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7使用firewalld打开关闭防火墙与端口</title>
    <url>/2020/01/23/12.CentOS7%E4%BD%BF%E7%94%A8firewalld%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E7%AB%AF%E5%8F%A3%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="CentOS7使用firewalld打开关闭防火墙与端口"><a href="#CentOS7使用firewalld打开关闭防火墙与端口" class="headerlink" title="CentOS7使用firewalld打开关闭防火墙与端口"></a>CentOS7使用firewalld打开关闭防火墙与端口</h2><p>1、firewalld的基本使用</p>
<p>启动： systemctl start firewalld</p>
<p>关闭： systemctl stop firewalld</p>
<p>查看状态： systemctl status firewalld </p>
<p>开机禁用 ： systemctl disable firewalld</p>
<p>开机启用 ： systemctl enable firewalld</p>
<p>2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。</p>
<p>启动一个服务：systemctl start firewalld.service<br>关闭一个服务：systemctl stop firewalld.service<br>重启一个服务：systemctl restart firewalld.service<br>显示一个服务的状态：systemctl status firewalld.service<br>在开机时启用一个服务：systemctl enable firewalld.service<br>在开机时禁用一个服务：systemctl disable firewalld.service<br>查看服务是否开机启动：systemctl is-enabled firewalld.service<br>查看已启动的服务列表：systemctl list-unit-files|grep enabled<br>查看启动失败的服务列表：systemctl –failed</p>
<p>3.配置firewalld-cmd</p>
<p>查看版本： firewall-cmd –version</p>
<p>查看帮助： firewall-cmd –help</p>
<p>显示状态： firewall-cmd –state</p>
<p>查看所有打开的端口： firewall-cmd –zone=public –list-ports</p>
<p>更新防火墙规则： firewall-cmd –reload</p>
<p>查看区域信息:  firewall-cmd –get-active-zones</p>
<p>查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0</p>
<p>拒绝所有包：firewall-cmd –panic-on</p>
<p>取消拒绝状态： firewall-cmd –panic-off</p>
<p>查看是否拒绝： firewall-cmd –query-panic</p>
<p>那怎么开启一个端口呢</p>
<p>添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent   （--permanent永久生效，没有此参数重启后失效）</span><br></pre></td></tr></table></figure>

<p>重新载入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D; public --query-port&#x3D;80&#x2F;tcp</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D; public --remove-port&#x3D;80&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>firewalld</tag>
      </tags>
  </entry>
  <entry>
    <title>pip源以及virtualenv基本操作</title>
    <url>/2020/01/22/11.pip%E6%BA%90%E4%BB%A5%E5%8F%8Avirtualenv%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="virtualenv基本操作（windows环境）"><a href="#virtualenv基本操作（windows环境）" class="headerlink" title="virtualenv基本操作（windows环境）"></a>virtualenv基本操作（windows环境）</h2><p>1、下载virtualenv</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure>

<p>2、创建一个virtualenv工作目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir myproject_env</span><br></pre></td></tr></table></figure>

<p>3、穿件一个python项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtualenv venv</span><br></pre></td></tr></table></figure>

<p>4、启动virtualenv中的venv项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd venv\Scripts&#96;&#96;activate</span><br></pre></td></tr></table></figure>

<p>5、关闭virtualenv</p>
<p>需要在venv\Scripts内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>



<h2 id="pip源修改"><a href="#pip源修改" class="headerlink" title="pip源修改"></a>pip源修改</h2><p>国内源：<br>新版ubuntu要求使用https源，要注意。</p>
<p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>华中理工大学：<a href="http://pypi.hustunique.com/" target="_blank" rel="noopener">http://pypi.hustunique.com/</a></p>
<p>山东理工大学：<a href="http://pypi.sdutlinux.org/" target="_blank" rel="noopener">http://pypi.sdutlinux.org/</a></p>
<p>豆瓣：<a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></p>
<p>临时使用：<br>可以在使用pip的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>例如：pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyspider，这样就会从清华这边的镜像去安装pyspider库。</p>
<p>永久修改，一劳永逸：<br>Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)</p>
<p>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<p>windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini。内容同上。</p>
]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>无法停止hadoop集群</title>
    <url>/2020/01/20/10.%E6%97%A0%E6%B3%95%E5%81%9C%E6%AD%A2hadoop%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>问题描述：</p>
<p>执行 ./bin/stop-all.sh 脚本一直提示没有可停止的namenode、datanode、secondarynode。</p>
<p>可是输入 jps 命令，发现hadoop 已经启动。</p>
<p>原因：</p>
<p>hadoop在stop的时候依据的是datanode上的mapred和dfs进程号。而默认的进程号保存在/tmp下，linux默认会每 隔一段时间（一般是一个月或者7天左右）去删除这个目录下的文件。因此删掉hadoop-hadoop-jobtracker.pid和hadoop- hadoop-namenode.pid两个文件后，namenode自然就找不到datanode上的这两个进程了。</p>
<p>解决方法：</p>
<p>jps查看所有进程的pid，手动杀死进程 kill -9 pid，多个节点都需要操作！<br>为了避免下次也出现问题，在配置文件中$HADOOP_HOME/etc/hadoop/hadoop-env.sh中添加如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HADOOP_PID_DIR&#x3D;$&#123;HADOOP_HOME&#125;&#x2F;pids</span><br></pre></td></tr></table></figure>

<p>重启Hadoop集群，即可</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>DBWritable与Writable的坑</title>
    <url>/2020/01/18/%EF%BC%819.DBWritable%E4%B8%8EWritable%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>export HADOOP_CLASSPATH=$HADOOP_CLASSPATH:~/lib/mysql-connector-java-5.1.28-bin.jar</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql5.6安装</title>
    <url>/2020/01/15/8.mysql5.6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>本次操作在centos7.2版本的服务器上成功实现，本文不涉及rpm和源码安装2种方式，本文采用二进制安装</p>
<h2 id="1-首先我们需要卸载内置的mariadb"><a href="#1-首先我们需要卸载内置的mariadb" class="headerlink" title="1.首先我们需要卸载内置的mariadb"></a>1.首先我们需要卸载内置的mariadb</h2><p>原因是以前的Linux系统中数据库大部分是mysql，不过自从被sun收购之后，就没用集成在centos这些开源Linux系统中了，那么如果想用的话就需要自己安装了，首先centos7 已经不支持mysql，因为收费了你懂得，所以内部集成了mariadb，而安装mysql的话会和mariadb的文件冲突，所以需要先卸载掉mariadb</p>
<p>操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum search mysql &#x2F;&#x2F;检查是否有mariadb.x86_64</span><br><span class="line"># yum remove mariadb-libs.x86_64</span><br></pre></td></tr></table></figure>



<h2 id="2-下载mysql"><a href="#2-下载mysql" class="headerlink" title="2.下载mysql"></a>2.下载mysql</h2><p>安装包：mysql-5.6.47-linux-glibc2.12-x86_64.tar.gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 下载</span><br><span class="line">#wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;Downloads&#x2F;MySQL-5.6&#x2F;mysql-5.6.47-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line">&#x2F;&#x2F; 解压</span><br><span class="line"># tar -zxvf mysql-5.6.47-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line">&#x2F;&#x2F; 复制解压后的mysql目录</span><br><span class="line"># cp -r mysql-5.6.47-linux-glibc2.12-x86_64 &#x2F;usr&#x2F;local&#x2F;mysql</span><br></pre></td></tr></table></figure>



<h2 id="3-添加用户组和用户"><a href="#3-添加用户组和用户" class="headerlink" title="3.添加用户组和用户"></a>3.添加用户组和用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;添加用户组</span><br><span class="line"># groupadd mysql</span><br><span class="line">&#x2F;&#x2F;添加用户mysql 到用户组mysql</span><br><span class="line"># useradd -g mysql mysql</span><br></pre></td></tr></table></figure>



<h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4.安装"></a>4.安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;</span><br><span class="line"># mkdir .&#x2F;data&#x2F;mysql</span><br><span class="line"># chown -R mysql:mysql .&#x2F;</span><br><span class="line"># .&#x2F;scripts&#x2F;mysql_install_db --user&#x3D;mysql --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql</span><br><span class="line"># cp support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br><span class="line"># chmod 755 &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br><span class="line"># cp support-files&#x2F;my-default.cnf &#x2F;etc&#x2F;my.cnf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;修改启动脚本</span><br><span class="line"># vi &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;修改项：</span><br><span class="line">basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;</span><br><span class="line">datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动服务</span><br><span class="line"># service mysqld start</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加入环境变量，编辑 &#x2F;etc&#x2F;profile，这样可以在任何地方用mysql命令了</span><br><span class="line"># export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;&#x2F;bin&lt;br&gt;source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动mysql</span><br><span class="line"># service mysqld start</span><br><span class="line">&#x2F;&#x2F;关闭mysql</span><br><span class="line"># service mysqld stop</span><br><span class="line">&#x2F;&#x2F;查看运行状态</span><br><span class="line"># service mysqld status</span><br></pre></td></tr></table></figure>



<p>可能出现的问题↓</p>
<p>问题1:：FATAL ERROR: please install the following Perl modules before executing</p>
<p>问题原因：缺少autoconf库</p>
<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install autoconf</span><br></pre></td></tr></table></figure>



<p>问题2：Installing MySQL system tables…./bin/mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory</p>
<p>问题原因：缺少libaio库文件</p>
<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install libaio*</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>手机流量统计-自定义序列化类</title>
    <url>/2020/01/14/7.%E6%89%8B%E6%9C%BA%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB/</url>
    <content><![CDATA[<p>Access.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Writable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInput;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutput;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Access</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> up;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> down;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone + <span class="string">'\t'</span> + up + <span class="string">'\t'</span> + down + <span class="string">'\t'</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Access</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Access</span><span class="params">(String phone, <span class="keyword">long</span> up, <span class="keyword">long</span> down)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        <span class="keyword">this</span>.up = up;</span><br><span class="line">        <span class="keyword">this</span>.down = down;</span><br><span class="line">        <span class="keyword">this</span>.sum = up + down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeUTF(phone);</span><br><span class="line">        dataOutput.writeLong(up);</span><br><span class="line">        dataOutput.writeLong(down);</span><br><span class="line">        dataOutput.writeLong(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = dataInput.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.up = dataInput.readLong();</span><br><span class="line">        <span class="keyword">this</span>.down = dataInput.readLong();</span><br><span class="line">        <span class="keyword">this</span>.sum = dataInput.readLong();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> up;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">(<span class="keyword">long</span> up)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.up = up;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDown</span><span class="params">(<span class="keyword">long</span> down)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.down = down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">(<span class="keyword">long</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SerDriver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ruozedata.bigdata.hadoop.utils.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 千篇一律</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 获取Job对象</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 本job对应要执行的主类是哪个</span></span><br><span class="line">        job.setJarByClass(SerDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(MyMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(MyReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 设置Mapper阶段输出数据的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(Access<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 设置Reducer阶段输出数据的类型</span></span><br><span class="line">        job.setOutputKeyClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(Access<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6) 设置输入和输出路径</span></span><br><span class="line">        String input = <span class="string">"data/access.log"</span>;</span><br><span class="line">        String output = <span class="string">"out"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FileUtils.deleteOutput(configuration, output);</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(input));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(output));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7) 提交作业</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Access</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String[] splits = value.toString().split(<span class="string">"\t"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手机号</span></span><br><span class="line">            String phone = splits[<span class="number">1</span>]; <span class="comment">//index是从0开始的</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上行流量</span></span><br><span class="line">            <span class="keyword">long</span> up = Long.parseLong(splits[splits.length - <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下行流量</span></span><br><span class="line">            <span class="keyword">long</span> down = Long.parseLong(splits[splits.length - <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写出去</span></span><br><span class="line"><span class="comment">//            Access access = new Access();</span></span><br><span class="line"><span class="comment">//            access.setPhone(phone);</span></span><br><span class="line"><span class="comment">//            access.setUp(up);</span></span><br><span class="line"><span class="comment">//            access.setDown(down);</span></span><br><span class="line"><span class="comment">//            access.setSum(up + down);</span></span><br><span class="line"></span><br><span class="line">            context.write(<span class="keyword">new</span> Text(phone), <span class="keyword">new</span> Access(phone, up, down));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">Access</span>, <span class="title">NullWritable</span>, <span class="title">Access</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text phone, Iterable&lt;Access&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> ups = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> downs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            Iterator&lt;Access&gt; iterator = values.iterator();</span></span><br><span class="line"><span class="comment">//            while(iterator.hasNext())&#123;</span></span><br><span class="line"><span class="comment">//                Access next = iterator.next();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(Access access : values)&#123;</span><br><span class="line">                ups += access.getUp();</span><br><span class="line">                downs += access.getDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            context.write(NullWritable.get(), <span class="keyword">new</span> Access(phone.toString(), ups, downs));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>hdfs简单API编程</title>
    <url>/2020/01/07/6.hdfs%E7%AE%80%E5%8D%95API%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.permission.FsPermission;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HDFSAPITest2</span> </span>&#123;</span><br><span class="line">    FileSystem fileSystem;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        URI uri = <span class="keyword">new</span> URI(<span class="string">"hdfs://hadoop:8020"</span>);</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line"></span><br><span class="line">        configuration.set(<span class="string">"dfs.client.use.datanode.hostname"</span>, <span class="string">"true"</span>);</span><br><span class="line">        configuration.set(<span class="string">"dfs.replication"</span>, <span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">// 1) 获取HDFS客户端</span></span><br><span class="line">        fileSystem = FileSystem.get(uri, configuration, <span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 3) 关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(fileSystem != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fileSystem.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mkdir</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        fileSystem.mkdirs(<span class="keyword">new</span> Path(<span class="string">"hdfs://hadoop:8020/hdfstest0"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFromLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Path src = <span class="keyword">new</span> Path(<span class="string">"data/ruozedata.txt"</span>);</span><br><span class="line">        Path dst = <span class="keyword">new</span> Path(<span class="string">"/hdfstest"</span>);</span><br><span class="line">        fileSystem.copyFromLocalFile(src, dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyToLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Path src = <span class="keyword">new</span> Path(<span class="string">"/20201011/146.txt"</span>);</span><br><span class="line">        Path dst = <span class="keyword">new</span> Path(<span class="string">"output/146.txt"</span>);</span><br><span class="line">        fileSystem.copyToLocalFile(src, dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rename</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Path src = <span class="keyword">new</span> Path(<span class="string">"/20201011/20201011-0.txt"</span>);</span><br><span class="line">        Path dst = <span class="keyword">new</span> Path(<span class="string">"/20201011/146.txt"</span>);</span><br><span class="line">        fileSystem.rename(src, dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RemoteIterator&lt;LocatedFileStatus&gt; files = fileSystem.listFiles(<span class="keyword">new</span> Path(<span class="string">"/20201011"</span>), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(files.hasNext())&#123;</span><br><span class="line">            LocatedFileStatus fileStatus = files.next();</span><br><span class="line">            String path = fileStatus.getPath().toString();</span><br><span class="line">            <span class="keyword">long</span> len = fileStatus.getLen();</span><br><span class="line">            <span class="keyword">short</span> replication = fileStatus.getReplication();</span><br><span class="line">            FsPermission permission = fileStatus.getPermission();</span><br><span class="line">            String isDir = fileStatus.isDirectory()? <span class="string">"文件夹"</span> : <span class="string">"文件"</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(path + <span class="string">"\t"</span> + len + <span class="string">"\t"</span> + replication + <span class="string">"\t"</span> + permission + <span class="string">"\t"</span> + isDir);</span><br><span class="line"></span><br><span class="line">            BlockLocation[] blockLocations = fileStatus.getBlockLocations();</span><br><span class="line">            <span class="keyword">for</span>(BlockLocation location : blockLocations)&#123;</span><br><span class="line">                String[] hosts = location.getHosts();</span><br><span class="line">                <span class="keyword">for</span>(String host : hosts)&#123;</span><br><span class="line">                    System.out.println(host + <span class="string">"........"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        fileSystem.delete(<span class="keyword">new</span> Path(<span class="string">"/hdfstest"</span>), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop单结点集群搭建</title>
    <url>/2020/01/06/5.hadoop%E5%8D%95%E7%BB%93%E7%82%B9%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>官网描述:<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="noopener">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html</a></p>
<p>本文在官网描述的基础上做翻译和细节补充</p>
<h2 id="hadoop部署"><a href="#hadoop部署" class="headerlink" title="hadoop部署"></a>hadoop部署</h2><p>类似于前一篇章的jdk部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf hadoop-2.6.0-cdh5.16.2.tar.gz -C ~&#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line">hadoop软件包常见目录说明</span><br><span class="line">	bin: hadoop客户端命令</span><br><span class="line">	etc: hadoop相关的配置文件存放目录</span><br><span class="line">	sbin:启动hadoop相关进程的脚本</span><br><span class="line">	share:常用例子</span><br><span class="line"></span><br><span class="line">配置.bash_profile</span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;root&#x2F;app&#x2F;hadoop-2.6.0-cdh5.16.2</span><br><span class="line">export PATH&#x3D;$HADOOP_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>



<p>修改相关的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop-env.sh内需要配置JAVA_HOME</span><br><span class="line">localhost:8020中的localhost需要修改</span><br><span class="line"></span><br><span class="line">core-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:8020&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">hdfs-site.xml</span><br><span class="line">其中hadoop.tmp.dir修改是因为机器每次重启时候会清空tmp目录</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;root&#x2F;app&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">slaves</span><br><span class="line">	mxh(设置成你喜欢的就行了，注意需要与hostname一致)</span><br></pre></td></tr></table></figure>



<p>启动HDFS：第一次执行的时候一定要格式化文件系统，不要重复执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>


<p>启动集群</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$HADOOP_HOME&#x2F;sbin&#x2F;start-dfs.sh</span><br><span class="line">验证:</span><br><span class="line">#jps</span><br><span class="line">8148 NameNode</span><br><span class="line">8245 DataNode</span><br><span class="line">8540 SecondaryNameNode</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop学习前置部署</title>
    <url>/2020/01/04/4.hadoop%E5%AD%A6%E4%B9%A0%E5%89%8D%E6%9C%9F%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="jdk部署"><a href="#jdk部署" class="headerlink" title="jdk部署"></a>jdk部署</h2><p><strong>Hadoop安装前置要求Java版本在1.8+</strong></p>
<p>安装过程（本过程在root用户下进行，非root用户目录有轻微变动）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拷贝本地软件包到服务器（wget等方法均可）</span><br><span class="line"></span><br><span class="line">解压jdk:tar -zvxf jdk-8u231-linux-x64.tar.gz -C ~&#x2F;app&#x2F;</span><br><span class="line"># 解压的包放置在app文件夹内，根据个人需要选择</span><br><span class="line"></span><br><span class="line">把jdk配置在系统环境变量中: ~&#x2F;.bash_profile</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;root&#x2F;app&#x2F;jdk1.8.0_231</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">之后source一下使其生效:source .bash_profile</span><br><span class="line">可以通过echo $JAVA_HOME检查是否生效</span><br><span class="line">提示：此处&#x3D;左右不可有空格</span><br></pre></td></tr></table></figure>



<h2 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ssh-keygen -t rsa  #一路回车</span><br><span class="line">此时.ssh文件夹下有3个新文件</span><br><span class="line">id_rsa          # 私钥</span><br><span class="line">id_rsa.pub      # 公钥</span><br><span class="line">known_hosts     # </span><br><span class="line"></span><br><span class="line"># cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line"># chmod 600 authorized_keys</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>linux用户管理</title>
    <url>/2019/12/30/3.linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="简易命令"><a href="#简易命令" class="headerlink" title="简易命令"></a>简易命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd testuser  创建用户testuser</span><br><span class="line">passwd testuser  给已创建的用户testuser设置密码</span><br><span class="line">说明：新创建的用户会在&#x2F;home下创建一个用户目录testuser</span><br><span class="line">usermod --help  修改用户这个命令的相关参数</span><br><span class="line">userdel testuser  删除用户testuser</span><br><span class="line">rm -rf testuser  删除用户testuser所在目录</span><br></pre></td></tr></table></figure>



<h2 id="给用户添加root权限"><a href="#给用户添加root权限" class="headerlink" title="给用户添加root权限"></a>给用户添加root权限</h2><p>使用Linux系统时，经常会被要求使用超级权限，但是root的权限太过大了，一般慎用！！！因此可以通过给普通用户添加sudo权限，平常用普通用户进行操作，当需要root权限的时候进行sudo操作。以下为解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 进入超级用户模式，也就是输入”su root”，系统会让你输入超级用户密码，输入密码后就进入了超级用户模式。（当然，你也可以直接用root进入修改）</span><br><span class="line">2. 添加文件的写权限，也就是输入命令”chmod u+w &#x2F;etc&#x2F;sudoers”。</span><br><span class="line">3. 编辑&#x2F;etc&#x2F;sudoers文件，也就是输入命令”vim &#x2F;etc&#x2F;sudoers”，进入编辑模式，找到这一 行：”root ALL&#x3D;(ALL) ALL”（会用vim编辑器的可以使用“&#x2F;root ALL&#x3D;(ALL)ALL”定位）在其下面添加”xxx ALL&#x3D;(ALL) ALL”(这里的xxx是你的用户名)，然后保存退出。</span><br><span class="line">4. 撤销文件的写权限，也就是输入命令”chmod u-w &#x2F;etc&#x2F;sudoers”。</span><br></pre></td></tr></table></figure>



<h2 id="修改hostname"><a href="#修改hostname" class="headerlink" title="修改hostname"></a>修改hostname</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hostnamectl set-hostname &lt;newhostname&gt;</span><br></pre></td></tr></table></figure>





<h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><p>用户：使用操作系统的人</p>
<p>用户组：具有相同系统权限的一组用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;group 存储当前系统中所有用户组信息</span><br><span class="line">- Group:     x    : 123 : abc,def,xyz</span><br><span class="line">- 组名称:组密码占位符:组编号:组中用户列表名</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;gshadow 存储当前系统中用户组的密码信息</span><br><span class="line">- Group:  *  :       :abc,def,xyz</span><br><span class="line">- 组名称:组密码:组管理者:组中用户列表名</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;passwd 存储当前系统中所有用户的信息</span><br><span class="line">- user :    x   :   123 :   456   : xxxxxxx : &#x2F;home&#x2F;user : &#x2F;bin&#x2F;bash</span><br><span class="line">- 用户名:密码占位符:用户编号:用户组编号:用户注释信息: 用户主目录  : shell类型</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;shadow 存储当前系统中所有用户的密码信息</span><br><span class="line">- user : xxx :::::</span><br><span class="line">- 用户名: 密码 ::::</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一套样例</span><br><span class="line"></span><br><span class="line"># groupadd sexy 创建sexy用户组</span><br><span class="line"># groupadd -n market sexy 用sexy组名改为market</span><br><span class="line"># groupmod -g 668 market 修改market用户组编号</span><br><span class="line"># groupadd -g 888 boss 创建boss用户组，编号为888</span><br><span class="line"># groupdel market 删除market用户组</span><br><span class="line"># useradd -g sexy sdf 添加用户</span><br><span class="line"># useradd -g sexy jzmb</span><br><span class="line"># useradd -d &#x2F;home&#x2F;xxx imooc 添加用户并指定用户文件夹所在位置</span><br><span class="line"># usermod -c dgdzmx sdf 修改sdf注释</span><br><span class="line"># usermod -l cls sdf 用户名sdf更改为cls</span><br><span class="line"># usermod -d &#x2F;home&#x2F;cls cls 修改cls文件夹路径</span><br><span class="line"># usermod -g sexy imooc imooc切换进sexy用户组</span><br><span class="line"># userdel jzmb 删除jzmb账号</span><br><span class="line"># userdel -r jzmb 删除jzmb用户文件夹</span><br><span class="line"></span><br><span class="line">touch &#x2F;etc&#x2F;nologin 禁止root以外的其他账户登录</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd -l cls 锁定cls</span><br><span class="line"># passwd -u cls 解锁cls</span><br><span class="line"># passwd -d cls cls账户无密码登录</span><br></pre></td></tr></table></figure>



<h2 id="主要组和附属组"><a href="#主要组和附属组" class="headerlink" title="主要组和附属组"></a>主要组和附属组</h2><p>用户可以同时属于多个组</p>
<ul>
<li>一个主要组</li>
<li>多个附属组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一套样例</span><br><span class="line"></span><br><span class="line"># gpasswd -a cls boss boss组变为cls的附属组,用逗号可以添加多个附属组</span><br><span class="line"># newgrp boss （cls自己执行，切换到boss组）</span><br><span class="line"># gpasswd -a cls boss cls不在是boss组的附属组</span><br></pre></td></tr></table></figure>







<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>权限</tag>
        <tag>linux</tag>
        <tag>用户</tag>
      </tags>
  </entry>
  <entry>
    <title>frp实现内网穿透</title>
    <url>/2019/12/29/%EF%BC%812.frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;对于没有公网ip的内网用户来说，远程管理或在外网访问内网机器上的服务是一个比较麻烦的问题，为了解决这个问题，我介绍一款相当好用的内网穿透工具frp。<br>&emsp;&emsp;frp 是一个使用 Go 语言开发的高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务。FRP 支持 TCP、UDP、HTTP、HTTPS等协议类型，并且支持 Web 服务根据域名进行路由转发。<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frp项目地址: https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp</span><br></pre></td></tr></table></figure>



<h1 id="frp的作用"><a href="#frp的作用" class="headerlink" title="frp的作用"></a>frp的作用</h1><p>1.利用处于内网或防火墙后的机器，对外网环境提供 HTTP 或 HTTPS 服务。</p>
<p>2.对于 HTTP, HTTPS 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个 80 端口。</p>
<p>3.利用处于内网或防火墙后的机器，对外网环境提供 TCP 和 UDP 服务，例如在家里通过 SSH 访问处于公司内网环境内的主机。</p>
<h1 id="frp安装"><a href="#frp安装" class="headerlink" title="frp安装"></a>frp安装</h1><p>FRP 采用 Go 语言开发，支持 Windows、Linux、MacOS、ARM等多平台部署。FRP 安装非常容易，只需下载对应系统平台的软件包，并解压就可用。</p>
<p>这里以 Linux 为例，为了方便管理我们把解压后的目录重命名为 frp ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.30.0&#x2F;frp_0.30.0_linux_amd64.tar.gz</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔分享</category>
      </categories>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>新篇章，新世界</title>
    <url>/2019/12/23/1.hello-world/</url>
    <content><![CDATA[<p>&emsp;&emsp;我在之前的hexo博客中写了50+篇文章，但质量都不太让我满意，解决问题的效率甚至比不上百度，恰巧之前的文档因操作失误丢失了，于是我就重置了整个博客内容从零开始</p>
<p>&emsp;&emsp;今后的每一篇文章我都会尽心尽力而为，不灌水，如果对文章有问题或者想要交流的小伙伴，可以加我的qq或给我发送邮件进行联系。</p>
<p>&emsp;&emsp;那么，加油！</p>
]]></content>
      <categories>
        <category>个人感想</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
