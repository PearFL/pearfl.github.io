---
title: leetcode-java基础技巧
date: 2020-2-6 15:33:32
tags:
 - leetcode
categories: 算法与数据结构
---

之前打算法竞赛一直是用C+STL，包括牛客网上写题练习也是用这个方式来解决的，长期习惯了以后，开始对java刷题甚至产生了排斥……但鉴于java以后肯定是要常用的，因此必须矫正这个问题

本篇博文讲述刷leetcode过程中采用java语言遇到的坑，明明一眼就知道该怎么写但不能用其他语言写出来就是不行啊！

根据自己经验，有竞赛基础的建议直接从周赛题开始摸坑=3=（倒着刷）

（本文长期更新）



## 1.String转int、long

```java
String s = "123"
int n1 = Integer.parseInt(s);
long n2 = Long.parseLong(s); 
```



## 2.StringBuffer

StringBuffer类和String一样，也用来代表字符串，只是由于StringBuffer的内部实现方式和String不同，所以StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些.

StringBuffer与String有一个显著的区别：**StringBuffer对象的每次修改都会改变对象自身**

StringBuffer是线程安全的，所以在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些



1.String转StringBuffer

```java
StringBuffer s = new StringBuffer("abc");
```

2.append方法，将内容追加到StringBuffer末尾

```java
StringBuffer s = new StringBuffer("abc");
s.append("efg");
System.out.println(s.toString());
```

3.delete方法

deleteCharAt(int index)
该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。第一位为0
s.delete(int start,int end)
该方法的作用是删除指定区间以内的所有字符，包含start，不包含end索引值的区间。

```java
StringBuffer s = new StringBuffer("abc");
s.append("efg");
s.deleteCharAt(2);
s.delete(0,2);
System.out.println(s.toString());
```

4.insert方法

StringBuffer insert(int offset, String str)
该方法的作用是在StringBuffer对象中插入内容，然后形成新的字符串

```java
StringBuffer sb = new StringBuffer("TestString");
sb.insert(4,"hello");
System.out.println(sb.toString());
```

5.reverse方法

StringBuffer reverse()
该方法的作用是将StringBuffer对象中的内容反转，然后形成新的字符串

```java
StringBuffer sb = new StringBuffer("TestString");
sb.reverse();
System.out.println(sb.toString());
```

6.setCharAt方法

setCharAt(int index, char ch)
该方法的作用是修改对象中索引值为index位置的字符为新的字符ch

```java
StringBuffer sb = new StringBuffer("bc");
sb.setCharAt(1,'D');
```



## 3.数组排序

Arrays.Sort() 快排

```
Arrays.sort(arys[])
Arrays.sort(arys[],int from,int to) // 排序范围:from-->to-1
Arrays.sort(arys[],new MyComparator())
Arrays.sort(arys[],int from,int to,new MyComparator())
```

Arrays.sort()方法可对任何实现compareble接口的对象数组排序, 像Integer,String这两种引用类型都实现了compareble接口，所以这两种类型的数组都可直接使用Arrays.sort()进行排序。



1.数字排序

```java
int[] intArray = new int[] { 4, 1, 3, -23 };
Arrays.sort(intArray);

输出： [-23, 1, 3, 4]
```



2.字符串排序，先大写后小写 String[] strArray = new String[] { "z", "a", "C" };

```java
String[] strArray = new String[] { "z", "a", "C" };
Arrays.sort(strArray);

输出： [C, a, z]
```



3.严格按字母表顺序排序，也就是忽略大小写排序 Case-insensitive sort

```java
Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);

输出： [a, C, z]
```



4.反向排序,Reverse-order sort

```java
Arrays.sort(strArray, Collections.reverseOrder());

输出：[z, a, C]
```



5.忽略大小写反向排序 Case-insensitive reverse-order sort

```java
Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);
Collections.reverse(Arrays.asList(strArray));

输出： [z, C, a]
```



Collections.sort模板

```java
Collections.sort(list, new Comparator<String>() {
    public int compare(String str1, String str2) {

        /**
　　　　　　* 升序排的话就是第一个参数.compareTo(第二个参数);
　　　　　　* 降序排的话就是第二个参数.compareTo(第一个参数);
　　　　　　*/

        // 按首字母升序排
        // return str1.compareTo(str2);
        // 按第二个字母升序排
        char c1 = str1.charAt(1);
        char c2 = str2.charAt(1);
        return c1 - c2;
    }
});
```





